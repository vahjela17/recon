'use strict';Object.defineProperty(exports,"__esModule",{value:!0});class e{constructor(){this._callbacks={},this._callbackActive={}}_addCallback(e,t,a,n=!1){e&&"string"==typeof e&&t&&(!this._callbacks[e]&&(this._callbacks[e]=[]),this._callbackActive[e]&&this._callbackActive[e]===this._callbacks[e]&&(this._callbackActive[e]=this._callbackActive[e].slice()),this._callbacks[e].push({callback:t,scope:a||this,once:n}))}on(e,t,a){return this._addCallback(e,t,a,!1),this}off(e,t,a){if(e)this._callbackActive[e]&&this._callbackActive[e]===this._callbacks[e]&&(this._callbackActive[e]=this._callbackActive[e].slice());else for(const e in this._callbackActive)this._callbacks[e]&&this._callbacks[e]===this._callbackActive[e]&&(this._callbackActive[e]=this._callbackActive[e].slice());if(!e)this._callbacks={};else if(!t)this._callbacks[e]&&(this._callbacks[e]=[]);else{const n=this._callbacks[e];if(!n)return this;let r=n.length;for(let e=0;e<r;e++)n[e].callback===t&&(a&&n[e].scope!==a||(n[e--]=n[--r]));n.length=r}return this}fire(e,t,a,n,r,o,s,d,l){if(!e||!this._callbacks[e])return this;let c;this._callbackActive[e]?(this._callbackActive[e]===this._callbacks[e]&&(this._callbackActive[e]=this._callbackActive[e].slice()),c=this._callbacks[e].slice()):this._callbackActive[e]=this._callbacks[e];for(let p=0;(c||this._callbackActive[e])&&p<(c||this._callbackActive[e]).length;p++){const i=(c||this._callbackActive[e])[p];if(i.callback.call(i.scope,t,a,n,r,o,s,d,l),i.once){const t=this._callbacks[e].indexOf(i);-1!==t&&(this._callbackActive[e]===this._callbacks[e]&&(this._callbackActive[e]=this._callbackActive[e].slice()),this._callbacks[e].splice(t,1))}}return c||(this._callbackActive[e]=void 0),this}once(e,t,a){return this._addCallback(e,t,a,!0),this}hasEvent(e){return this._callbacks[e]&&0!==this._callbacks[e].length||!1}}var t=effect.Amaz;class a extends e{constructor(e,t){super(),this.sceneObject=e,this.nativeClass=t,e&&t&&(this.native=e.native.addComponent(t))}static registerComponentType(e,t,a){this._typeToComponent.has(e)?console.warn("Component::Register component type more than once! Type: "+e):this._typeToComponent.set(e,a);for(const n of t)this._nativeToComponent.has(n)?console.warn("Component::Register native component more than once! Type: "+e):this._nativeToComponent.set(n,a)}static getComponentFromType(e){return this._typeToComponent.get(e)}static getComponentFronNative(e){return this._nativeToComponent.get(Object.getPrototypeOf(e).RTTI.Name)}initialize(e,t){for(let a=0;a<t.length;a++){const n=t[a];e&&e.hasOwnProperty(n)&&(this[n]=e[n])}}initWithNative(e,t,a){this.sceneObject=e,this.native=t,this.nativeClass=a}destroy(){this.sceneObject&&this.nativeClass&&(this.sceneObject.native.removeComponent(this.nativeClass),this.sceneObject=void 0)}addListener(e,a,n){if(this.native)t.AmazingManager.addListener(this.native,e,a,n);else throw new Error("Invalid native component in Component:addListener")}removeListener(e,a){if(this.native)t.AmazingManager.removeListener(this.native,e,a);else throw new Error("Invalid native component in Component:removeListener")}get enabled(){return this.native.enabled}set enabled(e){this.native.enabled=e}}a._typeToComponent=new Map,a._nativeToComponent=new Map;var n=effect.Amaz;class r{static createQuadMesh(){const e=new n.Mesh,t=new n.VertexAttribDesc;t.semantic=n.VertexAttribType.POSITION;const a=new n.VertexAttribDesc;a.semantic=n.VertexAttribType.TEXCOORD0;const r=new n.Vector;r.insert(0,t),r.insert(1,a),e.vertexAttribs=r;const i=-1,o=1,s=1,d=[o,s,0,1,1,o,i,0,1,0,-1,i,0,0,0,-1,s,0,0,1],l=new n.FloatVector;for(let e=0;e<d.length;++e)l.insert(e,d[e]);e.vertices=l;const c=new n.SubMesh;c.primitive=n.Primitive.TRIANGLES;const p=[0,1,2,2,3,0],u=new n.UInt16Vector;for(let e=0;e<p.length;++e)u.insert(e,p[e]);return c.indices16=u,c.mesh=e,e.addSubMesh(c),e}}class i{static toPascalCase(e){return e?`${e}`.replace(new RegExp(/[-_]+/,"g")," ").replace(new RegExp(/[^\w\s]/,"g"),"").replace(new RegExp(/\s+(.)(\w*)/,"g"),(e,t,a)=>`${t.toUpperCase()+a.toLowerCase()}`).replace(new RegExp(/\w/),e=>e.toUpperCase()):e}static getFilename(e){return e.substring(e.lastIndexOf("/")+1)}}class o{static createShaderPass(e,t){const a=new n.Pass;a.shaders=e;const r=new n.Map;return r.insert("inPosition",n.VertexAttribType.POSITION),r.insert("inTexCoord",n.VertexAttribType.TEXCOORD0),a.semantics=r,a.renderState=t,a}static createScreenMaterial(e){const t=new n.RenderState;t.viewport=new n.ViewportState,t.viewport.rect=new n.Rect(0,0,1,1),t.viewport.minDepth=0,t.viewport.maxDepth=1;const a=this.createShaderPass(e,t);return this.createMaterial(a)}static createMaterial(e){const t=new n.XShader;t.passes.pushBack(e);const a=new n.Material;a.xshader=t;const r=new n.PropertySheet;return a.properties=r,a}static createRenderTexture(){const e=new n.RenderTexture;return e.depth=1,e.width=640,e.height=360,e.filterMag=n.FilterMode.LINEAR,e.filterMin=n.FilterMode.LINEAR,e.filterMipmap=n.FilterMipmapMode.NONE,e.attachment=n.RenderTextureAttachment.NONE,e}static createRenderTexturePlus(e,t,a,r){const i=new n.RenderTexture;return i.builtinType=n.BuiltInTextureType.NORAML,i.internalFormat=n.InternalFormat.RGBA8,i.dataType=n.DataType.U8norm,i.depth=1,i.attachment=n.RenderTextureAttachment.DEPTH24,i.filterMag=r,i.filterMin=r,i.filterMipmap=n.FilterMipmapMode.NONE,i.width=e,i.height=t,i.colorFormat=a,i}static createTexture2D(){const e=new n.Texture2D;return e.filterMin=n.FilterMode.LINEAR,e.filterMag=n.FilterMode.LINEAR,e}static createShaders(e){const t=new n.Map;for(const a in e){const r=new n.Shader;r.type=n.ShaderType.VERTEX,r.source=e[a].vs;const i=new n.Shader;i.type=n.ShaderType.FRAGMENT,i.source=e[a].fs;const o=new n.Vector;o.insert(0,r),o.insert(1,i),t.insert(a,o)}return t}static createEmptyMaterial(){const e=new n.Material,t=new n.XShader;e.xshader=t;const a=new n.PropertySheet;return e.properties=a,e}static addPassToMaterial(e,t,a,r=!1){const i=new n.Pass,o=new n.Map;for(const i in t){const e=new n.Shader;e.type=n.ShaderType.VERTEX,e.source=t[i].vs;const a=new n.Shader;a.type=n.ShaderType.FRAGMENT,a.source=t[i].fs;const r=new n.Vector;r.pushBack(e),r.pushBack(a),o.insert(i,r)}i.shaders=o;const s=new n.Map;s.insert("inPosition",n.VertexAttribType.POSITION),s.insert("inTexCoord",n.VertexAttribType.TEXCOORD0),i.semantics=s;const d=new n.DepthStencilState;d.depthTestEnable=!1;const l=new n.RenderState;if(l.depthstencil=d,a){d.stencilTestEnable=!0;const e=new n.StencilOpState;e.compareOp=n.CompareOp.EQUAL,e.reference=42,e.writeMask=0,d.stencilFront=e,d.stencilBack=e}if(r){const e=new n.Vector,t=new n.ColorBlendAttachmentState;t.blendEnable=r,t.srcColorBlendFactor=n.BlendFactor.SRC_ALPHA,t.dstColorBlendFactor=n.BlendFactor.ONE_MINUS_SRC_ALPHA,t.srcAlphaBlendFactor=n.BlendFactor.SRC_ALPHA,t.dstAlphaBlendFactor=n.BlendFactor.ONE_MINUS_SRC_ALPHA,t.ColorBlendOp=n.BlendOp.ADD,t.AlphaBlendOp=n.BlendOp.ADD,e.pushBack(t),l.colorBlend=new n.ColorBlendState,l.colorBlend.attachments=e}return i.renderState=l,e.xshader.passes.pushBack(i),i}}class s{constructor(){this._screenMesh=r.createQuadMesh(),this._cmdBuffer=new n.CommandBuffer,this._cmdBufferDirty=!1}onPreUpdate(){this._cmdBuffer.clearAll()}onPostUpdate(){const e=Li.scene.native;e&&this._cmdBufferDirty&&(e.commitCommandBuffer(this._cmdBuffer),this._cmdBufferDirty=!1)}get screenMesh(){return this._screenMesh}cmdBufferSetRenderTexture(e){this._cmdBuffer.setRenderTexture(e),this._cmdBufferDirty=!0}cmdBufferClearRenderTexture(e,t,a,n){this._cmdBuffer.clearRenderTexture(e,t,a,n),this._cmdBufferDirty=!0}cmdBufferDrawMesh(e,t,a,n,r,i){this._cmdBuffer.drawMesh(e,t.native,a,n,r,i),this._cmdBufferDirty=!0}cmdBufferBlit(e,t){this._cmdBuffer.blit(e,t),this._cmdBufferDirty=!0}}class d{static doesSDKSupport(e){const t=n.VERSION.split(".").map(e=>parseInt(e)),a=e.split(".").map(e=>parseInt(e));if(t.length==a.length){for(let e=0;e<t.length;++e){if(a[e]<t[e])return!0;if(a[e]>t[e])return!1}return!0}return!1}}const l="5.8.3",c="10.5.0",p="11.0.0",u="11.7.0",m="11.2.0",g="12.0.0",f="12.8.0",_="14.0.0";(function(e){e.Core="Core",e.Gesture="Gesture",e.Audio="Audio",e.Analytics="Analytics",e.ObjectReferenceInScript="ObjectReferenceInScript",e.RenderChainEvent="RenderChainEvent"})(exports.Feature||(exports.Feature={}));const h=new Map([[exports.Feature.Core,c],[exports.Feature.Gesture,p],[exports.Feature.Audio,m],[exports.Feature.Analytics,g],[exports.Feature.ObjectReferenceInScript,f],[exports.Feature.RenderChainEvent,_]]);var y=effect.Amaz;class v{constructor(e,t,a,n){this._supportMemoryMapping=d.doesSDKSupport(u),this._native=e instanceof y.Color?e:new y.Color(null==e?1:e,null==t?1:t,null==a?1:a,null==n?1:n),this._values=this._supportMemoryMapping?new Float32Array(this._native.getBuffer()):new Float32Array}static fromNative(e){return new v(e)}static eq(e,t){return t&&e&&e.r===t.r&&e.g===t.g&&e.b===t.b&&e.a===t.a}get native(){return this._native}set(e,t,n,r){return this.a=r,this.r=e,this.g=t,this.b=n,this}get r(){return this._supportMemoryMapping?this._values[v.R]:this._native.r}set r(e){this._supportMemoryMapping?this._values[v.R]=Math.fround(e):this._native.r=e}get g(){return this._supportMemoryMapping?this._values[v.G]:this._native.g}set g(e){this._supportMemoryMapping?this._values[v.G]=Math.fround(e):this._native.g=e}get b(){return this._supportMemoryMapping?this._values[v.B]:this._native.b}set b(e){this._supportMemoryMapping?this._values[v.B]=Math.fround(e):this._native.b=e}get a(){return this._supportMemoryMapping?this._values[v.A]:this._native.a}set a(e){this._supportMemoryMapping?this._values[v.A]=Math.fround(e):this._native.a=e}eq(e){return e&&this.r===e.r&&this.g===e.g&&this.b===e.b&&this.a===e.a}toString(){return`color(R: ${this.r.toFixed(3)}, G: ${this.g.toFixed(3)}, B: ${this.b.toFixed(3)}, A: ${this.a.toFixed(3)})`}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this.a=e.a,this}clone(){return new v(this.r,this.g,this.b,this.a)}static lerp(e,a,n,r){var i=Math.min,o=Math.max;return void 0===r&&(r=new v),n=i(1,o(0,n)),r.r=e.r+n*(a.r-e.r),r.g=e.g+n*(a.g-e.g),r.b=e.b+n*(a.b-e.b),r.a=e.a+n*(a.a-e.a),r}}v.R=0,v.G=1,v.B=2,v.A=3;var T=effect.Amaz;class C{constructor(e,t,a,n){this._supportMemoryMapping=d.doesSDKSupport(u),this._native=e instanceof T.Rect?e:new T.Rect(null==e?0:e,null==t?0:t,null==a?0:a,null==n?0:n),this._values=this._supportMemoryMapping?new Float32Array(this._native.getBuffer()):new Float32Array}static fromNative(e){return new C(e)}static eq(e,t){return t&&e&&e.x===t.x&&e.y===t.y&&e.width===t.width&&e.height===t.height}get native(){return this._native}get x(){return this._supportMemoryMapping?this._values[C.X]:this._native.x}set x(e){this._supportMemoryMapping?this._values[C.X]=Math.fround(e):this._native.x=e}get y(){return this._supportMemoryMapping?this._values[C.Y]:this._native.y}set y(e){this._supportMemoryMapping?this._values[C.Y]=Math.fround(e):this._native.y=e}get width(){return this._supportMemoryMapping?this._values[C.Width]:this._native.width}set width(e){this._supportMemoryMapping?this._values[C.Width]=Math.fround(e):this._native.width=e}get height(){return this._supportMemoryMapping?this._values[C.Height]:this._native.height}set height(e){this._supportMemoryMapping?this._values[C.Height]=Math.fround(e):this._native.height=e}eq(e){return e&&this.x===e.x&&this.y===e.y&&this.width===e.width&&this.height===e.height}toString(){return`Rect(${this.x.toFixed(5)}, ${this.y.toFixed(5)}, ${this.width.toFixed(5)}, ${this.height.toFixed(5)})`}copy(e){return this.x=e.x,this.y=e.y,this.width=e.width,this.height=e.height,this}clone(){return new C(this.x,this.y,this.width,this.height)}}C.X=0,C.Y=1,C.Width=2,C.Height=3;var x=effect.Amaz,S=x.PixelFormat,M=x.MSAAMode,F=x.RenderTextureAttachment,P=x.Primitive,R=x.WrapMode,A=x.FilterMode,I=x.FilterMipmapMode,b=x.ShaderType,E=x.RendererType,z=x.CullFace,B=x.FrontFace,L=x.PolygonMode,O=x.CompareOp,k=x.BlendFactor,N=x.BlendOp;(function(e){e[e.Portrait=0]="Portrait",e[e.Landscape=1]="Landscape"})(exports.DeviceOrientationMode||(exports.DeviceOrientationMode={})),function(e){var t,a;e[e.Perspective=null==(t=x.CameraType)?void 0:t.PERSPECTIVE]="Perspective",e[e.Orthographic=null==(a=x.CameraType)?void 0:a.ORTHO]="Orthographic"}(exports.CameraType||(exports.CameraType={})),function(e){var t,a,n,r,i;e[e.AfterRender=null==(t=x.CameraEvent)?void 0:t.AFTER_RENDER]="AfterRender",e[e.BeforeRender=null==(a=x.CameraEvent)?void 0:a.BEFORE_RENDER]="BeforeRender",e[e.AfterEverything=null==(n=x.CameraEvent)?void 0:n.AFTER_EVERYTHING]="AfterEverything",e[e.AfterImageEffects=null==(r=x.CameraEvent)?void 0:r.AFTER_IMAGE_EFFECTS]="AfterImageEffects",e[e.RenderImageEffects=null==(i=x.CameraEvent)?void 0:i.RENDER_IMAGE_EFFECTS]="RenderImageEffects"}(exports.CameraRenderEvent||(exports.CameraRenderEvent={})),function(e){var t,a,n,r,i;e[e.Position=null==(t=x.VertexAttribType)?void 0:t.POSITION]="Position",e[e.Normal=null==(a=x.VertexAttribType)?void 0:a.NORMAL]="Normal",e[e.Tangent=null==(n=x.VertexAttribType)?void 0:n.TANGENT]="Tangent",e[e.Color=null==(r=x.VertexAttribType)?void 0:r.COLOR]="Color",e[e.Texcoord0=null==(i=x.VertexAttribType)?void 0:i.TEXCOORD0]="Texcoord0"}(exports.VertexAttribType||(exports.VertexAttribType={})),function(e){e[e.Directional=0]="Directional",e[e.Point=1]="Point",e[e.Spot=2]="Spot"}(exports.LightType||(exports.LightType={})),function(e){e[e.Box=0]="Box",e[e.Sphere=1]="Sphere",e[e.Capsule=2]="Capsule"}(exports.Collider3DType||(exports.Collider3DType={})),function(e){var t,a,n;e[e.Static=null==(t=x.RigidBodyType)?void 0:t.STATIC]="Static",e[e.Kinematic=null==(a=x.RigidBodyType)?void 0:a.KINEMATIC]="Kinematic",e[e.Dynamic=null==(n=x.RigidBodyType)?void 0:n.DYNAMIC]="Dynamic"}(exports.Physics3DType||(exports.Physics3DType={})),function(e){var t,a,n,r,i,o,s;e[e.Fit=null==(t=x.StretchMode)?void 0:t.fit]="Fit",e[e.Fill=null==(a=x.StretchMode)?void 0:a.fill]="Fill",e[e.FitWidth=null==(n=x.StretchMode)?void 0:n.fit_width]="FitWidth",e[e.FitHeight=null==(r=x.StretchMode)?void 0:r.fit_height]="FitHeight",e[e.Stretch=null==(i=x.StretchMode)?void 0:i.stretch]="Stretch",e[e.FillCut=null==(o=x.StretchMode)?void 0:o.fill_cut]="FillCut",e[e.ImageSize=null==(s=x.StretchMode)?void 0:s.texture_size]="ImageSize"}(exports.SpriteRenderMode||(exports.SpriteRenderMode={})),function(e){var t,a,n,r,i,o,s;e[e.Normal=null==(t=x.IFSprite2dType)?void 0:t.Normal]="Normal",e[e.Tiled=null==(a=x.IFSprite2dType)?void 0:a.Tiled]="Tiled",e[e.Sliced=null==(n=x.IFSprite2dType)?void 0:n.Sliced]="Sliced",e[e.Filled=null==(r=x.IFSprite2dType)?void 0:r.Filled]="Filled",e[e.Ellipse=null==(i=x.IFSprite2dType)?void 0:i.Ellipse]="Ellipse",e[e.Free=null==(o=x.IFSprite2dType)?void 0:o.Free]="Free",e[e.Corner=null==(s=x.IFSprite2dType)?void 0:s.Corner]="Corner"}(exports.ImageRenderMode||(exports.ImageRenderMode={})),function(e){var t,a,n;e[e.Horizontal=null==(t=x.IFFilledType)?void 0:t.Horizontal]="Horizontal",e[e.Vertical=null==(a=x.IFFilledType)?void 0:a.Vertical]="Vertical",e[e.Radial=null==(n=x.IFFilledType)?void 0:n.Radial]="Radial"}(exports.ImageFillType||(exports.ImageFillType={})),function(e){var t,a,n,r,i,o,s,d,l,c,p,u,m,g,f,_,h,y,v,T,C,S,M,F,P,R,A,I;e[e.Normal=null==(t=x.IFBlendMode)?void 0:t.Normal]="Normal",e[e.Add=null==(a=x.IFBlendMode)?void 0:a.Add]="Add",e[e.Average=null==(n=x.IFBlendMode)?void 0:n.Average]="Average",e[e.Burn=null==(r=x.IFBlendMode)?void 0:r.Burn]="Burn",e[e.Dodge=null==(i=x.IFBlendMode)?void 0:i.Dodge]="Dodge",e[e.Darken=null==(o=x.IFBlendMode)?void 0:o.Darken]="Darken",e[e.Difference=null==(s=x.IFBlendMode)?void 0:s.Difference]="Difference",e[e.Exclusion=null==(d=x.IFBlendMode)?void 0:d.Exclusion]="Exclusion",e[e.Glow=null==(l=x.IFBlendMode)?void 0:l.Glow]="Glow",e[e.HardLight=null==(c=x.IFBlendMode)?void 0:c.Hardlight]="HardLight",e[e.HardMix=null==(p=x.IFBlendMode)?void 0:p.Hardmix]="HardMix",e[e.Lighten=null==(u=x.IFBlendMode)?void 0:u.Lighten]="Lighten",e[e.LinearBurn=null==(m=x.IFBlendMode)?void 0:m.Linearburn]="LinearBurn",e[e.LinearDodge=null==(g=x.IFBlendMode)?void 0:g.Lineardodge]="LinearDodge",e[e.LinearLight=null==(f=x.IFBlendMode)?void 0:f.Linearlight]="LinearLight",e[e.Multiply=null==(_=x.IFBlendMode)?void 0:_.Multiply]="Multiply",e[e.Negation=null==(h=x.IFBlendMode)?void 0:h.Negation]="Negation",e[e.Overlay=null==(y=x.IFBlendMode)?void 0:y.Overlay]="Overlay",e[e.Phoenix=null==(v=x.IFBlendMode)?void 0:v.Phoenix]="Phoenix",e[e.PinLight=null==(T=x.IFBlendMode)?void 0:T.Pinlight]="PinLight",e[e.Reflect=null==(C=x.IFBlendMode)?void 0:C.Reflect]="Reflect",e[e.Screen=null==(S=x.IFBlendMode)?void 0:S.Screen]="Screen",e[e.Softlight=null==(M=x.IFBlendMode)?void 0:M.Softlight]="Softlight",e[e.Substract=null==(F=x.IFBlendMode)?void 0:F.Substract]="Substract",e[e.VividLight=null==(P=x.IFBlendMode)?void 0:P.Vividlight]="VividLight",e[e.SnowColor=null==(R=x.IFBlendMode)?void 0:R.Snowcolor]="SnowColor",e[e.SnowHue=null==(A=x.IFBlendMode)?void 0:A.Snowhue]="SnowHue",e[e.EndFlag=null==(I=x.IFBlendMode)?void 0:I.EndFlag]="EndFlag"}(exports.CanvasBlendMode||(exports.CanvasBlendMode={})),function(e){var t,a,n,r;e[e.None=null==(t=x.IFMaskType)?void 0:t.None]="None",e[e.Rect=null==(a=x.IFMaskType)?void 0:a.Rect]="Rect",e[e.Ellipse=null==(n=x.IFMaskType)?void 0:n.Ellipse]="Ellipse",e[e.Sprites=null==(r=x.IFMaskType)?void 0:r.MaskSprites]="Sprites"}(exports.CanvasMaskType||(exports.CanvasMaskType={})),function(e){var t,a;e[e.Overlay=null==(t=x.IFLayer2dRenderOrderMode)?void 0:t.ScreenOverlay]="Overlay",e[e.Custom=null==(a=x.IFLayer2dRenderOrderMode)?void 0:a.SceneCustom]="Custom"}(exports.CanvasRenderOrder||(exports.CanvasRenderOrder={})),function(e){var t,a,n,r;e[e.Once=null==(t=x.PlayMode)?void 0:t.once]="Once",e[e.Loop=null==(a=x.PlayMode)?void 0:a.loop]="Loop",e[e.PingPong=null==(n=x.PlayMode)?void 0:n.pingpong]="PingPong",e[e.Random=null==(r=x.PlayMode)?void 0:r.random]="Random"}(exports.SeqAnimationPlayMode||(exports.SeqAnimationPlayMode={})),function(e){var t,a,n,r,i;e[e.Origin=null==(t=x.IFResolutionType)?void 0:t.Origin]="Origin",e[e.FitWidth=null==(a=x.IFResolutionType)?void 0:a.FitWidth]="FitWidth",e[e.FitHeight=null==(n=x.IFResolutionType)?void 0:n.FitHeight]="FitHeight",e[e.Fit=null==(r=x.IFResolutionType)?void 0:r.Fit]="Fit",e[e.Fill=null==(i=x.IFResolutionType)?void 0:i.Fill]="Fill"}(exports.CanvasScalerType||(exports.CanvasScalerType={})),function(e){e[e.Box=0]="Box"}(exports.UIColliderType||(exports.UIColliderType={})),function(e){var t,a,n;e[e.Follow=null==(t=x.IFUISliderMode)?void 0:t.FOLLOW]="Follow",e[e.Offset=null==(a=x.IFUISliderMode)?void 0:a.OFFSET]="Offset",e[e.DragThumb=null==(n=x.IFUISliderMode)?void 0:n.DRAG_THUMB]="DragThumb"}(exports.SliderMode||(exports.SliderMode={})),function(e){var t,a,n,r;e[e.LeftRight=null==(t=x.IFUIMoveDirection)?void 0:t.LEFT_TO_RIGHT]="LeftRight",e[e.RightLeft=null==(a=x.IFUIMoveDirection)?void 0:a.RIGHT_TO_LEFT]="RightLeft",e[e.BottomTop=null==(n=x.IFUIMoveDirection)?void 0:n.BOTTOM_TO_TOP]="BottomTop",e[e.TopBottom=null==(r=x.IFUIMoveDirection)?void 0:r.TOP_TO_BOTTOM]="TopBottom"}(exports.UIMoveDirection||(exports.UIMoveDirection={})),function(e){var t,a,n;e[e.System=null==(t=x.IFUILabelFontType)?void 0:t.System]="System",e[e.TrueType=null==(a=x.IFUILabelFontType)?void 0:a.TrueType]="TrueType",e[e.Bitmap=null==(n=x.IFUILabelFontType)?void 0:n.Bitmap]="Bitmap"}(exports.LabelFontType||(exports.LabelFontType={})),function(e){var t,a,n;e[e.Left=null==(t=x.IFUILabelAlignment)?void 0:t.Left]="Left",e[e.Right=null==(a=x.IFUILabelAlignment)?void 0:a.Right]="Right",e[e.Center=null==(n=x.IFUILabelAlignment)?void 0:n.Center]="Center"}(exports.LabelAlignment||(exports.LabelAlignment={})),function(e){var t,a,n;e[e.AutoSize=null==(t=x.IFUILabelFitType)?void 0:t.AutoSize]="AutoSize",e[e.FitWidth=null==(a=x.IFUILabelFitType)?void 0:a.FitWidth]="FitWidth",e[e.FitSize=null==(n=x.IFUILabelFitType)?void 0:n.FitSize]="FitSize"}(exports.LabelFitType||(exports.LabelFitType={})),function(e){var t,a,n,r;e[e.None=null==(t=x.IFUIGridType)?void 0:t.NONE]="None",e[e.Horizontal=null==(a=x.IFUIGridType)?void 0:a.HORIZONTAL]="Horizontal",e[e.Vertical=null==(n=x.IFUIGridType)?void 0:n.VERTICAL]="Vertical",e[e.Grid=null==(r=x.IFUIGridType)?void 0:r.GRID]="Grid"}(exports.LayoutType||(exports.LayoutType={})),function(e){var t,a,n;e[e.None=null==(t=x.IFUIGridResizeMode)?void 0:t.NONE]="None",e[e.Container=null==(a=x.IFUIGridResizeMode)?void 0:a.CONTAINER]="Container",e[e.Children=null==(n=x.IFUIGridResizeMode)?void 0:n.CHILDREN]="Children"}(exports.LayoutSizeMode||(exports.LayoutSizeMode={})),function(e){var t,a;e[e.Horizontal=null==(t=x.IFUIGridStartAxis)?void 0:t.HORIZONTAL]="Horizontal",e[e.Vertical=null==(a=x.IFUIGridStartAxis)?void 0:a.VERTICAL]="Vertical"}(exports.LayoutGridMode||(exports.LayoutGridMode={})),function(e){var t,a;e[e.TopBottom=null==(t=x.IFUIGridVerticalDirection)?void 0:t.TOP_TO_BOTTOM]="TopBottom",e[e.BottomTop=null==(a=x.IFUIGridVerticalDirection)?void 0:a.BOTTOM_TO_TOP]="BottomTop"}(exports.LayoutVerticalDirection||(exports.LayoutVerticalDirection={})),function(e){var t,a;e[e.LeftRight=null==(t=x.IFUIGridHorizontalDirection)?void 0:t.LEFT_TO_RIGHT]="LeftRight",e[e.RightLeft=null==(a=x.IFUIGridHorizontalDirection)?void 0:a.RIGHT_TO_LEFT]="RightLeft"}(exports.LayoutHorizontalDirection||(exports.LayoutHorizontalDirection={})),function(e){var t,a;e[e.None=null==(t=x.IFUIGridSortingType)?void 0:t.NONE]="None",e[e.Alphabetic=null==(a=x.IFUIGridSortingType)?void 0:a.ALPHABETIC]="Alphabetic"}(exports.LayoutSortMode||(exports.LayoutSortMode={})),function(e){e.Head="head",e.Body="body",e.Hair="hair",e.Sky="sky",e.Building="building",e.Cloth="cloth",e.Ground="ground",e.Hand="hand"}(exports.SegmentationType||(exports.SegmentationType={}));const D=64,w=32;(function(e){e[e.Once=1]="Once",e[e.Loop=0]="Loop",e[e.PingPong=-1]="PingPong",e[e.Clamp=-2]="Clamp",e[e.Seek=-3]="Seek"})(exports.AnimationPlayMode||(exports.AnimationPlayMode={})),function(e){var t,a,n,r;e[e.Billboard=null==(t=x.ParticleQuatRendererOrientationType)?void 0:t.BILLBOARD]="Billboard",e[e.Direction=null==(a=x.ParticleQuatRendererOrientationType)?void 0:a.DIRECTION]="Direction",e[e.Shape=null==(n=x.ParticleQuatRendererOrientationType)?void 0:n.SHAPE]="Shape",e[e.Fixed=null==(r=x.ParticleQuatRendererOrientationType)?void 0:r.FIXED]="Fixed"}(exports.ParticleSystemRenderOrientation||(exports.ParticleSystemRenderOrientation={})),function(e){var t,a,n;e[e.ByDistance=null==(t=x.ParticleRenderSortingMode)?void 0:t.BY_DISTANCE]="ByDistance",e[e.OldestInFront=null==(a=x.ParticleRenderSortingMode)?void 0:a.OLDEST_IN_FRONT]="OldestInFront",e[e.YoungestInFront=null==(n=x.ParticleRenderSortingMode)?void 0:n.YOUNGEST_IN_FRONT]="YoungestInFront"}(exports.ParticleSystemRenderSortingMode||(exports.ParticleSystemRenderSortingMode={})),function(e){e[e.Quad=0]="Quad",e[e.Mesh=1]="Mesh"}(exports.ParticleSystemRenderType||(exports.ParticleSystemRenderType={})),function(e){var t,a;e[e.ScaleByParticle=null==(t=x.ParticleMeshRendererType)?void 0:t.SCALE_BY_PARTICLE]="ScaleByParticle",e[e.SizeByParticle=null==(a=x.ParticleMeshRendererType)?void 0:a.SIZE_BY_PARTICLE]="SizeByParticle"}(exports.ParticleSystemRenderDisplayMode||(exports.ParticleSystemRenderDisplayMode={})),function(e){e[e.None=0]="None",e[e.Color=1]="Color"}(exports.ParticleSystemAffector||(exports.ParticleSystemAffector={})),function(e){var t,a,n;e[e.Set=null==(t=x.ColorOperation)?void 0:t.SET]="Set",e[e.Multiply=null==(a=x.ColorOperation)?void 0:a.MULTIPLY]="Multiply",e[e.Random=null==(n=x.ColorOperation)?void 0:n.RANDOM]="Random"}(exports.ParticleSystemColorAffectorOperation||(exports.ParticleSystemColorAffectorOperation={})),function(e){e[e.Unknown=0]="Unknown",e[e.Human=1]="Human",e[e.Cat=2]="Cat",e[e.Dog=3]="Dog"}(exports.FaceType||(exports.FaceType={})),function(e){e[e.Whole=0]="Whole",e[e.LeftEye=1]="LeftEye",e[e.RightEye=2]="RightEye",e[e.Nose=3]="Nose",e[e.Mouth=4]="Mouth",e[e.LeftEyeBrow=5]="LeftEyeBrow",e[e.RightEyeBrow=6]="RightEyeBrow",e[e.LeftEar=7]="LeftEar",e[e.RightEar=8]="RightEar",e[e.Contour=9]="Contour"}(exports.FacePart||(exports.FacePart={})),function(e){e[e.Unknown=0]="Unknown",e[e.Angry=1]="Angry",e[e.Disgust=2]="Disgust",e[e.Fear=3]="Fear",e[e.Happy=4]="Happy",e[e.Sad=5]="Sad",e[e.Surprise=6]="Surprise",e[e.Neutral=7]="Neutral"}(exports.FaceExpression||(exports.FaceExpression={})),function(e){e.Detected="detected",e.Lost="lost"}(exports.FaceEvent||(exports.FaceEvent={})),function(e){e[e.None=0]="None",e[e.EyeBlink=1]="EyeBlink",e[e.EyeBlinkLeft=2]="EyeBlinkLeft",e[e.EyeBlinkRight=3]="EyeBlinkRight",e[e.MouthAh=4]="MouthAh",e[e.MouthPout=5]="MouthPout",e[e.HeadYaw=6]="HeadYaw",e[e.HeadPitch=7]="HeadPitch",e[e.BrowJump=8]="BrowJump",e[e.SideNod=9]="SideNod"}(exports.FaceAction||(exports.FaceAction={})),function(e){e[e.Face106=0]="Face106",e[e.Face240=1]="Face240",e[e.Face280=2]="Face280",e[e.Face3d=3]="Face3d",e[e.PetV2=4]="PetV2"}(exports.FaceLandmarkType||(exports.FaceLandmarkType={})),function(e){e.Lost="lost",e.Detected="detected",e.StaticGesture="staticGesture",e.DynamicGesture="dynamicGesture"}(exports.HandEvent||(exports.HandEvent={})),function(e){e[e.HeartA=0]="HeartA",e[e.HeartB=1]="HeartB",e[e.HeartC=2]="HeartC",e[e.HeartD=3]="HeartD",e[e.OK=4]="OK",e[e.HandOpen=5]="HandOpen",e[e.ThumbUp=6]="ThumbUp",e[e.ThumbDown=7]="ThumbDown",e[e.Rock=8]="Rock",e[e.Namaste=9]="Namaste",e[e.PalmUp=10]="PalmUp",e[e.Fist=11]="Fist",e[e.IndexFingerUp=12]="IndexFingerUp",e[e.DoubleFingerUp=13]="DoubleFingerUp",e[e.Victory=14]="Victory",e[e.BigV=15]="BigV",e[e.PhoneCall=16]="PhoneCall",e[e.Beg=17]="Beg",e[e.Thanks=18]="Thanks",e[e.Unknown=19]="Unknown",e[e.Cabbage=20]="Cabbage",e[e.Three=21]="Three",e[e.Four=22]="Four",e[e.Pistol=23]="Pistol",e[e.Rock2=24]="Rock2",e[e.Swear=25]="Swear",e[e.HoldFace=26]="HoldFace",e[e.Salute=27]="Salute",e[e.Spread=28]="Spread",e[e.Pray=29]="Pray",e[e.QiGong=30]="QiGong",e[e.Slide=31]="Slide",e[e.PalmDown=32]="PalmDown",e[e.Pistol2=33]="Pistol2",e[e.NinjaMudra1=34]="NinjaMudra1",e[e.NinjaMudra2=35]="NinjaMudra2",e[e.NinjaMudra3=36]="NinjaMudra3",e[e.NinjaMudra4=37]="NinjaMudra4",e[e.NinjaMudra5=38]="NinjaMudra5",e[e.NinjaMudra6=39]="NinjaMudra6",e[e.NinjaMudra7=40]="NinjaMudra7",e[e.NinjaMudra8=41]="NinjaMudra8",e[e.NinjaMudra9=42]="NinjaMudra9",e[e.NinjaMudra10=43]="NinjaMudra10",e[e.NinjaMudra11=44]="NinjaMudra11",e[e.SpiderHand=45]="SpiderHand",e[e.AvengerHand=46]="AvengerHand",e[e.MaxCount=47]="MaxCount",e[e.Undetect=48]="Undetect",e[e.None=99]="None"}(exports.HandStaticGesture||(exports.HandStaticGesture={})),function(e){e[e.None=0]="None",e[e.Punching=1]="Punching",e[e.Clapping=2]="Clapping",e[e.HighFive=4]="HighFive"}(exports.HandDynamicGesture||(exports.HandDynamicGesture={})),function(e){e[e.Wrist=0]="Wrist",e[e.Thumb3=1]="Thumb3",e[e.Thumb2=2]="Thumb2",e[e.Thumb1=3]="Thumb1",e[e.Thumb0=4]="Thumb0",e[e.Index3=5]="Index3",e[e.Index2=6]="Index2",e[e.Index1=7]="Index1",e[e.Index0=8]="Index0",e[e.Middle3=9]="Middle3",e[e.Middle2=10]="Middle2",e[e.Middle1=11]="Middle1",e[e.Middle0=12]="Middle0",e[e.Ring3=13]="Ring3",e[e.Ring2=14]="Ring2",e[e.Ring1=15]="Ring1",e[e.Ring0=16]="Ring0",e[e.Pinky3=17]="Pinky3",e[e.Pinky2=18]="Pinky2",e[e.Pinky1=19]="Pinky1",e[e.Pinky0=20]="Pinky0",e[e.Center=21]="Center"}(exports.HandKeyPoint||(exports.HandKeyPoint={})),function(e){e.Detected="detected",e.Lost="lost",e.Action="action"}(exports.BodyEvent||(exports.BodyEvent={})),function(e){e[e.Nose=0]="Nose",e[e.Neck=1]="Neck",e[e.RightShoulder=2]="RightShoulder",e[e.RightElbow=3]="RightElbow",e[e.RightWrist=4]="RightWrist",e[e.LeftShoulder=5]="LeftShoulder",e[e.LeftElbow=6]="LeftElbow",e[e.LeftWrist=7]="LeftWrist",e[e.RightHip=8]="RightHip",e[e.RightKnee=9]="RightKnee",e[e.RightAnkle=10]="RightAnkle",e[e.LeftHip=11]="LeftHip",e[e.LeftKnee=12]="LeftKnee",e[e.LeftAnkle=13]="LeftAnkle",e[e.RightEye=14]="RightEye",e[e.LeftEye=15]="LeftEye",e[e.RightEar=16]="RightEar",e[e.LeftEar=17]="LeftEar"}(exports.Body2DKeyPointType||(exports.Body2DKeyPointType={})),function(e){e[e.Hips=0]="Hips",e[e.LeftUpLeg=1]="LeftUpLeg",e[e.RightUpLeg=2]="RightUpLeg",e[e.Spine=3]="Spine",e[e.LeftLeg=4]="LeftLeg",e[e.RightLeg=5]="RightLeg",e[e.Spine1=6]="Spine1",e[e.LeftFoot=7]="LeftFoot",e[e.RightFoot=8]="RightFoot",e[e.Spine2=9]="Spine2",e[e.LeftToe=10]="LeftToe",e[e.RightToe=11]="RightToe",e[e.Neck=12]="Neck",e[e.LeftShoulder=13]="LeftShoulder",e[e.RightShoulder=14]="RightShoulder",e[e.Head=15]="Head",e[e.LeftArm=16]="LeftArm",e[e.RightArm=17]="RightArm",e[e.LeftForeArm=18]="LeftForeArm",e[e.RightForeArm=19]="RightForeArm",e[e.LeftHand=20]="LeftHand",e[e.RightHand=21]="RightHand"}(exports.Body3DKeyPointType||(exports.Body3DKeyPointType={})),function(e){e.Detected="detected",e.Lost="lost"}(exports.AvatarDriveEvent||(exports.AvatarDriveEvent={})),function(e){e[e.LeftEyeLookDown=0]="LeftEyeLookDown",e[e.LeftNoseSneer=1]="LeftNoseSneer",e[e.LeftEyeLookIn=2]="LeftEyeLookIn",e[e.BrowInnerUp=3]="BrowInnerUp",e[e.LeftEyeSquint=4]="LeftEyeSquint",e[e.MouthClose=5]="MouthClose",e[e.RightMouthLowerDown=6]="RightMouthLowerDown",e[e.JawOpen=7]="JawOpen",e[e.MouthShrugLower=8]="MouthShrugLower",e[e.LeftMouthLowerDown=9]="LeftMouthLowerDown",e[e.MouthFunnel=10]="MouthFunnel",e[e.RightEyeLookIn=11]="RightEyeLookIn",e[e.RightEyeLookDown=12]="RightEyeLookDown",e[e.RightNoseSneer=13]="RightNoseSneer",e[e.MouthRollUpper=14]="MouthRollUpper",e[e.JawRight=15]="JawRight",e[e.LeftMouthDimple=16]="LeftMouthDimple",e[e.MouthRollLower=17]="MouthRollLower",e[e.LeftMouthSmile=18]="LeftMouthSmile",e[e.LeftMouthPress=19]="LeftMouthPress",e[e.RightMouthSmile=20]="RightMouthSmile",e[e.RightMouthPress=21]="RightMouthPress",e[e.RightMouthDimple=22]="RightMouthDimple",e[e.MouthLeft=23]="MouthLeft",e[e.RightBrowDown=24]="RightBrowDown",e[e.LeftBrowDown=25]="LeftBrowDown",e[e.LeftMouthFrown=26]="LeftMouthFrown",e[e.LeftEyeBlink=27]="LeftEyeBlink",e[e.LeftCheekSquint=28]="LeftCheekSquint",e[e.LeftBrowOuterUp=29]="LeftBrowOuterUp",e[e.LeftEyeLookUp=30]="LeftEyeLookUp",e[e.JawLeft=31]="JawLeft",e[e.LeftMouthStretch=32]="LeftMouthStretch",e[e.RightMouthStretch=33]="RightMouthStretch",e[e.MouthPucker=34]="MouthPucker",e[e.RightEyeLookUp=35]="RightEyeLookUp",e[e.RightBrowOuterUp=36]="RightBrowOuterUp",e[e.RightCheekSquint=37]="RightCheekSquint",e[e.RightEyeBlink=38]="RightEyeBlink",e[e.LeftMouthUpperUp=39]="LeftMouthUpperUp",e[e.RightMouthFrown=40]="RightMouthFrown",e[e.RightEyeSquint=41]="RightEyeSquint",e[e.JawForward=42]="JawForward",e[e.RightMouthUpperUp=43]="RightMouthUpperUp",e[e.CheekPuff=44]="CheekPuff",e[e.LeftEyeLookOut=45]="LeftEyeLookOut",e[e.RightEyeLookOut=46]="RightEyeLookOut",e[e.RightEyeWide=47]="RightEyeWide",e[e.MouthRight=48]="MouthRight",e[e.LeftEyeWide=49]="LeftEyeWide",e[e.MouthShrugUpper=50]="MouthShrugUpper",e[e.TongueOut=51]="TongueOut"}(exports.AvatarDriveBlendShapeType||(exports.AvatarDriveBlendShapeType={})),function(e){e.Texture="texture",e.Mesh="mesh"}(exports.AssetType||(exports.AssetType={})),function(e){e.Segmentation="segmentation",e.Face="face",e.CameraInput="cameraInput",e.ImagePicker="imagePicker",e.CaptureFrame="captureFrame"}(exports.AssetSubType||(exports.AssetSubType={})),function(e){e.Possible="possible",e.Began="began",e.Changed="changed",e.Ended="ended",e.Cancelled="cancelled",e.Failed="failed"}(exports.GestureRecognizerState||(exports.GestureRecognizerState={})),function(e){e.Tap="tap",e.Pan="pan",e.Pinch="pinch",e.Rotation="rotation",e.LongPress="longPress",e.DoubleTap="doubleTap"}(exports.GestureType||(exports.GestureType={})),function(e){e[e.AR=0]="AR",e[e.UI=1]="UI",e[e.ThreeD=2]="ThreeD",e[e.TwoD=3]="TwoD",e[e.Other=4]="Other"}(exports.ScreenRaycasterType||(exports.ScreenRaycasterType={})),function(e){e.Began="screenRespondBegan",e.Ended="screenRespondEnded",e.Respond="screenRespond"}(exports.ScreenRespondType||(exports.ScreenRespondType={})),function(e){e[e.Once=0]="Once",e[e.Continuous=1]="Continuous"}(exports.TouchRespondType||(exports.TouchRespondType={})),function(e){e.File="file",e.Mic="mic",e.Music="music"}(exports.AudioControllerType||(exports.AudioControllerType={})),function(e){e[e.Preparing=0]="Preparing",e[e.Playing=1]="Playing",e[e.Stoping=2]="Stoping",e[e.Stopped=3]="Stopped",e[e.Pausing=4]="Pausing",e[e.Paused=5]="Paused",e[e.Exception=-1]="Exception"}(exports.AudioFileControllerState||(exports.AudioFileControllerState={})),function(e){e.Reverb="reverb",e.Megaphone="megaphone",e.Compressor="compressor",e.Delay="delay",e.Filter="filter",e.Vibrato="vibrato",e.Limiter="limiter"}(exports.AudioEffectType||(exports.AudioEffectType={})),function(e){e[e.LowPass=0]="LowPass",e[e.HighPass=1]="HighPass"}(exports.AudioEffectFilterType||(exports.AudioEffectFilterType={})),function(e){e.Energy="energyDetection",e.PitchDetection="pitchDetection",e.BeatsDetection="beatsDetection",e.VolumeDetection="volumeDetection",e.OnsetDetection="onsetDetection"}(exports.AudioExtractorType||(exports.AudioExtractorType={})),function(e){e.Play="play",e.Pause="pause",e.Resume="resume",e.Stop="stop",e.LoopCompletion="loopCompletion"}(exports.AudioEvent||(exports.AudioEvent={})),function(e){e[e.CPU=0]="CPU",e[e.GPU=1]="GPU",e[e.DSP=2]="DSP",e[e.NPU=3]="NPU",e[e.AUTO=4]="AUTO",e[e.METAL=5]="METAL",e[e.OPENCL=6]="OPENCL",e[e.OPENGL=7]="OPENGL",e[e.VULKAN=8]="VULKAN",e[e.CUDA=9]="CUDA",e[e.CoreML=10]="CoreML"}(exports.ByteNNForwardType||(exports.ByteNNForwardType={})),function(e){e[e.U8=0]="U8",e[e.Int8=1]="Int8",e[e.Int16=2]="Int16",e[e.Uint16=3]="Uint16",e[e.Float=4]="Float",e[e.Fp16=5]="Fp16",e[e.Double=6]="Double"}(exports.ByteNNDataType||(exports.ByteNNDataType={})),function(e){e[e.COLOR_BGR2BGRA=0]="COLOR_BGR2BGRA",e[e.COLOR_RGB2RGBA=0]="COLOR_RGB2RGBA",e[e.COLOR_BGRA2BGR=1]="COLOR_BGRA2BGR",e[e.COLOR_RGBA2RGB=1]="COLOR_RGBA2RGB",e[e.COLOR_BGR2RGBA=2]="COLOR_BGR2RGBA",e[e.COLOR_RGB2BGRA=2]="COLOR_RGB2BGRA",e[e.COLOR_RGBA2BGR=3]="COLOR_RGBA2BGR",e[e.COLOR_BGRA2RGB=3]="COLOR_BGRA2RGB",e[e.COLOR_BGR2RGB=4]="COLOR_BGR2RGB",e[e.COLOR_RGB2BGR=4]="COLOR_RGB2BGR",e[e.COLOR_BGRA2RGBA=5]="COLOR_BGRA2RGBA",e[e.COLOR_RGBA2BGRA=5]="COLOR_RGBA2BGRA",e[e.COLOR_BGR2GRAY=6]="COLOR_BGR2GRAY",e[e.COLOR_RGB2GRAY=7]="COLOR_RGB2GRAY",e[e.COLOR_GRAY2BGR=8]="COLOR_GRAY2BGR",e[e.COLOR_GRAY2RGB=8]="COLOR_GRAY2RGB",e[e.COLOR_GRAY2BGRA=9]="COLOR_GRAY2BGRA",e[e.COLOR_GRAY2RGBA=9]="COLOR_GRAY2RGBA",e[e.COLOR_BGRA2GRAY=10]="COLOR_BGRA2GRAY",e[e.COLOR_RGBA2GRAY=11]="COLOR_RGBA2GRAY"}(exports.ColorConversionCodes||(exports.ColorConversionCodes={})),function(e){e[e.CV_16S=3]="CV_16S",e[e.CV_16SC1=3]="CV_16SC1",e[e.CV_16SC2=11]="CV_16SC2",e[e.CV_16SC3=19]="CV_16SC3",e[e.CV_16SC4=27]="CV_16SC4",e[e.CV_16U=2]="CV_16U",e[e.CV_16UC1=2]="CV_16UC1",e[e.CV_16UC2=10]="CV_16UC2",e[e.CV_16UC3=18]="CV_16UC3",e[e.CV_16UC4=26]="CV_16UC4",e[e.CV_32F=5]="CV_32F",e[e.CV_32FC1=5]="CV_32FC1",e[e.CV_32FC2=13]="CV_32FC2",e[e.CV_32FC3=21]="CV_32FC3",e[e.CV_32FC4=29]="CV_32FC4",e[e.CV_32S=4]="CV_32S",e[e.CV_32SC1=4]="CV_32SC1",e[e.CV_32SC2=12]="CV_32SC2",e[e.CV_32SC3=20]="CV_32SC3",e[e.CV_32SC4=28]="CV_32SC4",e[e.CV_64F=6]="CV_64F",e[e.CV_64FC1=6]="CV_64FC1",e[e.CV_64FC2=14]="CV_64FC2",e[e.CV_64FC3=22]="CV_64FC3",e[e.CV_64FC4=30]="CV_64FC4",e[e.CV_8S=1]="CV_8S",e[e.CV_8SC1=1]="CV_8SC1",e[e.CV_8SC2=9]="CV_8SC2",e[e.CV_8SC3=17]="CV_8SC3",e[e.CV_8SC4=25]="CV_8SC4",e[e.CV_8U=0]="CV_8U",e[e.CV_8UC1=0]="CV_8UC1",e[e.CV_8UC2=8]="CV_8UC2",e[e.CV_8UC3=16]="CV_8UC3",e[e.CV_8UC4=24]="CV_8UC4"}(exports.CVMatrixFormat||(exports.CVMatrixFormat={}));var V=effect.Amaz;const G=["clearColor","clearColorBuffer","clearDepthBuffer","clearStencilBuffer","orthoHeight","near","far","fov","type","viewport","layers","renderOrder"];class U extends a{constructor(e,t){if(e){super(e,"Camera");const a=new V.DynamicBitset(D,0);a.set(0,1),this.native.layerVisibleMask=a,this.initialize(t,G),this.native.renderTexture=new V.SceneOutputRT}else super()}static register(){a.registerComponentType("Camera",this.nativeClasses,U),this.register=()=>void 0}static fromNative(e,t){const a=new U;if(t instanceof V.Camera)a.initWithNative(e,t,"Camera");else throw new Error("Incorrect argument to CameraComponent::fromNative");return a}get renderTexture(){return this.native.renderTexture}set renderTexture(e){this.native.renderTexture=e}get clearColor(){return new v(this.native.clearColor)}set clearColor(e){this.native.clearColor=e.native}get clearColorBuffer(){const e=this.native.clearType;return 1===e||3===e||7===e}set clearColorBuffer(e){let t=this.native.clearType;0===t||4===t||5===t?t=e?1:t:1===t?t=e?1:5:2===t||3===t?t=e?3:2:6===t||7===t?t=e?7:6:void 0;this.native.clearType=t}get clearDepthBuffer(){const e=this.native.clearType;return 2===e||3===e||6===e||7===e}set clearDepthBuffer(e){let t=this.native.clearType;0===t||4===t||5===t?t=e?2:t:1===t||3===t?t=e?3:1:2===t?t=e?e:5:6===t?t=e?6:5:7===t?t=e?7:1:void 0;this.native.clearType=t}get clearStencilBuffer(){const e=this.native.clearType;return 6===e||7===e}set clearStencilBuffer(e){let t=this.native.clearType;0===t||4===t||5===t?t=e?6:t:1===t||3===t?t=e?7:t:2===t||6===t?t=e?6:2:7===t?t=e?7:1:void 0;this.native.clearType=t}get orthoHeight(){return this.native.orthoScale}set orthoHeight(e){this.native.orthoScale=e}get near(){return this.native.zNear}set near(e){this.native.zNear=e}get far(){return this.native.zFar}set far(e){this.native.zFar=e}get fov(){return this.native.fovy}set fov(e){this.native.fovy=e}get type(){return this.native.type}set type(e){this.native.type=e}get viewport(){return new C(this.native.viewport)}set viewport(e){this.native.viewport=e.native}get layers(){const e=[];for(let t=0;t<D;++t)this.native.layerVisibleMask.test(t)&&e.push(t);return e}set layers(e){const t=new V.DynamicBitset(D,0);for(const a of e)if(0<=a&&a<D)t.set(a);else throw new Error("Invalid layer value!");this.native.layerVisibleMask=t}get renderOrder(){return this.native.renderOrder}set renderOrder(e){this.native.renderOrder=e}screenToWorld(e){return this.native.screenToWorldPoint(e.native)}worldToScreen(e){return this.native.worldToScreenPoint(e.native)}}U.nativeClasses=["Camera"],U.register();class H{constructor(e){this._supportMemoryMapping=d.doesSDKSupport(u),this._native=e,this._values=this._supportMemoryMapping?new Float32Array(this._native.getBuffer()):new Float32Array}}H.X=0,H.Y=1,H.Z=2,H.W=3;const j=Math.PI/180,W=180/Math.PI,Y=1e-5,X=3.141592653589793,q=.7071067811865476,K=.002777777777777778;function Z(e,t,a=1e-6){return Math.abs(e-t)<=a}function Q(e){return 2*(e*K)*X}var J=effect.Amaz;class $ extends H{constructor(e,t,a){e instanceof J.Vector3f?super(e):super(new J.Vector3f(null==e?0:e,null==t?0:t,null==a?0:a))}static fromNative(e){return new $(e)}static eq(e,t){return e&&t&&e.x===t.x&&e.y===t.y&&e.z===t.z}get native(){return this._native}set(e,t,a){return this.x=e,this.y=t,this.z=a,this}get x(){return this._supportMemoryMapping?this._values[H.X]:this._native.x}set x(e){this._supportMemoryMapping?this._values[H.X]=Math.fround(e):this._native.x=e}get y(){return this._supportMemoryMapping?this._values[H.Y]:this._native.y}set y(e){this._supportMemoryMapping?this._values[H.Y]=Math.fround(e):this._native.y=e}get z(){return this._supportMemoryMapping?this._values[H.Z]:this._native.z}set z(e){this._supportMemoryMapping?this._values[H.Z]=Math.fround(e):this._native.z=e}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}clone(){return new $(this.x,this.y,this.z)}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}mul(e){return e instanceof $?(this.x*=e.x,this.y*=e.y,this.z*=e.z):(this.x*=e,this.y*=e,this.z*=e),this}div(e){return e instanceof $?(this.x/=e.x,this.y/=e.y,this.z/=e.z):(this.x/=e,this.y/=e,this.z/=e),this}eq(e){return e&&this.x===e.x&&this.y===e.y&&this.z===e.z}neg(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}inv(){return this.x=1/this.x,this.y=1/this.y,this.z=1/this.z,this}scale(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}len(){return Math.sqrt(this.dot(this))}lenSq(){return this.dot(this)}normalize(){return this.div(this.len())}isNormalized(){return Z(this.lenSq(),1)}max(e,t){var a=Math.max;return this.set(a(e.x,t.x),a(e.y,t.y),a(e.z,t.z)),this}min(e,t){var a=Math.min;return this.set(a(e.x,t.x),a(e.y,t.y),a(e.z,t.z)),this}abs(){var e=Math.abs;return this.set(e(this.x),e(this.y),e(this.z)),this}static lerp(e,a,n,r){var i=Math.min,o=Math.max;return void 0===r&&(r=new $),n=i(1,o(0,n)),r.x=e.x+n*(a.x-e.x),r.y=e.y+n*(a.y-e.y),r.z=e.z+n*(a.z-e.z),r}static slerp(e,a,n,t){void 0===t&&(t=new $);const r=e._native.slerp(a._native,n);return t.set(r.x,r.y,r.z),t}distance(e){return e.clone().sub(this).len()}isFinite(){var e=Number.isFinite;return e(this.x)&&e(this.y)&&e(this.z)}cross(e,t){return this.set(e.y*t.z-e.z*t.y,e.z*t.x-e.x*t.z,e.x*t.y-e.y*t.x),this}static cross(e,t,a){return void 0===a&&(a=new $),a.cross(e,t)}static reflect(e,t,a){return void 0===a&&(a=new $),a.copy(t),a.mul(-2*t.dot(e)).add(e)}toString(){return`Vector3f(${this.x.toFixed(5)}, ${this.y.toFixed(5)}, ${this.z.toFixed(5)})`}aboutEq(e,t){return Z(this.x,e.x,t)&&Z(this.y,e.y,t)&&Z(this.z,e.z,t)}static orthoNormalize(e,t,a){e.native.orthoNormalize(t.native,a.native)}rotateTowards(e,t,a,n){const r=e.native.rotateTowards(t.native,a*j,n);return this.set(r.x,r.y,r.z)}static rotateTowards(e,t,a,n,r){return void 0===r&&(r=new $),r.rotateTowards(e,t,a,n)}moveTowards(e,t,a){const n=e.native.moveTowards(t.native,a);return this.set(n.x,n.y,n.z)}static moveTowards(e,t,a,n){return void 0===n&&(n=new $),n.moveTowards(e,t,a)}}var ee=effect.Amaz;const te=["type","offset","halfExtents","radius","height"],ae=new Map([[exports.Collider3DType.Box,"BoxCollider3D"],[exports.Collider3DType.Sphere,"SphereCollider3D"],[exports.Collider3DType.Capsule,"CapsuleCollider3D"]]);function ne(e){if(!ae.has(e))throw new Error("Unknown type of shape");return ae.get(e)}class re extends a{constructor(e,t){if(e){const a=t&&t.hasOwnProperty("type")?t:{type:exports.Collider3DType.Box};super(e,ne(a.type)),this.initialize(a,te)}else super()}static register(){a.registerComponentType("Collider",this.nativeClasses,re),this.register=()=>void 0}static fromNative(e,t){const a=new re;if(t instanceof ee.BoxCollider3D)a.initWithNative(e,t,"BoxCollider3D"),a.type=exports.Collider3DType.Box;else if(t instanceof ee.SphereCollider3D)a.initWithNative(e,t,"SphereCollider3D"),a.type=exports.Collider3DType.Sphere;else if(t instanceof ee.CapsuleCollider3D)a.initWithNative(e,t,"CapsuleCollider3D"),a.type=exports.Collider3DType.Capsule;else throw new Error("Incorrect argument to CollisionComponent::fromNative");return a}get offset(){return new $(this.native.offset)}set offset(e){this.native.offset=e.native}get radius(){return this.native.radius}set radius(e){this.native.radius=e}get height(){return this.native.height}set height(e){this.native.height=e}get halfExtents(){return new $(this.native.halfExtent)}set halfExtents(e){this.native.halfExtent=e.native}}re.nativeClasses=["BoxCollider3D","SphereCollider3D","CapsuleCollider3D"],re.register();var ie=effect.Amaz;class oe extends H{constructor(e,t){e instanceof ie.Vector2f?super(e):super(new ie.Vector2f(null==e?0:e,null==t?0:t))}static fromNative(e){return new oe(e)}static eq(e,t){return e&&t&&e.x===t.x&&e.y===t.y}get native(){return this._native}set(e,t){return this.x=e,this.y=t,this}get x(){return this._supportMemoryMapping?this._values[H.X]:this._native.x}set x(e){this._supportMemoryMapping?this._values[H.X]=Math.fround(e):this._native.x=e}get y(){return this._supportMemoryMapping?this._values[H.Y]:this._native.y}set y(e){this._supportMemoryMapping?this._values[H.Y]=Math.fround(e):this._native.y=e}copy(e){return this.x=e.x,this.y=e.y,this}clone(){return new oe(this.x,this.y)}add(e){return this.x+=e.x,this.y+=e.y,this}sub(e){return this.x-=e.x,this.y-=e.y,this}mul(e){return e instanceof oe?(this.x*=e.x,this.y*=e.y):(this.x*=e,this.y*=e),this}div(e){return e instanceof oe?(this.x/=e.x,this.y/=e.y):(this.x/=e,this.y/=e),this}eq(e){return e&&this.x===e.x&&this.y===e.y}neg(){return this.x=-this.x,this.y=-this.y,this}inv(){return this.x=1/this.x,this.y=1/this.y,this}dot(e){return this.x*e.x+this.y*e.y}len(){return Math.sqrt(this.dot(this))}lenSq(){return this.dot(this)}angle(e){const t=Math.acos(Math.min(1,Math.max(-1,this.dot(e)/(this.len()*e.len()))));return t*W}normalize(){return this.div(this.len())}isNormalized(){return Z(this.lenSq(),1)}max(e,t){var a=Math.max;return this.set(a(e.x,t.x),a(e.y,t.y))}min(e,t){var a=Math.min;return this.set(a(e.x,t.x),a(e.y,t.y))}abs(){var e=Math.abs;return this.set(e(this.x),e(this.y))}static lerp(e,a,n,r){var i=Math.min,o=Math.max;return void 0===r&&(r=new oe),n=i(1,o(0,n)),r.x=e.x+n*(a.x-e.x),r.y=e.y+n*(a.y-e.y),r}distance(e){const t=e.clone().sub(this);return t.len()}isFinite(){var e=Number.isFinite;return e(this.x)&&e(this.y)}toString(){return`Vector2f(${this.x.toFixed(5)}, ${this.y.toFixed(5)})`}aboutEq(e,t){return Z(this.x,e.x,t)&&Z(this.y,e.y,t)}}var se=effect.Amaz;const de=new Map([[exports.LightType.Directional,"DirectionalLight"],[exports.LightType.Point,"PointLight"],[exports.LightType.Spot,"SpotLight"]]);function le(e){if(!de.has(e))throw new Error("Unknown type of light");return de.get(e)}const ce=["type","color","intensity","castShadow","enableSoftShadow","shadowSoftness","shadowBias","camera","shadowResolution","attenuationRange"];class pe extends a{constructor(e,t){if(e){const a=t&&t.hasOwnProperty("type")?t:{type:exports.LightType.Directional};super(e,le(a.type)),this.initialize(a,ce)}else super()}static register(){a.registerComponentType("Light",this.nativeClasses,pe),this.register=()=>void 0}static fromNative(e,t){const a=new pe;if(t instanceof se.DirectionalLight)a.initWithNative(e,t,"DirectionalLight"),a.type=exports.LightType.Directional;else if(t instanceof se.PointLight)a.initWithNative(e,t,"PointLight"),a.type=exports.LightType.Point;else if(t instanceof se.SpotLight)a.initWithNative(e,t,"SpotLight"),a.type=exports.LightType.Spot;else throw new Error("Incorrect argument to LightComponent::fromNative");return a}get color(){const e=this.native.color;return new v(e.x,e.y,e.z,1)}set color(e){this.native.color=new $(e.r,e.g,e.b).native}get intensity(){return this.native.intensiy}set intensity(e){this.native.intensiy=e}get castShadow(){return this.native.shadowEnableNew}set castShadow(e){this.native.shadowEnableNew=e}get enableSoftShadow(){return this.native.useSoftShadow}set enableSoftShadow(e){this.native.useSoftShadow=e}get shadowSoftness(){return this.native.shadowSoftness}set shadowSoftness(e){this.native.shadowSoftness=e}get shadowBias(){return this.native.shadowBias}set shadowBias(e){this.native.shadowBias=e}get shadowResolution(){return new oe(this.native.shadowResolution)}set shadowResolution(e){this.native.shadowResolution=e.native}get attenuationRange(){if(this.type===exports.LightType.Point||this.type===exports.LightType.Spot)return this.native.attenuationRange;throw new Error("Light Type does not support attenuationRange!")}set attenuationRange(e){if(this.type===exports.LightType.Point||this.type===exports.LightType.Spot)this.native.attenuationRange=e;else throw new Error("Light Type does not support attenuationRange!")}get camera(){if(this.type===exports.LightType.Directional){var e,t,a,n;return null==(e=this.sceneObject)||null==(t=e.scene)?void 0:t.sceneObjectFromNative(null==(a=this.native)||null==(n=a.mainCamera)?void 0:n.entity)}}set camera(e){if(!(this.type===exports.LightType.Directional))throw new Error("Only directional light needs cameera for shadow optimization!");else if(e)if(e.native)this.native.mainCamera=e.native.getComponent("Transform");else throw new Error("Invalid camera!")}}pe.nativeClasses=["DirectionalLight","PointLight","SpotLight"],pe.register();var ue=effect.Amaz;class me extends H{constructor(e,t,a,n){e instanceof ue.Vector4f?super(e):super(new ue.Vector4f(null==e?0:e,null==t?0:t,null==a?0:a,null==n?0:n))}static fromNative(e){return new me(e)}static eq(e,t){return e&&t&&e.x===t.x&&e.y===t.y&&e.z===t.z&&e.w===t.w}get native(){return this._native}set(e,t,a,n){return this.x=e,this.y=t,this.z=a,this.w=n,this}get x(){return this._supportMemoryMapping?this._values[H.X]:this._native.x}set x(e){this._supportMemoryMapping?this._values[H.X]=Math.fround(e):this._native.x=e}get y(){return this._supportMemoryMapping?this._values[H.Y]:this._native.y}set y(e){this._supportMemoryMapping?this._values[H.Y]=Math.fround(e):this._native.y=e}get z(){return this._supportMemoryMapping?this._values[H.Z]:this._native.z}set z(e){this._supportMemoryMapping?this._values[H.Z]=Math.fround(e):this._native.z=e}get w(){return this._supportMemoryMapping?this._values[H.W]:this._native.w}set w(e){this._supportMemoryMapping?this._values[H.W]=Math.fround(e):this._native.w=e}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}clone(){return new me(this.x,this.y,this.z,this.w)}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}mul(e){return e instanceof me?(this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w):(this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}div(e){return e instanceof me?(this.x/=e.x,this.y/=e.y,this.z/=e.z,this.w/=e.w):(this.x/=e,this.y/=e,this.z/=e,this.w/=e),this}eq(e){return e&&this.x===e.x&&this.y===e.y&&this.z===e.z&&this.w===e.w}neg(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}static lerp(e,a,n,r){var i=Math.min,o=Math.max;return void 0===r&&(r=new me),n=i(1,o(0,n)),r.x=e.x+n*(a.x-e.x),r.y=e.y+n*(a.y-e.y),r.z=e.z+n*(a.z-e.z),r.w=e.w+n*(a.w-e.w),r}toString(){return`Vector4f(${this.x.toFixed(5)}, ${this.y.toFixed(5)}, ${this.z.toFixed(5)}, ${this.w.toFixed(5)})`}isFinite(){var e=Number.isFinite;return e(this.x)&&e(this.y)&&e(this.z)&&e(this.w)}}class ge{constructor(e){this._supportMemoryMapping=d.doesSDKSupport(u),this._native=e,this._values=this._supportMemoryMapping?new Float32Array(this._native.getBuffer()):new Float32Array}}var fe=effect.Amaz;const _e=3;class he extends ge{constructor(e,t,a,n,r,i,o,s,d){e instanceof fe.Matrix3x3f?super(e):super(new fe.Matrix3x3f(null==e?1:e,null==t?0:t,null==a?0:a,null==n?0:n,null==r?1:r,null==i?0:i,null==o?0:o,null==s?0:s,null==d?1:d))}static fromNative(e){return new he(e)}get native(){return this._native}set(e,t,a){var n=Math.fround;return this._supportMemoryMapping?e<_e&&t<_e&&(this._values[e+t*_e]=n(a)):e<_e&&t<_e&&this._native.set(e,t,a),this}get(e,t){return this._supportMemoryMapping?this._values[e+t*_e]:this._native.get(e,t)}getColumn(e,t){return void 0===t&&(t=new $),t.set(this.get(0,e),this.get(1,e),this.get(2,e))}copy(e){for(let t=0;t<_e;++t)for(let a=0;a<_e;++a)this.set(t,a,e.get(t,a));return this}clone(){const e=new he;for(let t=0;t<_e;++t)for(let a=0;a<_e;++a)e.set(t,a,this.get(t,a));return e}eq(e){for(let t=0;t<_e;++t)for(let a=0;a<_e;++a)if(this.get(t,a)!==e.get(t,a))return!1;return!0}static eq(e,t){for(let a=0;a<_e;++a)for(let n=0;n<_e;++n)if(e.get(a,n)!==t.get(a,n))return!1;return!0}identity(){return this.set(0,0,1),this.set(1,0,0),this.set(2,0,0),this.set(0,1,0),this.set(1,1,1),this.set(2,1,0),this.set(0,2,0),this.set(1,2,0),this.set(2,2,1),this}zero(){return this.set(0,0,0),this.set(1,0,0),this.set(2,0,0),this.set(0,1,0),this.set(1,1,0),this.set(2,1,0),this.set(0,2,0),this.set(1,2,0),this.set(2,2,0),this}isIdentity(e){return Z(this.get(0,0),1,e)&&Z(this.get(1,0),0,e)&&Z(this.get(2,0),0,e)&&Z(this.get(0,1),0,e)&&Z(this.get(1,1),1,e)&&Z(this.get(2,1),0,e)&&Z(this.get(0,2),0,e)&&Z(this.get(1,2),0,e)&&Z(this.get(2,2),1,e)}isZero(e){return Z(this.get(0,0),0,e)&&Z(this.get(1,0),0,e)&&Z(this.get(2,0),0,e)&&Z(this.get(0,1),0,e)&&Z(this.get(1,1),0,e)&&Z(this.get(2,1),0,e)&&Z(this.get(0,2),0,e)&&Z(this.get(1,2),0,e)&&Z(this.get(2,2),0,e)}inv(){let e=this.determinant();if(Z(e,0))return this.zero();e=1/e;const t=e*(this.get(1,1)*this.get(2,2)-this.get(1,2)*this.get(2,1)),a=e*-(this.get(1,0)*this.get(2,2)-this.get(1,2)*this.get(2,0)),n=e*(this.get(1,0)*this.get(2,1)-this.get(1,1)*this.get(2,0)),r=e*-(this.get(0,1)*this.get(2,2)-this.get(0,2)*this.get(2,1)),i=e*(this.get(0,0)*this.get(2,2)-this.get(0,2)*this.get(2,0)),o=e*-(this.get(0,0)*this.get(2,1)-this.get(0,1)*this.get(2,0)),s=e*(this.get(0,1)*this.get(1,2)-this.get(0,2)*this.get(1,1)),d=e*-(this.get(0,0)*this.get(1,2)-this.get(0,2)*this.get(1,0)),l=e*(this.get(0,0)*this.get(1,1)-this.get(0,1)*this.get(1,0));return this.set(0,0,t),this.set(1,0,a),this.set(2,0,n),this.set(0,1,r),this.set(1,1,i),this.set(2,1,o),this.set(0,2,s),this.set(1,2,d),this.set(2,2,l),this}mul(e){for(let t=0;t<_e;++t){const a=[this.get(t,0),this.get(t,1),this.get(t,2)];this.set(t,0,a[0]*e.get(0,0)+a[1]*e.get(1,0)+a[2]*e.get(2,0)),this.set(t,1,a[0]*e.get(0,1)+a[1]*e.get(1,1)+a[2]*e.get(2,1)),this.set(t,2,a[0]*e.get(0,2)+a[1]*e.get(1,2)+a[2]*e.get(2,2))}return this}transformVec3(e){return e.set(this.get(0,0)*e.x+this.get(0,1)*e.y+this.get(0,2)*e.z,this.get(1,0)*e.x+this.get(1,1)*e.y+this.get(1,2)*e.z,this.get(2,0)*e.x+this.get(2,1)*e.y+this.get(2,2)*e.z)}static transformVec3(e,t){return e.transformVec3(t)}scale(e){return this.set(0,0,this.get(0,0)*e.x),this.set(1,0,this.get(1,0)*e.x),this.set(2,0,this.get(2,0)*e.x),this.set(0,1,this.get(0,1)*e.y),this.set(1,1,this.get(1,1)*e.y),this.set(2,1,this.get(2,1)*e.y),this.set(0,2,this.get(0,2)*e.z),this.set(1,2,this.get(1,2)*e.z),this.set(2,2,this.get(2,2)*e.z),this}fromScale(e){return this.set(0,0,e.x),this.set(1,0,0),this.set(2,0,0),this.set(0,1,0),this.set(1,1,e.y),this.set(2,1,0),this.set(0,2,0),this.set(1,2,0),this.set(2,2,e.z),this}determinant(){const e=this.get(0,0)*this.get(1,1)*this.get(2,2),t=this.get(0,1)*this.get(1,2)*this.get(2,0),a=this.get(0,2)*this.get(1,0)*this.get(2,1),n=this.get(0,2)*this.get(1,1)*this.get(2,0),r=this.get(0,1)*this.get(1,0)*this.get(2,2),i=this.get(0,0)*this.get(1,2)*this.get(2,1);return e+t+a-n-r-i}transpose(){let e=this.get(0,1);return this.set(0,1,this.get(1,0)),this.set(1,0,e),e=this.get(0,2),this.set(0,2,this.get(2,0)),this.set(2,0,e),e=this.get(1,2),this.set(1,2,this.get(2,1)),this.set(2,1,e),this}static fromEulerAngles(e,t,a,n){var r=Math.sin,i=Math.cos;void 0===n&&(n=new he);const o=i(e*j),s=r(e*j),d=i(t*j),l=r(t*j),c=i(a*j),p=r(a*j);return n.set(0,0,d*c+s*l*p),n.set(0,1,c*s*l-d*p),n.set(0,2,o*l),n.set(1,0,o*p),n.set(1,1,o*c),n.set(1,2,-s),n.set(2,0,-c*l+d*s*p),n.set(2,1,d*c*s+l*p),n.set(2,2,o*d),n}fromAxisAngle(e,t){var a=Math.sin,n=Math.cos;const r=a(t*j),i=n(t*j),o=e.x,s=e.y,d=e.z,l=o*s,c=s*d,p=d*o,u=o*r,m=s*r,g=d*r,f=1-i;return this.set(0,0,f*(o*o)+i),this.set(0,1,f*l-g),this.set(0,2,f*p+m),this.set(1,0,f*l+g),this.set(1,1,f*(s*s)+i),this.set(1,2,f*c-u),this.set(2,0,f*p-m),this.set(2,1,f*c+u),this.set(2,2,f*(d*d)+i),this}static fromAxisAngle(e,t,a){return void 0===a&&(a=new he),a.fromAxisAngle(e,t)}fromToRotation(t,a){const n=new $;n.cross(t,a);const r=t.dot(a);if(r>1-Y)return this.identity();if(r<-1+Y){const e=new $(0,t.z,-t.y);e.len()<Y&&e.set(-t.z,0,t.x),e.normalize();const a=new $;a.cross(e,t);const n=-t.x*t.x,r=-t.y*t.y,i=-t.z*t.z,o=-t.x*t.y,s=-t.x*t.z,d=-t.y*t.z,l=a.x*a.x,c=a.y*a.y,p=a.z*a.z,u=a.x*a.y,m=a.x*a.z,g=a.y*a.z,f=-e.x*e.x,_=-e.y*e.y,h=-e.z*e.z,y=-e.x*e.y,v=-e.x*e.z,T=-e.y*e.z;this.set(0,0,n+l+f),this.set(0,1,o+u+y),this.set(0,2,s+m+v),this.set(1,0,this.get(0,1)),this.set(1,1,r+c+_),this.set(1,2,d+g+T),this.set(2,0,this.get(0,2)),this.set(2,1,this.get(1,2)),this.set(2,2,i+p+h)}else{const e=(1-r)/n.dot(n),t=e*n.x,a=e*n.z,i=t*n.y,o=t*n.z,s=a*n.y;this.set(0,0,r+t*n.x),this.set(0,1,i-n.z),this.set(0,2,o+n.y),this.set(1,0,i+n.z),this.set(1,1,r+e*n.y*n.y),this.set(1,2,s-n.x),this.set(2,0,o-n.y),this.set(2,1,s+n.x),this.set(2,2,r+a*n.z)}return this}static fromToRotation(e,t,a){return void 0===a&&(a=new he),a.fromToRotation(e,t)}fromLookAt(e,t){const a=new $;a.copy(e);let n=a.len();if(n<Y)return this.identity();a.div(n);const r=new $;if(r.cross(t,a),n=r.len(),n<Y)return this.identity();r.div(n);const i=new $;return i.cross(a,r),Z(1,i.len())?this.fromBasisXYZ(r,i,a):this.identity()}static fromLookAt(e,t,a){return void 0===a&&(a=new he),a.fromLookAt(e,t)}fromBasisXYZ(e,t,a){return this.set(0,0,e.x),this.set(0,1,t.x),this.set(0,2,a.x),this.set(1,0,e.y),this.set(1,1,t.y),this.set(1,2,a.y),this.set(2,0,e.z),this.set(2,1,t.z),this.set(2,2,a.z),this}static fromBasisXYZ(e,t,a,n){return void 0===n&&(n=new he),n.fromBasisXYZ(e,t,a)}orthoNormalVectorFast(e){var t=Math.sqrt,a=Math.abs;const r=new $;if(r.copy(e),a(r.z)>q){const n=r.y*r.y+r.z*r.z,a=1/t(n);e.x=0,e.y=-r.z*a,e.z=r.y*a}else{const n=r.x*r.x+r.y*r.y,a=1/t(n);e.x=-r.y*a,e.y=r.x*a,e.z=0}return e}orthoNormalize(){let e=this.getColumn(0),t=this.getColumn(1);const a=this.getColumn(2);let n=e.len();n>Y?e.div(n):e=new $(1,0,0);let r=e.dot(t);const i=new $;i.copy(e),t.sub(i.mul(r)),n=t.len(),n>Y?t.div(n):(i.copy(e),t=this.orthoNormalVectorFast(t));const o=t.dot(a);r=e.dot(a);const s=new $;return s.copy(t),i.copy(e),a.sub(i.mul(r).add(s.mul(o))),n=a.len(),n>Y?a.div(n):a.cross(e,t),this.fromBasisXYZ(e,t,a)}sanitizeEuler(e){const t=-1e-4,a=2*X-1e-4;e.x<t?e.x+=2*X:e.x>a&&(e.x-=2*X),e.y<t?e.y+=2*X:e.y>a&&(e.y-=2*X),e.z<t?e.z+=2*X:e.z>a&&(e.z-=2*X)}toEulerAngles(e){var t=Math.atan2,a=Math.asin;return void 0===e&&(e=new $),.999>this.get(1,2)?-.999<this.get(1,2)?(e.x=a(-this.get(1,2)),e.y=t(this.get(0,2),this.get(2,2)),e.z=t(this.get(1,0),this.get(1,1)),this.sanitizeEuler(e),e.x*=W,e.y*=W,e.z*=W,e):(e.x=.5*X,e.y=t(this.get(0,1),this.get(0,0)),e.z=0,this.sanitizeEuler(e),e.set(0,0,0),e):(e.x=.5*-X,e.y=t(-this.get(0,1),this.get(0,0)),e.z=0,this.sanitizeEuler(e),e.set(0,0,0),e)}toAxisAngle(e){const t=this.toEulerAngles(),a=ve.fromEulerAngles(t.x,t.y,t.z);return a.toAxisAngle(e)}}var ye=effect.Amaz;class ve extends H{constructor(e,t,a,n){e instanceof ye.Quaternionf?super(e):super(new ye.Quaternionf(null==e?0:e,null==t?0:t,null==a?0:a,null==n?1:n))}static fromNative(e){return new ve(e)}static identity(){return new ve(0,0,0,1)}static fromToRotation(e,t,a){a===void 0&&(a=new ve);const n=e.len(),r=t.len();if(n<Y||r<Y)return a.set(0,0,0,1),a;else{const i=he.fromToRotation(e.div(n),t.div(r));return a.fromMatrix3(i)}}static fromLookAt(e,t,a){a===void 0&&(a=new ve);const n=he.fromLookAt(e,t);return n.isIdentity()?(a.set(0,0,0,1),a):a.fromMatrix3(n)}static rotateVec3(e,t){return e.rotateVec3(t)}static slerp(e,a,n,t){void 0===t&&(t=new ve);const r=e._native.slerp(a._native,n);return t.set(r.x,r.y,r.z,r.w),t}static fromAxisAngle(e,t,a){return void 0===a&&(a=new ve),a.fromAxisAngle(e,t)}static eq(e,t){return e&&t&&e.x===t.x&&e.y===t.y&&e.z===t.z&&e.w===t.w}get native(){return this._native}set(e,t,a,n){return this.x=e,this.y=t,this.z=a,this.w=n,this}get x(){return this._supportMemoryMapping?this._values[H.X]:this._native.x}set x(e){this._supportMemoryMapping?this._values[H.X]=Math.fround(e):this._native.x=e}get y(){return this._supportMemoryMapping?this._values[H.Y]:this._native.y}set y(e){this._supportMemoryMapping?this._values[H.Y]=Math.fround(e):this._native.y=e}get z(){return this._supportMemoryMapping?this._values[H.Z]:this._native.z}set z(e){this._supportMemoryMapping?this._values[H.Z]=Math.fround(e):this._native.z=e}get w(){return this._supportMemoryMapping?this._values[H.W]:this._native.w}set w(e){this._supportMemoryMapping?this._values[H.W]=Math.fround(e):this._native.w=e}eq(e){return e&&this.x===e.x&&this.y===e.y&&this.z===e.z&&this.w===e.w}toString(){return`Quaternionf(${this.x.toFixed(5)}, ${this.y.toFixed(5)}, ${this.z.toFixed(5)}, ${this.w.toFixed(5)})`}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}mul(e){return this.set(this.w*e.x+this.x*e.w+this.y*e.z-this.z*e.y,this.w*e.y+this.y*e.w+this.z*e.x-this.x*e.z,this.w*e.z+this.z*e.w+this.x*e.y-this.y*e.x,this.w*e.w-this.x*e.x-this.y*e.y-this.z*e.z)}div(e){return this.x/=e,this.y/=e,this.z/=e,this.w/=e,this}neg(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}identity(){return this.set(0,0,0,1),this}static fromEulerAngles(e,t,a,n){n===void 0&&(n=new ve);const r=n.native.eulerToQuaternion(new ye.Vector3f(e*j,t*j,a*j));return n.set(r.x,r.y,r.z,r.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}clone(){return new ve(this.x,this.y,this.z,this.w)}toEulerAngles(e){const t=this.native.quaternionToEuler();return e.set(t.x*W,t.y*W,t.z*W)}toAxisAngle(e){let t=this.x,a=this.y,n=this.z,r=this.w;0>r&&(t=-t,a=-a,n=-n,r=-r),1<r&&(r=1);const i=2*Math.acos(r);if(Z(i,0))e.set(1,0,0);else{const i=1/Math.sqrt(1-r*r);e.set(t*i,a*i,n*i)}return i}rotateVec3(e){const t=2*this.x,a=2*this.y,n=2*this.z,r=this.x*t,i=this.y*a,o=this.z*n,s=this.x*a,d=this.x*n,l=this.y*n,c=this.w*t,p=this.w*a,u=this.w*n,m=e.clone();return e.x=(1-(i+o))*m.x+(s-u)*m.y+(d+p)*m.z,e.y=(s+u)*m.x+(1-(r+o))*m.y+(l-c)*m.z,e.z=(d-p)*m.x+(l+c)*m.y+(1-(r+i))*m.z,e}fromAxisAngle(e,t){const a=.5*t*j,n=Math.sin(a);return this.set(n*e.x,n*e.y,n*e.z,Math.cos(a))}normalize(){return this.div(this.len())}setZero(){return this.x=0,this.y=0,this.z=0,this.w=0,this}len(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}lenSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}inv(){return Z(this.lenSq(),1)?(this.x=-this.x,this.y=-this.y,this.z=-this.z,this):this.setZero()}static fromMatrix4(e,t){t===void 0&&(t=new ve);const a=new he(e.get(0,0),e.get(1,0),e.get(2,0),e.get(0,1),e.get(1,1),e.get(2,1),e.get(0,2),e.get(1,2),e.get(2,2));return t.fromMatrix3(a)}indexSet(e,t){0===e?this.x=t:1===e?this.y=t:2===e?this.z=t:3==e&&(this.w=t)}static fromMatrix3(e,t){return void 0===t&&(t=new ve),t.fromMatrix3(e)}fromMatrix3(e){var t=Math.sqrt;const a=e.get(0,0)+e.get(1,1)+e.get(2,2);let n=0;if(0<a)n=t(a+1),this.w=.5*n,n=.5/n,this.x=(e.get(2,1)-e.get(1,2))*n,this.y=(e.get(0,2)-e.get(2,0))*n,this.z=(e.get(1,0)-e.get(0,1))*n;else{const a=[1,2,0];let r=0;e.get(1,1)>e.get(0,0)&&(r=1),e.get(2,2)>e.get(r,r)&&(r=2);const i=a[r],o=a[i];if(n=t(e.get(r,r)-e.get(i,i)-e.get(o,o)+1),n<Y)return this.setZero();this.indexSet(r,.5*n),n=.5/n,this.w=(e.get(o,i)-e.get(i,o))*n,this.indexSet(i,(e.get(i,r)+e.get(r,i))*n),this.indexSet(o,(e.get(o,r)+e.get(r,o))*n)}return this.normalize()}}var Te=effect.Amaz;const Ce=4;class xe extends ge{constructor(e,t,a,n,r,i,o,s,d,l,c,p,u,m,g,f){e instanceof Te.Matrix4x4f?super(e):e instanceof he?super(new Te.Matrix4x4f(e.native)):super(new Te.Matrix4x4f(null==e?1:e,null==t?0:t,null==a?0:a,null==n?0:n,null==r?0:r,null==i?1:i,null==o?0:o,null==s?0:s,null==d?0:d,null==l?0:l,null==c?1:c,null==p?0:p,null==u?0:u,null==m?0:m,null==g?0:g,null==f?1:f))}static fromNative(e){return new xe(e)}get native(){return this._native}set(e,t,a){var n=Math.fround;return this._supportMemoryMapping?e<Ce&&t<Ce&&(this._values[e+t*Ce]=n(a)):e<Ce&&t<Ce&&this._native.set(e,t,a),this}get(e,t){return this._supportMemoryMapping?this._values[e+t*Ce]:this._native.get(e,t)}getRow(e,t){return void 0===t&&(t=new me),t.set(this.get(e,0),this.get(e,1),this.get(e,2),this.get(e,3))}setRow(e,t){return this.set(e,0,t.x),this.set(e,1,t.y),this.set(e,2,t.z),this.set(e,3,t.w),this}getColumn(e,t){return void 0===t&&(t=new me),t.set(this.get(0,e),this.get(1,e),this.get(2,e),this.get(3,e))}setColumn(e,t){return this.set(0,e,t.x),this.set(1,e,t.y),this.set(2,e,t.z),this.set(3,e,t.w),this}getAxisX(e){return void 0===e&&(e=new $),e.set(this.get(0,0),this.get(1,0),this.get(2,0))}setAxisX(e){return this.set(0,0,e.x),this.set(1,0,e.y),this.set(2,0,e.z),this}getAxisY(e){return void 0===e&&(e=new $),e.set(this.get(0,1),this.get(1,1),this.get(2,1))}setAxisY(e){return this.set(0,1,e.x),this.set(1,1,e.y),this.set(2,1,e.z),this}getAxisZ(e){return void 0===e&&(e=new $),e.set(this.get(0,2),this.get(1,2),this.get(2,2))}setAxisZ(e){return this.set(0,2,e.x),this.set(1,2,e.y),this.set(2,2,e.z),this}getTranslation(e){return void 0===e&&(e=new $),e.set(this.get(0,3),this.get(1,3),this.get(2,3))}setTranslation(e){return this.set(0,3,e.x),this.set(1,3,e.y),this.set(2,3,e.z),this}copy(e){for(let t=0;t<Ce;++t)for(let a=0;a<Ce;++a)this.set(t,a,e.get(t,a));return this}clone(){const e=new xe;for(let t=0;t<Ce;++t)for(let a=0;a<Ce;++a)e.set(t,a,this.get(t,a));return e}eq(e){for(let t=0;t<Ce;++t)for(let a=0;a<Ce;++a)if(this.get(t,a)!==e.get(t,a))return!1;return!0}static eq(e,t){for(let a=0;a<Ce;++a)for(let n=0;n<Ce;++n)if(e.get(a,n)!==t.get(a,n))return!1;return!0}identity(){return this.set(0,0,1),this.set(1,0,0),this.set(2,0,0),this.set(3,0,0),this.set(0,1,0),this.set(1,1,1),this.set(2,1,0),this.set(3,1,0),this.set(0,2,0),this.set(1,2,0),this.set(2,2,1),this.set(3,2,0),this.set(0,3,0),this.set(1,3,0),this.set(2,3,0),this.set(3,3,1),this}zero(){return this.set(0,0,0),this.set(1,0,0),this.set(2,0,0),this.set(3,0,0),this.set(0,1,0),this.set(1,1,0),this.set(2,1,0),this.set(3,1,0),this.set(0,2,0),this.set(1,2,0),this.set(2,2,0),this.set(3,2,0),this.set(0,3,0),this.set(1,3,0),this.set(2,3,0),this.set(3,3,0),this}isIdentity(e){return Z(this.get(0,0),1,e)&&Z(this.get(1,0),0,e)&&Z(this.get(2,0),0,e)&&Z(this.get(3,0),0,e)&&Z(this.get(0,1),0,e)&&Z(this.get(1,1),1,e)&&Z(this.get(2,1),0,e)&&Z(this.get(3,1),0,e)&&Z(this.get(0,2),0,e)&&Z(this.get(1,2),0,e)&&Z(this.get(2,2),1,e)&&Z(this.get(3,2),0,e)&&Z(this.get(0,3),0,e)&&Z(this.get(1,3),0,e)&&Z(this.get(2,3),0,e)&&Z(this.get(3,3),1,e)}isZero(e){return Z(this.get(0,0),0,e)&&Z(this.get(1,0),0,e)&&Z(this.get(2,0),0,e)&&Z(this.get(3,0),0,e)&&Z(this.get(0,1),0,e)&&Z(this.get(1,1),0,e)&&Z(this.get(2,1),0,e)&&Z(this.get(3,1),0,e)&&Z(this.get(0,2),0,e)&&Z(this.get(1,2),0,e)&&Z(this.get(2,2),0,e)&&Z(this.get(3,2),0,e)&&Z(this.get(0,3),0,e)&&Z(this.get(1,3),0,e)&&Z(this.get(2,3),0,e)&&Z(this.get(3,3),0,e)}toArrayCopy(){const e=Array(16);for(let t=0;t<Ce;++t)for(let a=0;a<Ce;++a)e[a+t*Ce]=this.get(a,t);return e}invTRS(){const e=this.toArrayCopy(),t=e[10]*e[5]-e[6]*e[9],a=-e[10]*e[1]+e[2]*e[9],n=e[6]*e[1]-e[2]*e[5],r=-e[10]*e[4]+e[6]*e[8],i=e[10]*e[0]-e[2]*e[8],o=-e[6]*e[0]+e[2]*e[4],s=e[9]*e[4]-e[5]*e[8],d=-e[9]*e[0]+e[1]*e[8],l=e[5]*e[0]-e[1]*e[4],c=e[0]*t+e[1]*r+e[2]*s;if(0===c)return this.zero();const p=1/c;return this.set(0,0,p*t),this.set(1,0,p*a),this.set(2,0,p*n),this.set(3,0,0),this.set(0,1,p*r),this.set(1,1,p*i),this.set(2,1,p*o),this.set(3,1,0),this.set(0,2,p*s),this.set(1,2,p*d),this.set(2,2,p*l),this.set(3,2,0),this.set(0,3,-(this.get(0,0)*e[12]+this.get(0,1)*e[13]+this.get(0,2)*e[14])),this.set(1,3,-(this.get(1,0)*this.get(0,3)+this.get(1,1)*e[13]+this.get(1,2)*e[14])),this.set(2,3,-(this.get(3,0)*this.get(0,3)+this.get(3,1)*this.get(1,3)+this.get(3,2)*e[14])),this.set(3,3,1),this}inv(){return this._native.invert_Full(),this}mul(e){const t=this.toArrayCopy();for(let a=0;a<Ce;a++)this.set(a,0,t[a]*e.get(0,0)+t[a+4]*e.get(1,0)+t[a+8]*e.get(2,0)+t[a+12]*e.get(3,0)),this.set(a,1,t[a]*e.get(0,1)+t[a+4]*e.get(1,1)+t[a+8]*e.get(2,1)+t[a+12]*e.get(3,1)),this.set(a,2,t[a]*e.get(0,2)+t[a+4]*e.get(1,2)+t[a+8]*e.get(2,2)+t[a+12]*e.get(3,2)),this.set(a,3,t[a]*e.get(0,3)+t[a+4]*e.get(1,3)+t[a+8]*e.get(2,3)+t[a+12]*e.get(3,3));return this}transformVec4(e){return e.set(this.get(0,0)*e.x+this.get(0,1)*e.y+this.get(0,2)*e.z+this.get(0,3)*e.w,this.get(1,0)*e.x+this.get(1,1)*e.y+this.get(1,2)*e.z+this.get(1,3)*e.w,this.get(2,0)*e.x+this.get(2,1)*e.y+this.get(2,2)*e.z+this.get(2,3)*e.w,this.get(3,0)*e.x+this.get(3,1)*e.y+this.get(3,2)*e.z+this.get(3,3)*e.w)}static transformVec4(e,t){return e.transformVec4(t)}rotateQuat(e){return e.set(this.get(0,0)*e.x+this.get(0,1)*e.y+this.get(0,2)*e.z+this.get(0,3)*e.w,this.get(1,0)*e.x+this.get(1,1)*e.y+this.get(1,2)*e.z+this.get(1,3)*e.w,this.get(2,0)*e.x+this.get(2,1)*e.y+this.get(2,2)*e.z+this.get(2,3)*e.w,this.get(3,0)*e.x+this.get(3,1)*e.y+this.get(3,2)*e.z+this.get(3,3)*e.w)}static rotateQuat(e,t){return e.rotateQuat(t)}transformVec3(e){return e.set(this.get(0,0)*e.x+this.get(0,1)*e.y+this.get(0,2)*e.z,this.get(1,0)*e.x+this.get(1,1)*e.y+this.get(1,2)*e.z,this.get(2,0)*e.x+this.get(2,1)*e.y+this.get(2,2)*e.z)}static transformVec3(e,t){return e.transformVec3(t)}scale(e){return this.set(0,0,this.get(0,0)*e.x),this.set(1,0,this.get(1,0)*e.x),this.set(2,0,this.get(2,0)*e.x),this.set(3,0,this.get(3,0)*e.x),this.set(0,1,this.get(0,1)*e.y),this.set(1,1,this.get(1,1)*e.y),this.set(2,1,this.get(2,1)*e.y),this.set(3,1,this.get(3,1)*e.y),this.set(0,2,this.get(0,2)*e.z),this.set(1,2,this.get(1,2)*e.z),this.set(2,2,this.get(2,2)*e.z),this.set(3,2,this.get(3,2)*e.z),this}determinant(){const e=this.get(0,0),t=this.get(0,1),a=this.get(0,2),n=this.get(0,3),r=this.get(1,0),i=this.get(1,1),o=this.get(1,2),s=this.get(1,3),d=this.get(2,0),l=this.get(2,1),c=this.get(2,2),p=this.get(2,3),u=this.get(3,0),m=this.get(3,1),g=this.get(3,2),f=this.get(3,3);return n*o*l*u-a*s*l*u-n*i*c*u+t*s*c*u+a*i*p*u-t*o*p*u-n*o*d*m+a*s*d*m+n*r*c*m-e*s*c*m-a*r*p*m+e*o*p*m+n*i*d*g-t*s*d*g-n*r*l*g+e*s*l*g+t*r*p*g-e*i*p*g-a*i*d*f+t*o*d*f+a*r*l*f-e*o*l*f-t*r*c*f+e*i*c*f}transpose(){let e=this.get(0,1);return this.set(0,1,this.get(1,0)),this.set(1,0,e),e=this.get(0,2),this.set(0,2,this.get(2,0)),this.set(2,0,e),e=this.get(0,3),this.set(0,3,this.get(3,0)),this.set(3,0,e),e=this.get(1,2),this.set(1,2,this.get(2,1)),this.set(2,1,e),e=this.get(1,3),this.set(1,3,this.get(3,1)),this.set(3,1,e),e=this.get(2,3),this.set(2,3,this.get(3,2)),this.set(3,2,e),this}fromToRotation(e,t){const a=new he;this.identity(),he.fromToRotation(e,t,a);for(let n=0;3>n;++n)for(let e=0;3>e;++e)this.set(n,e,a.get(n,e));return this}static fromToRotation(e,t,a){return void 0===a&&(a=new xe),a.fromToRotation(e,t)}fromBasisXYZ(e,t,a){return this.set(0,0,e.x),this.set(0,1,t.x),this.set(0,2,a.x),this.set(0,3,0),this.set(1,0,e.y),this.set(1,1,t.y),this.set(1,2,a.y),this.set(1,3,0),this.set(2,0,e.z),this.set(2,1,t.z),this.set(2,2,a.z),this.set(2,3,0),this.set(3,0,0),this.set(3,1,0),this.set(3,2,0),this.set(3,3,1),this}static fromBasisXYZ(e,t,a,n){return void 0===n&&(n=new xe),n.fromBasisXYZ(e,t,a)}fromOrtho(e,t,a,n,r,i){this.identity();const o=t-e,s=n-a,d=i-r;return this.set(0,0,2/o),this.set(0,3,-(t+e)/o),this.set(1,1,2/s),this.set(1,3,-(n+a)/s),this.set(2,2,-2/d),this.set(2,3,-(i+r)/d),this}static fromOrtho(e,t,a,n,r,i,o){return void 0===o&&(o=new xe),o.fromOrtho(e,t,a,n,r,i)}fromFrustum(e,t,a,n,r,i){return this.set(0,0,2*r/(t-e)),this.set(0,1,0),this.set(0,2,(t+e)/(t-e)),this.set(0,3,0),this.set(1,0,0),this.set(1,1,2*r/(n-a)),this.set(1,2,(n+a)/(n-a)),this.set(1,3,0),this.set(2,0,0),this.set(2,1,0),this.set(2,2,-(i+r)/(i-r)),this.set(2,3,-(2*i*r)/(i-r)),this.set(3,0,0),this.set(3,1,0),this.set(3,2,-1),this.set(3,3,0),this}static fromFrustum(e,t,a,n,r,i,o){return void 0===o&&(o=new xe),o.fromFrustum(e,t,a,n,r,i)}fromPerspective(e,t,a,n){var r=Math.sin,i=Math.cos;const o=Q(.5*e),s=i(o)/r(o),d=a-n;return this.set(0,0,s/t),this.set(0,1,0),this.set(0,2,0),this.set(0,3,0),this.set(1,0,0),this.set(1,1,s),this.set(1,2,0),this.set(1,3,0),this.set(2,0,0),this.set(2,1,0),this.set(2,2,(n+a)/d),this.set(2,3,2*a*n/d),this.set(3,0,0),this.set(3,1,0),this.set(3,2,-1),this.set(3,3,0),this}static fromPerspective(e,t,a,n,r){return void 0===r&&(r=new xe),r.fromPerspective(e,t,a,n)}static fromTranslation(e,t,a,n){return void 0===n?n=new xe:n.identity(),n.set(0,3,e),n.set(1,3,t),n.set(2,3,a),n}fromQuaternion(e){const t=2*e.x,a=2*e.y,n=2*e.z,r=e.x*t,i=e.y*a,o=e.z*n,s=e.x*a,d=e.x*n,l=e.y*n,c=e.w*t,p=e.w*a,u=e.w*n;return this.set(0,0,1-(i+o)),this.set(1,0,s+u),this.set(2,0,d-p),this.set(3,0,0),this.set(0,1,s-u),this.set(1,1,1-(r+o)),this.set(2,1,l+c),this.set(3,1,0),this.set(0,2,d+p),this.set(1,2,l-c),this.set(2,2,1-(r+i)),this.set(3,2,0),this.set(0,3,0),this.set(1,3,0),this.set(2,3,0),this.set(3,3,1),this}static fromQuaternion(e,t){return void 0===t&&(t=new xe),t.fromQuaternion(e)}fromRotation(e){return this.fromQuaternion(e),this}static fromRotation(e,t){return void 0===t&&(t=new xe),t.fromRotation(e)}fromCompose(e,t,a){return this.fromQuaternion(t),this.set(0,0,this.get(0,0)*a.x),this.set(1,0,this.get(1,0)*a.x),this.set(2,0,this.get(2,0)*a.x),this.set(0,1,this.get(0,1)*a.y),this.set(1,1,this.get(1,1)*a.y),this.set(2,1,this.get(2,1)*a.y),this.set(0,2,this.get(0,2)*a.z),this.set(1,2,this.get(1,2)*a.z),this.set(2,2,this.get(2,2)*a.z),this.set(0,3,e.x),this.set(1,3,e.y),this.set(2,3,e.z),this}static fromCompose(e,t,a,n){return void 0===n&&(n=new xe),n.fromCompose(e,t,a)}decompose(e,t,a){e.x=this.get(0,3),e.y=this.get(1,3),e.z=this.get(2,3),this.set(0,3,0),this.set(1,3,0),this.set(2,3,0);const n=new $(this.get(0,0),this.get(1,0),this.get(2,0)),r=new $(this.get(0,1),this.get(1,1),this.get(2,1)),i=new $(this.get(0,2),this.get(1,2),this.get(2,2)),o=n.len(),s=r.len(),d=i.len();a.x=o,a.y=s,a.z=d;const l=new xe(o,0,0,0,0,s,0,0,0,0,d,0,0,0,0,1);return this.mul(l.inv()),ve.fromMatrix4(this,t),this}}var Se=effect.Amaz;class Me{constructor(e,t=void 0,a=void 0,n=void 0){this.owner=e,t&&(this.horizontal=t),a&&(this.depth=a),n&&(this.vertical=n)}setUniformWrapMode(e){this.horizontal=e,this.depth=e,this.vertical=e}get horizontal(){return this.owner.native?this.owner.native.wrapModeS:null}set horizontal(e){null!=e&&this.owner.native&&(this.owner.native.wrapModeS=e)}get depth(){return this.owner.native?this.owner.native.wrapModeR:null}set depth(e){null!=e&&this.owner.native&&(this.owner.native.wrapModeR=e)}get vertical(){return this.owner.native?this.owner.native.wrapModeT:null}set vertical(e){null!=e&&this.owner.native&&(this.owner.native.wrapModeT=e)}}class Fe{constructor(e,t=void 0,a=void 0,n=void 0){this.owner=e,t&&(this.min=t),a&&(this.mag=a),n&&(this.mipMap=n)}get min(){return this.owner.native?this.owner.native.filterMin:null}set min(e){null!=e&&this.owner.native&&(this.owner.native.filterMin=e)}get mag(){return this.owner.native?this.owner.native.filterMag:null}set mag(e){null!=e&&this.owner.native&&(this.owner.native.filterMag=e)}get mipMap(){return this.owner.native?this.owner.native.filterMipmap:null}set mipMap(e){null!=e&&this.owner.native&&(this.owner.native.filterMipmap=e)}}class Pe{constructor(e=void 0){if(this.name="no-name",this.native=null,this.wrapMode=new Me(this),this.filterMode=new Fe(this),null!=e&&e.native){const t=e.native;this.fromNative(t)}else if(null!=e&&e.path){const a=null==e?void 0:e.path;this.native=null;try{var t;this.native=null==(t=Li.assets.loadSync(a))?void 0:t.resource}catch(t){console.error(t)}}else this.native=new Se.Texture;const a=null==e?void 0:e.options;a&&this.fromOptions(a)}fromNative(e){return e?void(this.native=e,this.width=e.width,this.height=e.height,this.depth=e.depth,this.wrapMode=new Me(this,e.wrapModeS,e.wrapModeR,e.wrapModeT),this.filterMode=new Fe(this,e.filterMin,e.filterMag,e.filterMipmap)):void console.error("Amaz.Texture class is invalid")}fromOptions(e){e&&(e.width!==void 0&&(this.width=e.width),e.height!==void 0&&(this.height=e.height),e.depth!==void 0&&(this.depth=e.depth),e.horizontalWrap!==void 0&&(this.wrapMode.horizontal=e.horizontalWrap),e.verticalWrap!==void 0&&(this.wrapMode.vertical=e.verticalWrap),e.depthWrap!==void 0&&(this.wrapMode.depth=e.depthWrap),e.magFilter!==void 0&&(this.filterMode.mag=e.magFilter),e.minFilter!==void 0&&(this.filterMode.min=e.minFilter),e.mipMapFilter!==void 0&&(this.filterMode.mipMap=e.mipMapFilter))}getSize(){return{width:this.width,height:this.height}}get height(){return this.native?this.native.height:-1}set height(e){e&&this.native&&(this.native.height=e)}get width(){return this.native?this.native.width:-1}set width(e){e&&this.native&&(this.native.width=e)}get depth(){return this.native?this.native.depth:-1}set depth(e){e&&this.native&&(this.native.depth=e)}get internalFormat(){return this.native?this.native.internalFormat:null}set internalFormat(e){this.native&&null!=e&&(this.native.internalFormat=e)}get dataType(){return this.native?this.native.dataType:null}set dataType(e){this.native&&null!=e&&(this.native.dataType=e)}get enableMipMap(){return this.native?this.native.enableMipmap:null}set enableMipMap(e){this.native&&null!=e&&(this.native.enableMipmap=e)}get builtinType(){return this.native?this.native.builtinType:null}set builtinType(e){this.native&&null!=e&&(this.native.builtinType=e)}get maxAnisotropy(){return this.native?this.native.maxAnisotropy:-1}set maxAnisotropy(e){this.native&&(this.native.maxAnisotropy=e)}}var Re=effect.Amaz;const Ae="gles2";class Ie{constructor(e=void 0){this.native=new Re.RenderState,this.rasterizationState=new Re.RasterizationState,this.depthStencilState=new Re.DepthStencilState,this.colorBlendState=new Re.ColorBlendState,this.colorBlendAttachmentState=new Re.ColorBlendAttachmentState,this.native=e?e:new Re.RenderState}}class be{constructor(e,t=""){this.native=new Re.Shader,this._type=-1,this._source="",this.type=e,this.source=t}get type(){return this._type}set type(e){this._type=e,this.native.type=this._type}get source(){return this._source}set source(e){this._source=e,this.native.source=this._source}}class Ee{constructor(e){this.native=new Re.XShader,this.vertexShader=new be(b.VERTEX),this.fragmentShader=new be(b.FRAGMENT),this.attributes=new Map([["a_Position",Re.VertexAttribType.POSITION],["a_Normal",Re.VertexAttribType.NORMAL],["a_Color",Re.VertexAttribType.COLOR],["a_UV",Re.VertexAttribType.TEXCOORD0]]),this.renderState=new Ie,this._cullMode=z.NONE,this._frontFace=B.COUNTER_CLOCKWISE,this._polygonMode=L.FILL,this._depthTestEnable=!1,this._depthWriteEnable=!0,this._stencilTestEnable=!1,this._depthCompareOp=O.LESS,this._srcColorBlendFactor=k.ONE,this._dstColorBlendFactor=k.ZERO,this._srcAlphaBlendFactor=k.ONE,this._dstAlphaBlendFactor=k.ZERO,this._colorBlendOp=N.ADD,this._alphaBlendOp=N.ADD,this._blendEnable=!0;const t=null==e?void 0:e.native;if(t)this.native=t,this.fromNative(t);else if(e&&null!=e&&e.path){var a;const t=null==e?void 0:e.path,n=null==(a=Li.assets.loadSync(t))?void 0:a.resource;this.fromNative(n);const r=null==e?void 0:e.options;r&&this.fromOptions(r)}else{const t=null==e?void 0:e.vertex;t&&(this.vertexShader.source=t);const a=null==e?void 0:e.fragment;a&&(this.fragmentShader.source=a);const n=null==e?void 0:e.attributes;if(n)for(const[e,t]of Object.entries(n))this.attributes.set(e,t);const r=null==e?void 0:e.options;if(r&&this.fromOptions(r),t)this.vertexShader.source=t;else throw new Error("vertex shader source is missing from shader");if(a)this.fragmentShader.source=a;else throw new Error("fragment shader source is missing from shader");const i=new Re.Map;if(this.attributes.forEach((e,t)=>{i.insert(t,e)}),0>=this.vertexShader.source.length)throw new Error("Missing source for vertex shader");if(0>=this.fragmentShader.source.length)throw new Error("Missing source for fragment shader");const o=new Re.Vector;o.pushBack(this.vertexShader.native),o.pushBack(this.fragmentShader.native);const s=new Re.Map,d=null!=e&&e.language?null==e?void 0:e.language:Ae;s.insert(d,o),this.renderState.rasterizationState.cullMode=this.cullMode,this.renderState.rasterizationState.polygonMode=this.polygonMode,this.renderState.rasterizationState.frontFace=this.frontFace,this.renderState.native.rasterization=this.renderState.rasterizationState,this.renderState.depthStencilState.depthTestEnable=this.depthTestEnable,this.renderState.depthStencilState.depthWriteEnable=this.depthWriteEnable,this.renderState.depthStencilState.stencilTestEnable=this.stencilTestEnable,this.renderState.depthStencilState.depthCompareOp=this.depthCompareOp,this.renderState.native.depthstencil=this.renderState.depthStencilState,this.renderState.colorBlendAttachmentState.srcColorBlendFactor=this.srcColorBlendFactor,this.renderState.colorBlendAttachmentState.dstColorBlendFactor=this.dstColorBlendFactor,this.renderState.colorBlendAttachmentState.srcAlphaBlendFactor=this.srcAlphaBlendFactor,this.renderState.colorBlendAttachmentState.dstAlphaBlendFactor=this.dstAlphaBlendFactor,this.renderState.colorBlendAttachmentState.colorWriteMask=15,this.renderState.colorBlendAttachmentState.ColorBlendOp=this.colorBlendOp,this.renderState.colorBlendAttachmentState.AlphaBlendOp=this.alphaBlendOp,this.renderState.colorBlendAttachmentState.blendEnable=this.blendEnable;const l=new Re.Vector;l.pushBack(this.renderState.colorBlendAttachmentState),this.renderState.colorBlendState.attachments=l,this.renderState.native.colorBlend=this.renderState.colorBlendState;const c=new Re.Pass;c.semantics=i,c.shaders=s,c.renderState=this.renderState.native;const p=new Re.Vector;p.pushBack(c),this.native=new Re.XShader,this.native.passes=p}}fromNative(e){var t,a,n,r,i;if(this.native=e,0>=this.native.passes.size())return void console.error("Shader: does not have any passes. ");const o=this.native.passes.get(0),s=o.shaders,d=s.getVectorKeys();for(let t=0;t<d.size();++t){const e=d.get(t),a=s.get(e);for(let e=0;e<a.size();++e){const t=a.get(e);let n=t.source&&0<t.source.length?t.source:"";n=t.sourcePath&&0<t.sourcePath.length?t.sourcePath:n,t.type===b.VERTEX?this.vertexShader=new be(b.VERTEX,n):t.type===b.FRAGMENT&&(this.fragmentShader=new be(b.FRAGMENT,n))}}const l=o.semantics,c=l.getVectorKeys();for(let t=0;t<c.size();++t){const e=c.get(t),a=l.get(e);this.attributes.set(e,a)}const p=null==(t=o.renderState)?void 0:t.rasterization;p&&(this.cullMode=p.cullMode,this.polygonMode=p.polygonMode,this.frontFace=p.frontFace);const u=null==(a=o.renderState)?void 0:a.depthstencil;u&&(this.depthTestEnable=u.depthTestEnable,this.depthWriteEnable=u.depthWriteEnable,this.stencilTestEnable=u.stencilTestEnable,this.depthCompareOp=u.depthCompareOp);const m=null==(n=o.renderState)||null==(r=n.colorBlend)||null==(i=r.attachments)?void 0:i.get(0);m&&(this.srcColorBlendFactor=m.srcColorBlendFactor,this.dstColorBlendFactor=m.dstColorBlendFactor,this.srcAlphaBlendFactor=m.srcAlphaBlendFactor,this.dstAlphaBlendFactor=m.dstAlphaBlendFactor,this.colorBlendOp=m.ColorBlendOp,this.alphaBlendOp=m.AlphaBlendOp,this.blendEnable=m.blendEnable)}fromOptions(e){e&&(e.cullMode&&(this.cullMode=e.cullMode),e.frontFace&&(this.frontFace=e.frontFace),e.polygonMode&&(this.polygonMode=e.polygonMode),e.depthTestEnable&&(this.depthTestEnable=e.depthTestEnable),e.depthWriteEnable&&(this.depthWriteEnable=e.depthWriteEnable),e.stencilTestEnable&&(this.stencilTestEnable=e.stencilTestEnable),e.depthCompareOp&&(this.depthCompareOp=e.depthCompareOp),e.srcColorBlendFactor&&(this.srcColorBlendFactor=e.srcColorBlendFactor),e.dstColorBlendFactor&&(this.dstColorBlendFactor=e.dstColorBlendFactor),e.srcAlphaBlendFactor&&(this.srcAlphaBlendFactor=e.srcAlphaBlendFactor),e.dstAlphaBlendFactor&&(this.dstAlphaBlendFactor=e.dstAlphaBlendFactor),e.colorBlendOp&&(this.colorBlendOp=e.colorBlendOp),e.alphaBlendOp&&(this.alphaBlendOp=e.alphaBlendOp),e.blendEnable&&(this.blendEnable=e.blendEnable))}get cullMode(){return this._cullMode}set cullMode(e){this._cullMode=e,this.renderState.rasterizationState.cullMode=this._cullMode}get frontFace(){return this._frontFace}set frontFace(e){this._frontFace=e,this.renderState.rasterizationState.frontFace=this._frontFace}get polygonMode(){return this._polygonMode}set polygonMode(e){this._polygonMode=e,this.renderState.rasterizationState.polygonMode=this._polygonMode}get depthTestEnable(){return this._depthTestEnable}set depthTestEnable(e){this._depthTestEnable=e,this.renderState.depthStencilState.depthTestEnable=this._depthTestEnable}get depthWriteEnable(){return this._depthWriteEnable}set depthWriteEnable(e){this._depthWriteEnable=e,this.renderState.depthStencilState.depthWriteEnable=this._depthWriteEnable}get stencilTestEnable(){return this._stencilTestEnable}set stencilTestEnable(e){this._stencilTestEnable=e,this.renderState.depthStencilState.stencilTestEnable=this._stencilTestEnable}get depthCompareOp(){return this._depthCompareOp}set depthCompareOp(e){this._depthCompareOp=e,this.renderState.depthStencilState.depthCompareOp=this._depthCompareOp}get srcColorBlendFactor(){return this._srcColorBlendFactor}set srcColorBlendFactor(e){this._srcColorBlendFactor=e;const t=this.renderState.colorBlendState.attachments.front();t&&(t.srcColorBlendFactor=this._srcColorBlendFactor)}get dstColorBlendFactor(){return this._dstColorBlendFactor}set dstColorBlendFactor(e){this._dstColorBlendFactor=e;const t=this.renderState.colorBlendState.attachments.front();t&&(t.dstColorBlendFactor=this._dstColorBlendFactor)}get srcAlphaBlendFactor(){return this._srcAlphaBlendFactor}set srcAlphaBlendFactor(e){this._srcAlphaBlendFactor=e;const t=this.renderState.colorBlendState.attachments.front();t&&(t.srcAlphaBlendFactor=this._srcAlphaBlendFactor)}get dstAlphaBlendFactor(){return this._dstAlphaBlendFactor}set dstAlphaBlendFactor(e){this._dstAlphaBlendFactor=e;const t=this.renderState.colorBlendState.attachments.front();t&&(t.dstAlphaBlendFactor=this._dstAlphaBlendFactor)}get colorBlendOp(){return this._colorBlendOp}set colorBlendOp(e){this._colorBlendOp=e;const t=this.renderState.colorBlendState.attachments.front();t&&(t.ColorBlendOp=this._colorBlendOp)}get alphaBlendOp(){return this._alphaBlendOp}set alphaBlendOp(e){this._alphaBlendOp=e;const t=this.renderState.colorBlendState.attachments.front();t&&(t.AlphaBlendOp=this._alphaBlendOp)}get blendEnable(){return this._blendEnable}set blendEnable(e){this._blendEnable=e;const t=this.renderState.colorBlendState.attachments.front();t&&(t.blendEnable=this._blendEnable)}}var ze=effect.Amaz;class Be{constructor(e=void 0){this.name="no-name",this.uniforms=new Map;const t=null==e?void 0:e.native;if(t)this.native=t,this.frontNative(this.native),this.shader=new Ee({native:this.native.xshader});else{this.native=new ze.Material;const t=null==e?void 0:e.shader;t&&(this.shader=t);const a=null==e?void 0:e.uniforms;if(a)for(const[e,t]of Object.entries(a))this.uniforms.set(e,t);const n=null==e?void 0:e.macros;if(n)for(const[e,t]of Object.entries(n))this.addMacro(e,t)}this.uniforms&&this.uniforms.forEach((e,t)=>{this.setUniform(t,e)})}frontNative(e=void 0){if(!e)return;const t=e.properties,a=t.floatmap.getVectorKeys();for(let n=0;n<a.size();++n){const e=a.get(n);this.uniforms.set(e,t.getFloat(e))}const n=t.vec2map.getVectorKeys();for(let a=0;a<n.size();++a){const e=n.get(a),r=t.getVec2(e);this.uniforms.set(e,new oe(r))}const r=t.vec3map.getVectorKeys();for(let a=0;a<r.size();++a){const e=r.get(a),n=t.getVec3(e);this.uniforms.set(e,new $(n))}const o=t.vec4map.getVectorKeys();for(let a=0;a<o.size();++a){const e=o.get(a),n=t.getVec4(e);this.uniforms.set(e,new me(n))}const s=t.mat4map.getVectorKeys();for(let a=0;a<s.size();++a){const e=s.get(a),n=t.getMat4(e);this.uniforms.set(e,new xe(n))}const d=t.texmap.getVectorKeys();for(let a=0;a<d.size();++a){const e=d.get(a),n=t.getTex(e);this.uniforms.set(e,n)}}clone(){return new Be({native:this.native.instantiate()})}setUniform(e,t){if(this.uniforms.set(e,t),"number"==typeof t)this.native.setFloat(e,t);else if(t instanceof oe)this.native.setVec2(e,t.native);else if(t instanceof $)this.native.setVec3(e,t.native);else if(t instanceof me)this.native.setVec4(e,t.native);else if(t instanceof v){const a=new me(t.r,t.g,t.b,t.a).native;this.native.setVec4(e,a)}else t instanceof xe?this.native.setMat4(e,t.native):t instanceof ze.Texture?this.native.setTex(e,t):t instanceof Pe&&(t.native?this.native.setTex(e,t.native):console.error("Texutre "+t.name+".native is null"))}addProperty(e,t){this.setUniform(e,t)}getUniform(e){if(this.uniforms.has(e)){const t=this.uniforms.get(e);if("number"==typeof t);else{if(t instanceof oe)return t;if(t instanceof $)return t;if(t instanceof me)return t;if(t instanceof v)return t;if(t instanceof xe)return t;if(t instanceof ze.Texture)return t;if(t instanceof Pe)return t}}}removeUniform(e){this.uniforms.set(e,void 0)}addMacro(e,t){this.native.enableMacro(e,t)}removeMacro(e){this.native.disableMacro(e)}set shader(e){this.native.xshader=e.native}}var Le=effect.Amaz;const Oe=["castShadow","mesh","material","materials"];class ke extends a{constructor(e,t){super(e,"MeshRenderer"),this._materials=[],0>=this._materials.length&&this._materials.push(new Be),e&&this.initialize(t,Oe)}static register(){a.registerComponentType("Model",this.nativeClasses,ke),this.register=()=>void 0}static fromNative(e,t){const a=new ke;if(t instanceof Le.MeshRenderer)a.initWithNative(e,t,"MeshRenderer");else throw new Error("Incorrect argument to ModelComponent::fromNative");return t.material&&0<a._materials.length&&(a._materials[0]=new Be({native:t.material})),a}get castShadow(){return this.native.castShadow}set castShadow(e){this.native.castShadow=e}get mesh(){return this.native.mesh}set mesh(e){this.native.mesh=e.native}get material(){return this._materials&&0<this._materials.length?this._materials[0]:void 0}set material(e){if(0>=this._materials.length)throw new Error("Model Component materials is empty! ");if(e){var t;this._materials[0]=e,this.native.material=null==(t=this.material)?void 0:t.native}}setMaterial(e,t){return e>=this._materials.length?void console.error("Index "+e+" is out of range"):void(this._materials[e]=t,this.native.materials.set(e,this._materials[e].native))}get materials(){return this._materials}set materials(e){if(e){this._materials=e;const t=this._materials.length;this.native.materials.clear();for(let e=0;e<t;++e)this.native.materials.pushBack(this._materials[e].native)}}}ke.nativeClasses=["MeshRenderer"],ke.register();var Ne=effect.Amaz;const De=["autoPlay","flipDirection","totalParticles","material","emitterRadius","emissionRate","lifetime","scale","angle","speed","rotationX","rotationY","rotationZ","rotationXSpeed","rotationYSpeed","rotationZSpeed","colors","orientation","sortingMode","renderType","mesh","displayMode","orientationStart","orientationEnd","affectorType","colorAffectorOperation","colorAffectorColors"];class we extends a{constructor(e,t){if(e){super(e,"ParticleComponent");let a;if(a=t&&t.hasOwnProperty("renderType")?t.renderType:exports.ParticleSystemRenderType.Quad,a==exports.ParticleSystemRenderType.Mesh)this.native.renderer=new Ne.ParticleMeshRenderer;else if(a==exports.ParticleSystemRenderType.Quad)this.native.renderer=new Ne.ParticleQuatRenderer;else throw new Error("Incorrect options: renderType");let n;if(t&&t.hasOwnProperty("affectorType")&&(n=t.affectorType),n==exports.ParticleSystemAffector.Color){const e=new Ne.Vector;e.pushBack(new Ne.ColorAffector),this.native.affectors=e}const r=new Ne.Vector;r.pushBack(new Ne.CircleEmitter),this.native.emitters=r,this.initialize(t,this.getProps())}else super()}static register(){a.registerComponentType("ParticleSystem",this.nativeClasses,we),this.register=()=>void 0}static fromNative(e,t){const a=new we;if(t instanceof Ne.ParticleComponent)a.initWithNative(e,t,"ParticleComponent");else throw new Error("Incorrect argument to ParticleSystemComponent::fromNative");return a}getEmitter(){const e=this.native.emitters.get(0);return e instanceof Ne.CircleEmitter?e:void 0}getAffector(){const e=this.native.affectors.get(0);return e instanceof Ne.ColorAffector?e:void 0}getProps(){return De}isPlaying(){return this.native.isStarted()}start(){const e=this.getEmitter();return e&&(e.enable=!0),this.native.start()}stop(){return this.native.stop()}resume(){return this.native.resume()}pause(){return this.native.pause()}get orientation(){if(this.native.renderer instanceof Ne.ParticleQuatRenderer)return this.native.renderer.orientationType;throw new Error("Not supported param for render type")}set orientation(e){if(this.native.renderer instanceof Ne.ParticleQuatRenderer)this.native.renderer.orientationType=e;else throw new Error("Not supported param for render type")}get sortingMode(){return this.native.renderer.sortingMode}set sortingMode(e){this.native.renderer.sortingMode=e}get displayMode(){if(this.native.renderer instanceof Ne.ParticleMeshRenderer)return this.native.renderer.displayMode;throw new Error("Not supported param for render type")}set displayMode(e){if(this.native.renderer instanceof Ne.ParticleMeshRenderer)this.native.renderer.displayMode=e;else throw new Error("Not supported param for render type")}get mesh(){return this.native.renderer.templateMesh}set mesh(e){this.native.renderer.templateMesh=e}get autoPlay(){return this.native.autoStart}set autoPlay(e){this.native.autoStart=e}get flipDirection(){return this.native.flipY}set flipDirection(e){this.native.flipY=e}get totalParticles(){return this.native.particleQuota}set totalParticles(e){this.native.particleQuota=e}get material(){if(!this._material){const e=this.native.material;e&&(this._material=new Be(e))}return this._material}set material(e){e&&(this._material=e,this.native.material=e.native)}get emitterRadius(){const e=this.getEmitter();if(e)return{min:e.inner_radius,max:e.radius};throw new Error("Invalid emitter in ParticleSystemComponent::get emitterRadius")}set emitterRadius(e){const t=this.getEmitter();if(t)t.innder_radius=e.min,t.radius=e.max;else throw new Error("Invalid emitter in ParticleSystemComponent::set emitterRadius")}get emissionRate(){const e=this.getEmitter();if(e){const t=e.emissionRate;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get emissionRate")}set emissionRate(e){const t=this.getEmitter();if(t){const a=t.emissionRate;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set emissionRate")}get lifetime(){const e=this.getEmitter();if(e){const t=e.totalTimeToLive;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get lifetime")}set lifetime(e){const t=this.getEmitter();if(t){const a=t.totalTimeToLive;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set lifetime")}get scale(){const e=this.getEmitter();if(e){const t=e.particleScale;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get scale")}set scale(e){const t=this.getEmitter();if(t){const a=t.particleScale;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set scale")}get angle(){const e=this.getEmitter();if(e){const t=e.angle;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get angle")}set angle(e){const t=this.getEmitter();if(t){const a=t.angle;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set angle")}get speed(){const e=this.getEmitter();if(e){const t=e.particleVelocity;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get speed")}set speed(e){const t=this.getEmitter();if(t){const a=t.particleVelocity;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set speed")}get rotationX(){const e=this.getEmitter();if(e){const t=e.particleXRotation;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get rotationX")}set rotationX(e){const t=this.getEmitter();if(t){const a=t.particleXRotation;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set rotationX")}get rotationY(){const e=this.getEmitter();if(e){const t=e.particleYRotation;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get rotationY")}set rotationY(e){const t=this.getEmitter();if(t){const a=t.particleYRotation;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set rotationY")}get rotationZ(){const e=this.getEmitter();if(e){const t=e.particleZRotation;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get rotationZ")}set rotationZ(e){const t=this.getEmitter();if(t){const a=t.particleZRotation;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set rotationZ")}get rotationXSpeed(){const e=this.getEmitter();if(e){const t=e.particleXRotationSpeed;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get rotationXSpeed")}set rotationXSpeed(e){const t=this.getEmitter();if(t){const a=t.particleXRotationSpeed;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set rotationXSpeed")}get rotationYSpeed(){const e=this.getEmitter();if(e){const t=e.particleYRotationSpeed;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get rotationYSpeed")}set rotationYSpeed(e){const t=this.getEmitter();if(t){const a=t.particleYRotationSpeed;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set rotationYSpeed")}get rotationZSpeed(){const e=this.getEmitter();if(e){const t=e.particleZRotationSpeed;return{min:t.min,max:t.max}}throw new Error("Invalid emitter in ParticleSystemComponent::get rotationZSpeed")}set rotationZSpeed(e){const t=this.getEmitter();if(t){const a=t.particleZRotationSpeed;a.min=e.min,a.max=e.max}else throw new Error("Invalid emitter in ParticleSystemComponent::set rotationZSpeed")}set colors(e){const t=this.getEmitter();if(t){const a=new Ne.Vec4Vector;for(const t of e)a.pushBack(new me(t.r,t.g,t.b,t.a).native);t.particleColorList=a}else throw new Error("Invalid emitter in ParticleSystemComponent::set colors")}get orientationStart(){const e=this.getEmitter();if(e)return e.orientationStart.quaternionToEuler();throw new Error("Invalid emitter in ParticleSystemComponent::get orientationStart")}set orientationStart(e){const t=this.getEmitter();if(t)t.orientationStart=ve.fromEulerAngles(e.x,e.y,e.z);else throw new Error("Invalid emitter in ParticleSystemComponent::set orientationStart")}get orientationEnd(){const e=this.getEmitter();if(e)return e.orientationEnd.quaternionToEuler();throw new Error("Invalid emitter in ParticleSystemComponent::get orientationEnd")}set orientationEnd(e){const t=this.getEmitter();if(t)t.orientationEnd=ve.fromEulerAngles(e.x,e.y,e.z);else throw new Error("Invalid emitter in ParticleSystemComponent::set orientationEnd")}get colorAffectorOperation(){const e=this.getAffector();if(e)return e.colorOperation;throw new Error("Invalid affector in ParticleSystemComponent::get colorAffectorOperation")}set colorAffectorOperation(e){const t=this.getAffector();if(t)t.colorOperation=e;else throw new Error("Invalid affector in ParticleSystemComponent::set colorAffectorOperation")}get colorAffectorColors(){const e=this.getAffector();if(e){const t=[];for(let a=0;a<e.colorMap.size();++a){const n=e.colorMap.get(a);t.push({time:n.get(0),color:new Ne.Color(n.get(1),n.get(2),n.get(3),n.get(4))})}return t}throw new Error("Invalid affector in ParticleSystemComponent::get colorAffectorColors")}set colorAffectorColors(e){const t=this.getAffector();if(t){const a=new Ne.Vector;for(const t of e){const e=new Ne.FloatVector;e.pushBack(t.time),e.pushBack(t.color.r),e.pushBack(t.color.g),e.pushBack(t.color.b),e.pushBack(t.color.a),a.pushBack(e)}t.colorMap=a}else throw new Error("Invalid affector in ParticleSystemComponent::set colorAffectorColors")}}we.nativeClasses=["ParticleComponent"],we.register();const Ve=["type","mass","category","mask"],Ge=16;class Ue extends a{constructor(e,t){e?(super(e,"RigidBody3D"),this.initialize(t,this.getProps())):super()}static register(){a.registerComponentType("RigidBody",this.nativeClasses,Ue),this.register=()=>void 0}initialize(e,t){var a,n;e&&t&&super.initialize(e,t),this.native.initPosition=null==(a=this.sceneObject)?void 0:a.position.native,this.native.initRotation=null==(n=this.sceneObject)?void 0:n.rotationQuat.native,this.moveToLocation(this.native.initPosition,this.native.initRotation)}moveToLocation(e,t){this.native.position=e.native,this.native.rotationQuat=t.native}getProps(){return Ve}getContactPoints(e){const t=[];for(let a=0;a<e.contacts.size();++a)t.push(e.contacts.get(a));return t}get mass(){return this.native.mass}set mass(e){this.native.mass=e}setSensorEnabled(e){this.native.sensor=e}get type(){return this.native.rigidBodyType}set type(e){this.native.rigidBodyType=e}get category(){return Math.log2(this.native.categoryBits)}set category(e){this.native.categoryBits=1<<e}get mask(){const e=[],t=this.native.maskBits;for(let a=0;a<Ge;++a)0<(1<<a&t)&&e.push(a);return e}set mask(e){let t=0;for(const a of e)if(0<=a&&a<Ge)t|=1<<a;else throw new Error("Invalid mask value!");this.native.maskBits=t}}Ue.nativeClasses=["RigidBody3D"],Ue.register();var He=effect.Amaz;const je=["angularDamping","angularFactor","angularVelocity","linearDamping","linearFactor","linearVelocity","gravityAcceleration"];class We extends Ue{constructor(e,t){e?(super(e,t),this.registerCallbacks()):super()}static fromNative(e,t){const a=new We;if(t instanceof He.RigidBody3D&&!t.sensor)a.initWithNative(e,t,"RigidBody3D");else throw new Error("Incorrect argument to RigidBodyComponent::fromNative");return a.registerCallbacks(),a}destroy(){this.removeCallbacks(),super.destroy()}getProps(){const e=super.getProps();return e.concat(je)}initialize(e,t){super.initialize(e,t),this.reset()}reset(){const e=new $(0,0,0);this.native.initLinearVel=e.native,this.native.initAngularVel=e.native,this.native.externalForce=e.native,this.native.forcePosition=e.native,this.native.externalTorque=e.native,this.native.externalImpulse=e.native,this.native.impulsePosition=e.native,this.native.externalTorqueImpulse=e.native,this.linearVelocity=e,this.angularVelocity=e,this.gravityAcceleration=new $(0,-9.81,0)}teleport(e,t){const a=new ve;t&&ve.fromEulerAngles(t.x,t.y,t.z,a),this.moveToLocation(e,a),this.reset()}applyForce(e,t){this.native.externalForce=e.native,this.native.forcePosition=t?t.native:new $(0,0,0).native}applyTorque(e){this.native.externalTorque=e.native}applyImpusle(e,t){this.native.externalImpulse=e.native,this.native.impulsePosition=t?t.native:new $(0,0,0).native}applyTorqueImpulse(e){this.native.externalTorqueImpulse=e.native}get angularDamping(){return this.native.angularDamping}set angularDamping(e){this.native.angularDamping=e}get angularFactor(){return new $(this.native.angularFactor)}set angularFactor(e){this.native.angularFactor=e.native}get angularVelocity(){return new $(this.native.angularVel)}set angularVelocity(e){this.native.angularVel=e.native}get linearDamping(){return this.native.linearDamping}set linearDamping(e){this.native.linearDamping=e}get linearFactor(){return new $(this.native.linearFactor)}set linearFactor(e){this.native.linearFactor=e.native}get linearVelocity(){return new $(this.native.linearVel)}set linearVelocity(e){this.native.linearVel=e.native}get gravityAcceleration(){return new $(this.native.gravityAcceleration)}set gravityAcceleration(e){this.native.gravityAcceleration=e.native}registerCallbacks(){this.addListener(He.Collision3DEventType.ENTER,this.onCollisionEnter,this),this.addListener(He.Collision3DEventType.STAY,this.onCollisionStay,this),this.addListener(He.Collision3DEventType.EXIT,this.onCollisionExit,this)}removeCallbacks(){this.removeListener(He.Collision3DEventType.ENTER,this.onCollisionEnter),this.removeListener(He.Collision3DEventType.STAY,this.onCollisionStay),this.removeListener(He.Collision3DEventType.EXIT,this.onCollisionExit)}onCollisionEnter(e,t){if(t&&t.otherRigidbody){var a,n;const r=t.otherRigidbody.sceneObject,i=null==(a=e.sceneObject)||null==(n=a.scene)?void 0:n.sceneObjectFromNative(r),o=e.getContactPoints(t);t.otherRigidbody.sensor?e.fire("triggerenter",e.sceneObject,i,o):e.fire("collisionenter",e.sceneObject,i,o)}}onCollisionStay(e,t){if(t&&t.otherRigidbody){var a,n;const r=t.otherRigidbody.sceneObject,i=null==(a=e.sceneObject)||null==(n=a.scene)?void 0:n.sceneObjectFromNative(r),o=e.getContactPoints(t);t.otherRigidbody.sensor?e.fire("triggerstay",e.sceneObject,i,o):e.fire("collisionstay",e.sceneObject,i,o)}}onCollisionExit(e,t){if(t&&t.otherRigidbody){var a,n;const r=t.otherRigidbody.sceneObject,i=null==(a=e.sceneObject)||null==(n=a.scene)?void 0:n.sceneObjectFromNative(r),o=e.getContactPoints(t);t.otherRigidbody.sensor?e.fire("triggerexit",e.sceneObject,i,o):e.fire("collisionexit",e.sceneObject,i,o)}}}We.register();const Ye=["alpha","alphaCascading"];class Xe extends a{constructor(e,t,a){if(!(e&&t))super();else if(e.screenTransform)super(e,t),this.initialize(a,this.getProps());else throw new Error("Widget2DComponent can only be added to an 2d sceneObject")}getProps(){return Ye}get alpha(){return this.native.alpha}set alpha(e){this.native.alpha=e}get alphaCascading(){return this.native.cascadeAlphaEnabled}set alphaCascading(e){this.native.cascadeAlphaEnabled=e}}var qe=effect.Amaz;const Ke=["renderMode","color","texture","atlas","atlasIndex","filledType","filledStart","filledRange","slicedLeft","slicedRight","slicedTop","slicedBottom","slicedFillCenter","ellipseWidth","ellipseHeight","freeTopLeft","freeTopRight","freeBottomLeft","freeBottomRight","cornerTopLeft","cornerTopRight","cornerBottomLeft","cornerBottomRight"];class Ze extends Xe{constructor(e,t){super(e,"IFSprite2d",t)}static register(){a.registerComponentType("Image",this.nativeClasses,Ze),this.register=()=>void 0}static fromNative(e,t){const a=new Ze;if(t instanceof qe.IFSprite2d)a.initWithNative(e,t,"IFSprite2d");else throw new Error("Incorrect argument in ImageComponent::fromNative");return a}getProps(){const e=super.getProps();return e.concat(Ke)}get renderMode(){return this.native.type}set renderMode(e){this.native.type=e}get color(){return new v(this.native.colorTint)}set color(e){this.native.colorTint=e.native}get texture(){return this.native.texture}set texture(e){this.native.texture=e}get atlas(){return this.native.imageAtlas}set atlas(e){this.native.imageAtlas=e}get atlasIndex(){return this.native.atlasIndex}set atlasIndex(e){this.native.atlasIndex=e}get filledType(){return this.native.filledType}set filledType(e){this.native.filledType=e}get filledStart(){return this.native.filledStartPos}set filledStart(e){this.native.filledStartPos=e}get filledRange(){return this.native.filledRange}set filledRange(e){this.native.filledRange=e}get slicedLeft(){return this.native.slicedLeft}set slicedLeft(e){this.native.slicedLeft=e}get slicedRight(){return this.native.slicedRight}set slicedRight(e){this.native.slicedRight=e}get slicedTop(){return this.native.slicedTop}set slicedTop(e){this.native.slicedTop=e}get slicedBottom(){return this.native.slicedBottom}set slicedBottom(e){this.native.slicedBottom=e}get slicedFillCenter(){return this.native.fillCenter}set slicedFillCenter(e){this.native.fillCenter=e}get ellipseWidth(){return this.native.ellipseX}set ellipseWidth(e){this.native.ellipseX=e}get ellipseHeight(){return this.native.ellipseY}set ellipseHeight(e){this.native.ellipseY=e}get freeTopLeft(){return new oe(this.native.topLeftPoint)}set freeTopLeft(e){this.native.topLeftPoint=e.native}get freeTopRight(){return new oe(this.native.topRightPoint)}set freeTopRight(e){this.native.topRightPoint=e.native}get freeBottomLeft(){return new oe(this.native.bottomLeftPoint)}set freeBottomLeft(e){this.native.bottomLeftPoint=e.native}get freeBottomRight(){return new oe(this.native.bottomRightPoint)}set freeBottomRight(e){this.native.bottomRightPoint=e.native}get cornerTopLeft(){return this.native.topLeft}set cornerTopLeft(e){this.native.topLeft=e}get cornerTopRight(){return this.native.topRight}set cornerTopRight(e){this.native.topRight=e}get cornerBottomLeft(){return this.native.bottomLeft}set cornerBottomLeft(e){this.native.bottomLeft=e}get cornerBottomRight(){return this.native.bottomRight}set cornerBottomRight(e){this.native.bottomRight=e}}Ze.nativeClasses=["IFSprite2d"],Ze.register();var Qe=effect.Amaz;const Je=["blendMode","alpha","alphaBlending","mask","clipping"];class $e extends a{constructor(e,t){if(!e)super();else if(e.screenTransform)super(e,"IFLayer2d"),t||(t={}),t&&!t.hasOwnProperty("alphaBlending")&&(t.alphaBlending=!0),this.initialize(t,this.getProps());else throw new Error("CanvasComponent can only be added to an 2d sceneObject")}static register(){a.registerComponentType("Canvas",this.nativeClasses,$e),this.register=()=>void 0}static fromNative(e,t){const a=new $e;if(t instanceof Qe.IFLayer2d)a.initWithNative(e,t,"IFLayer2d");else throw new Error("Incorrect argument to CanvasComponent::fromNative");return a}getProps(){return Je}get blendMode(){return this.native.blendMode}set blendMode(e){this.native.blendMode=e}get maskType(){return this.native.maskType}set maskType(e){this.native.maskType=e}get renderOrder(){return this.native.renderOrderMode}set renderOrder(e){this.native.renderOrderMode=e}get alpha(){return this.native.blendAlpha}set alpha(e){this.native.blendAlpha=e}get clipping(){return this.native.scissorRectMask}set clipping(e){this.native.scissorRectMask=e}get alphaBlending(){return this.native.blendAlphaCkeck}set alphaBlending(e){this.native.blendAlphaCkeck=e}getDrawCallCount(){return this.native.drawCallNum}}$e.nativeClasses=["IFLayer2d"],$e.register();var et=effect.Amaz;const tt=["renderMode","pivot","flipX","flipY ","material","color"];class at extends a{constructor(e,t){e?(super(e,"Sprite2DRenderer"),this.initialize(t,this.getProps())):super()}static register(){a.registerComponentType("Sprite",this.nativeClasses,at),this.register=()=>void 0}static fromNative(e,t){const a=new at;if(t instanceof et.Sprite2DRenderer)a.initWithNative(e,t,"Sprite2DRenderer");else throw new Error("Incorrect argument in SpriteComponent::fromNative");return a}getProps(){return tt}get material(){if(!this._material){const e=this.native.material;e&&(this._material=new Be(e))}return this._material}set material(e){e&&(this._material=e,this.native.material=e.native)}get flipX(){return this.native.mirror}set flipX(e){this.native.mirror=e}get flipY(){return this.native.flip}set flipY(e){this.native.flip=e}get color(){return new v(this.native.color)}set color(e){this.native.color=e.native}get pivot(){return new oe(this.native.pivot)}set pivot(e){this.native.pivot=e.native}get renderMode(){return this.native.stretchMode}set renderMode(e){this.native.stretchMode=e}setBaseTexture(e,t,a){t===void 0&&(t=new me(1,1,0,0)),a===void 0&&(a=et.RotateType.ROTATE_0),this.native.setBaseTexture(e,t.native,a)}}at.nativeClasses=["Sprite2DRenderer"],at.register();var nt=effect.Amaz;const rt=["sequence","textureName","autoPlay","playMode"];class it extends a{constructor(e,t){e?(super(e,"AnimSeqComponent"),this.initialize(t,this.getProps())):super()}static register(){a.registerComponentType("SeqAnimation",this.nativeClasses,it),this.register=()=>void 0}static fromNative(e,t){const a=new it;if(t instanceof nt.AnimSeqComponent)a.initWithNative(e,t,"AnimSeqComponent");else throw new Error("Incorrect argument in SeqAnimationComponent::fromNative");return a}getProps(){return rt}play(){this.native.play()}stop(){this.native.stop()}pause(){this.native.pause()}resume(){this.native.play()}seek(e){this.native.seek(e)}get sequence(){return this.native.animSeq}set sequence(e){this.native.animSeq=e}get textureName(){return this.native.texName}set textureName(e){this.native.texName=e}get autoPlay(){return this.native.autoplay}set autoPlay(e){this.native.autoplay=e}get playMode(){return this.native.playmode}set playMode(e){this.native.playmode=e}}it.nativeClasses=["AnimSeqComponent"],it.register();var ot=effect.Amaz;class st extends Ue{constructor(e,t){if(e){const a={type:exports.Physics3DType.Kinematic,mass:1};t&&(a.category=t.category,a.mask=t.mask),super(e,a),this.setSensorEnabled(!0),this.registerCallbacks()}else super()}static fromNative(e,t){const a=new st;if(t instanceof ot.RigidBody3D&&t.sensor)a.initWithNative(e,t,"RigidBody3D");else throw new Error("Incorrect argument to TriggerComponent::fromNative");return a.registerCallbacks(),a}destroy(){this.removeCallbacks(),super.destroy()}registerCallbacks(){this.addListener(ot.Collision3DEventType.ENTER,this.onTriggerEnter,this),this.addListener(ot.Collision3DEventType.STAY,this.onTriggerStay,this),this.addListener(ot.Collision3DEventType.EXIT,this.onTriggerExit,this)}removeCallbacks(){this.removeListener(ot.Collision3DEventType.ENTER,this.onTriggerEnter),this.removeListener(ot.Collision3DEventType.STAY,this.onTriggerStay),this.removeListener(ot.Collision3DEventType.EXIT,this.onTriggerExit)}onTriggerEnter(e,t){if(t&&t.otherRigidbody){var a,n;const r=t.otherRigidbody.sceneObject,i=null==(a=e.sceneObject)||null==(n=a.scene)?void 0:n.sceneObjectFromNative(r),o=e.getContactPoints(t);e.fire("triggerenter",e.sceneObject,i,o)}}onTriggerStay(e,t){if(t&&t.otherRigidbody){var a,n;const r=t.otherRigidbody.sceneObject,i=null==(a=e.sceneObject)||null==(n=a.scene)?void 0:n.sceneObjectFromNative(r),o=e.getContactPoints(t);e.fire("triggerstay",e.sceneObject,i,o)}}onTriggerExit(e,t){if(t&&t.otherRigidbody){var a,n;const r=t.otherRigidbody.sceneObject,i=null==(a=e.sceneObject)||null==(n=a.scene)?void 0:n.sceneObjectFromNative(r),o=e.getContactPoints(t);e.fire("triggerexit",e.sceneObject,i,o)}}}st.register();const dt=["touchEnabled"];class lt extends a{constructor(e,t,a){if(!(e&&t))super();else if(e.screenTransform)super(e,t),this.initialize(a,this.getProps());else throw new Error("UIInteractComponent can only be added to an 2d sceneObject")}getProps(){return dt}get touchEnabled(){return this.native.touchEnabled}set touchEnabled(e){this.native.touchEnabled=e}}const ct=["enabled","normalFrame","pressedFrame","disabledFrame","normalColor","pressedColor","disabledColor"];class pt extends lt{constructor(e,t,a){e&&t?super(e,t,a):super()}getProps(){const e=super.getProps();return e.concat(ct)}get enabled(){return this.native.enabled}set enabled(e){this.native.enabled=e}get normalFrame(){return this.native.normalSprite}set normalFrame(e){this.native.normalSprite=e}get pressedFrame(){return this.native.pressedSprite}set pressedFrame(e){this.native.pressedSprite=e}get disabledFrame(){return this.native.disabledSprite}set disabledFrame(e){this.native.disabledSprite=e}get normalColor(){return new v(this.native.normalColor)}set normalColor(e){this.native.normalColor=e.native}get pressedColor(){return new v(this.native.pressedColor)}set pressedColor(e){this.native.pressedColor=e.native}get disabledColor(){return new v(this.native.disabledColor)}set disabledColor(e){this.native.disabledColor=e.native}}var ut;(function(e){e[e.TouchDown=1201]="TouchDown",e[e.TouchDownRepeat=1202]="TouchDownRepeat",e[e.DragInside=1204]="DragInside",e[e.DragOutside=1208]="DragOutside",e[e.DragEnter=1216]="DragEnter",e[e.DragExit=1232]="DragExit",e[e.TouchUpInside=1264]="TouchUpInside",e[e.TouchUpOutside=1328]="TouchUpOutside",e[e.TouchCancel=1456]="TouchCancel"})(ut||(ut={}));var mt=effect.Amaz;const gt=[];class ft extends pt{constructor(e,t){e?(super(e,"IFUIButton",t),this.registerCallbacks()):super()}static register(){a.registerComponentType("Button",this.nativeClasses,ft),this.register=()=>void 0}destroy(){this.removeCallbacks(),super.destroy()}static fromNative(e,t){const a=new ft;if(t instanceof mt.IFUIButton)a.initWithNative(e,t,"IFButton2d");else throw new Error("Incorrect argument to ButtonComponent::fromNative");return a.registerCallbacks(),a}getProps(){const e=super.getProps();return e.concat(gt)}registerCallbacks(){this.addListener(ut.TouchDown,this.onClicked,this)}removeCallbacks(){this.removeListener(ut.TouchDown,this.onClicked)}onClicked(e){e.fire("click",e.sceneObject)}}ft.nativeClasses=["IFUIButton"],ft.register();var _t=effect.Amaz;const ht=["mask"];class yt extends a{constructor(e,t){if(!e)super();else if(e.camera)super(e,"IFEventDistributor"),this.initialize(t,this.getProps());else throw new Error("UIEventSystemComponent can only be added to an camera sceneObject")}static register(){a.registerComponentType("UIEventSystem",this.nativeClasses,yt),this.register=()=>void 0}static fromNative(e,t){const a=new yt;if(t instanceof _t.IFEventDistributor)a.initWithNative(e,t,"IFEventDistributor");else throw new Error("Incorrect argument to UIEventSystemComponent::fromNative");return a}getProps(){return ht}get mask(){return this.native.EventMask}set mask(e){this.native.EventMask=e}}yt.nativeClasses=["IFEventDistributor"],yt.register();var vt=effect.Amaz;const Tt=["autoSize","center","size"],Ct=new Map([[exports.UIColliderType.Box,"IFBoxCollider"]]);function xt(e){if(!Ct.has(e))throw new Error("Unknown type of collider");return Ct.get(e)}class St extends a{constructor(e,t){if(!e)super();else if(e.screenTransform&&t&&t.hasOwnProperty("type"))super(e,xt(t.type)),this.initialize(t,this.getProps());else throw new Error("UIColliderComponent can only be added to an 2d sceneObject with the type option specified")}static register(){a.registerComponentType("UICollider",this.nativeClasses,St),this.register=()=>void 0}static fromNative(e,t){const a=new St;if(t instanceof vt.IFBoxCollider)a.initWithNative(e,t,"IFBoxCollider"),a.type=exports.UIColliderType.Box;else throw new Error("Incorrect argument to UIColliderComponent::fromNative");return a}getProps(){return Tt}get autoSize(){return this.native.autoAdjustCollider}set autoSize(e){this.native.autoAdjustCollider=e}get center(){return new $(this.native.center)}set center(e){this.native.center=e.native}get size(){return new $(this.native.size)}set size(e){this.native.size=e.native}}St.nativeClasses=["IFBoxCollider"],St.register();var Mt=effect.Amaz;const Ft=["fillSceneObject","thumbSceneObject","mode","direction","minValue","maxValue","step","value"],Pt=1004;class Rt extends pt{constructor(e,t){e?(super(e,"IFUISlider",t),this.registerCallbacks()):super()}static register(){a.registerComponentType("Slider",this.nativeClasses,Rt),this.register=()=>void 0}destroy(){this.removeCallbacks(),super.destroy()}static fromNative(e,t){const a=new Rt;if(t instanceof Mt.IFUISlider)a.initWithNative(e,t,"IFSlider2d");else throw new Error("Incorrect argument to SliderComponent::fromNative");return a.registerCallbacks(),a}getProps(){const e=super.getProps();return e.concat(Ft)}registerCallbacks(){this.addListener(Pt,this.onValueChanged,this)}removeCallbacks(){this.removeListener(Pt,this.onValueChanged)}onValueChanged(e){e.fire("change",e.sceneObject)}get mode(){return this.native.mode}set mode(e){this.native.mode=e}get direction(){return this.native.direction}set direction(e){this.native.direction=e}get minValue(){return this.native.minValue}set minValue(e){this.native.minValue=e}get maxValue(){return this.native.maxValue}set maxValue(e){this.native.maxValue=e}get step(){return this.native.steps}set step(e){this.native.steps=e}get value(){return this.native.value}set value(e){this.native.value=e}set fillSceneObject(e){if(e.native)this.native.fillTrans=e.native.getComponent("IFTransform2d");else throw new Error("Invalid fillSceneObject!")}set thumbSceneObject(e){if(e.native)this.native.thumbTrans=e.native.getComponent("IFTransform2d");else throw new Error("Invalid thumbSceneObject!")}}Rt.nativeClasses=["IFUISlider"],Rt.register();var At=effect.Amaz;const It=[];class bt extends pt{constructor(e,t){e?(super(e,"IFUISliderThumb",t),this.registerCallbacks()):super()}static register(){a.registerComponentType("SliderThumb",this.nativeClasses,bt),this.register=()=>void 0}destroy(){this.removeCallbacks(),super.destroy()}static fromNative(e,t){const a=new bt;if(t instanceof At.IFUISliderThumb)a.initWithNative(e,t,"IFSliderThumb2d");else throw new Error("Incorrect argument to SliderThumbComponent::fromNative");return a}getProps(){const e=super.getProps();return e.concat(It)}registerCallbacks(){this.addListener(ut.TouchDown,this.onClicked,this)}removeCallbacks(){this.removeListener(ut.TouchDown,this.onClicked)}onClicked(e){e.fire("click",e.sceneObject)}}bt.nativeClasses=["IFUISliderThumb"],bt.register();var Et=effect.Amaz;const zt=["text","textColor","fontPath","fontSize","fontType","alignment","fitType","spacing"];class Bt extends Xe{constructor(e,t){e?super(e,"IFUILabel",t):super()}static register(){a.registerComponentType("Label",this.nativeClasses,Bt),this.register=()=>void 0}static fromNative(e,t){const a=new Bt;if(t instanceof Et.IFUILabel)a.initWithNative(e,t,"IFUILabel");else throw new Error("Incorrect argument to LabelComponent::fromNative");return a}getProps(){const e=super.getProps();return e.concat(zt)}get text(){return this.native.text}set text(e){this.native.text=e}get textColor(){return new v(this.native.textColor)}set textColor(e){this.native.textColor=e.native}get fontPath(){return this.native.fontPath}set fontPath(e){this.native.fontPath=e}get fontSize(){return this.native.fontSize}set fontSize(e){this.native.fontSize=e}get fontType(){return this.native.fontType}set fontType(e){this.native.fontType=e}get alignment(){return this.native.alignment}set alignment(e){this.native.alignment=e}get fitType(){return this.native.fitType}set fitType(e){this.native.fitType=e}get spacing(){return new oe(this.native.spacing)}set spacing(e){this.native.spacing=e.native}}Bt.nativeClasses=["IFUILabel"],Bt.register();var Lt=effect.Amaz;const Ot=["type","size"];class kt extends a{constructor(e,t){if(!e)super();else if(e.screenTransform)super(e,"IFCanvas2d"),this.initialize(t,this.getProps());else throw new Error("Canvas2DComponent can only be added to an 2d sceneObject")}static register(){a.registerComponentType("CanvasScaler",this.nativeClasses,kt),this.register=()=>void 0}static fromNative(e,t){const a=new kt;if(t instanceof Lt.IFCanvas2d)a.initWithNative(e,t,"IFCanvas2d");else throw new Error("Incorrect argument to Canvas2DComponent::fromNative");return a}getProps(){return Ot}get type(){return this.native.resolutionType}set type(e){this.native.resolutionType=e}get size(){return new oe(this.native.resolutionSize)}set size(e){this.native.resolutionSize=e.native}}kt.nativeClasses=["IFCanvas2d"],kt.register();var Nt=effect.Amaz;const Dt=["type","sizeMode","gridMode","verticalDirection","horizontalDirection","sortMode","cellSize","paddingLeft","paddingRight","paddingTop","paddingBottom","horizontalSpace","verticalSpace","useScaledSize","excludeInvisible"];class wt extends a{constructor(e,t){if(!e)super();else if(e.screenTransform)super(e,"IFUIGrid"),this.initialize(t,this.getProps());else throw new Error("LayoutComponent can only be added to an 2d sceneObject")}static register(){a.registerComponentType("Layout",this.nativeClasses,wt),this.register=()=>void 0}static fromNative(e,t){const a=new wt;if(t instanceof Nt.IFUIGrid)a.initWithNative(e,t,"IFUIGrid");else throw new Error("Incorrect argument to LayoutComponent::fromNative");return a}getProps(){return Dt}get type(){return this.native.type}set type(e){this.native.type=e}get sizeMode(){return this.native.resizeMode}set sizeMode(e){this.native.resizeMode=e}get gridMode(){return this.native.startAxis}set gridMode(e){this.native.startAxis=e}get verticalDirection(){return this.native.verticalDirection}set verticalDirection(e){this.native.verticalDirection=e}get horizontalDirection(){return this.native.horizontalDirection}set horizontalDirection(e){this.native.horizontalDirection=e}get sortMode(){return this.native.sortingType}set sortMode(e){this.native.sortingType=e}get cellSize(){return this.native.cellSize}set cellSize(e){this.native.cellSize=e}get paddingLeft(){return this.native.paddingLeft}set paddingLeft(e){this.native.paddingLeft=e}get paddingRight(){return this.native.paddingRight}set paddingRight(e){this.native.paddingRight=e}get paddingTop(){return this.native.paddingTop}set paddingTop(e){this.native.paddingTop=e}get paddingBottom(){return this.native.paddingBottom}set paddingBottom(e){this.native.paddingBottom=e}get horizontalSpace(){return this.native.horizontalSpace}set horizontalSpace(e){this.native.horizontalSpace=e}get verticalSpace(){return this.native.verticalSpace}set verticalSpace(e){this.native.verticalSpace=e}get useScaledSize(){return this.native.affectedByScale}set useScaledSize(e){this.native.affectedByScale=e}get excludeInvisible(){return this.native.filterInvisibleChildren}set excludeInvisible(e){this.native.filterInvisibleChildren=e}}wt.nativeClasses=["IFUIGrid"],wt.register();var Vt=effect.Amaz;const Gt=["target","leftTarget","rightTarget","topTarget","bottomTarget","leftAnchor","rightAnchor","topAnchor","bottomAnchor","leftOffset","rightOffset","topOffset","bottomOffset"];class Ut extends a{constructor(e,t){if(!e)super();else if(e.screenTransform)super(e,"IFUIConstraints"),this.initialize(t,this.getProps());else throw new Error("AlignmentComponent can only be added to an 2d sceneObject")}static register(){a.registerComponentType("Alignment",this.nativeClasses,Ut),this.register=()=>void 0}static fromNative(e,t){const a=new Ut;if(t instanceof Vt.IFUIConstraints)a.initWithNative(e,t,"IFUIConstraints");else throw new Error("Incorrect argument to AlignmentComponent::fromNative");return a}getProps(){return Gt}set target(e){if(e.native)this.native.target=e.native.getComponent("IFTransform2d");else throw new Error("Invalid target")}set leftTarget(e){if(e.native)this.native.leftTarget=e.native.getComponent("IFTransform2d");else throw new Error("Invalid leftTarget!")}set rightTarget(e){if(e.native)this.native.rightTarget=e.native.getComponent("IFTransform2d");else throw new Error("Invalid rightTarget!")}set bottomTarget(e){if(e.native)this.native.bottomTarget=e.native.getComponent("IFTransform2d");else throw new Error("Invalid bottomTarget!")}set topTarget(e){if(e.native)this.native.topTarget=e.native.getComponent("IFTransform2d");else throw new Error("Invalid topTarget!")}get leftAnchor(){return this.native.leftRange}set leftAnchor(e){this.native.leftRange=e}get rightAnchor(){return this.native.rightRange}set rightAnchor(e){this.native.rightRange=e}get topAnchor(){return this.native.topRange}set topAnchor(e){this.native.topRange=e}get bottomAnchor(){return this.native.bottomRange}set bottomAnchor(e){this.native.bottomRange=e}get leftOffset(){return this.native.leftOffset}set leftOffset(e){this.native.leftOffset=e}get rightOffset(){return this.native.rightOffset}set rightOffset(e){this.native.rightOffset=e}get topOffset(){return this.native.topOffset}set topOffset(e){this.native.topOffset=e}get bottomOffset(){return this.native.bottomOffset}set bottomOffset(e){this.native.bottomOffset=e}}Ut.nativeClasses=["IFUIConstraints"],Ut.register();var Ht=effect.Amaz;const jt=["otherSceneObject","linearLowerLimit","linearUpperLimit","angularLowerLimit","angularUpperLimit","positionOffset","otherPositionOffset","rotationOffset","otherRotationOffset","linearCorrection","linearSoftness","angularCorrection","angularSoftness"];class Wt extends a{constructor(e,t){e?(super(e,"GenericJoint3D"),this.initialize(t,this.getProps())):super()}static register(){a.registerComponentType("GenericJoint",this.nativeClasses,Wt),this.register=()=>void 0}static fromNative(e,t){const a=new Wt;if(t instanceof Ht.GenericJoint3D)a.initWithNative(e,t,"GenericJoint3D");else throw new Error("Incorrect argument to GenericJoint3DComponent::fromNative");return a}getProps(){return jt}set otherSceneObject(e){if(e.native)this.native.connectedBody=e.native.getComponent("RigidBody3D");else throw new Error("Invalid target")}set linearLowerLimit(e){this.native.linearLowerLimit=e.native}get linearLowerLimit(){return new $(this.native.linearLowerLimit)}set linearUpperLimit(e){this.native.linearUpperLimit=e.native}get linearUpperLimit(){return new $(this.native.linearUpperLimit)}set angularLowerLimit(e){this.native.angularLowerLimit=e.native}get angularLowerLimit(){return new $(this.native.angularLowerLimit)}set angularUpperLimit(e){this.native.angularUpperLimit=e.native}get angularUpperLimit(){return new $(this.native.angularUpperLimit)}set positionOffset(e){this.native.posAnchorA=e.native}get positionOffset(){return new $(this.native.posAnchorA)}set otherPositionOffset(e){this.native.posAnchorB=e.native}get otherPositionOffset(){return new $(this.native.posAnchorB)}set rotationOffset(e){this.native.rotAnchorA=e.native}get rotationOffset(){return new $(this.native.rotAnchorA)}set otherRotationOffset(e){this.native.rotAnchorB=e.native}get otherRotationOffset(){return new $(this.native.rotAnchorB)}set linearCorrection(e){this.native.erpLinear=e}get linearCorrection(){return this.native.erpLinear}set linearSoftness(e){this.native.cfmLinear=e}get linearSoftness(){return this.native.cfmLinear}set angularCorrection(e){this.native.erpAngular=e}get angularCorrection(){return this.native.erpAngular}set angularSoftness(e){this.native.cfmAngular=e}get angularSoftness(){return this.native.cfmAngular}}Wt.nativeClasses=["GenericJoint3D"],Wt.register();var Yt=effect.Amaz;const Xt=["animations"];class qt extends a{constructor(e,t){e?(super(e,"Animator"),this.initialize(t,this.getProps())):super()}static register(){a.registerComponentType("Animation",this.nativeClasses,qt),this.register=()=>void 0}static fromNative(e,t){const a=new qt;if(t instanceof Yt.Animator)a.initWithNative(e,t,"Animator");else throw new Error("Incorrect argument in AnimationComponent::fromNative");return a}getProps(){return Xt}play(e,t){const a={playMode:t&&t.playMode!==void 0?t.playMode:exports.AnimationPlayMode.Once,speed:t&&t.speed!==void 0?t.speed:1,fadeTime:t&&t.fadeTime!==void 0?t.fadeTime:0,startTime:t&&t.startTime!==void 0?t.startTime:0};this.native.play(e,a.playMode,a.speed,a.fadeTime,a.startTime)}stop(){this.native.stopAllAnimations()}pause(){this.native.pauseAnimator()}resume(){this.native.resumeAnimator()}get animations(){const e=[],t=this.native.animations;for(let a=0;a<t.size();a++)e.push(t.get(a));return e}set animations(e){const t=new Yt.Vector;for(const a of e)t.pushBack(a);this.native.animations=t}}qt.nativeClasses=["Animator"],qt.register();var Kt=effect.Amaz;const Zt=["audio","autoPlay","loop"];class Qt extends a{constructor(e,t){e?(super(e,"Audio"),this.initialize(t,this.getProps())):super()}static register(){a.registerComponentType("Audio",this.nativeClasses,Qt),this.register=()=>void 0}static fromNative(e,t){const a=new Qt;if(t instanceof Kt.Audio)a.initWithNative(e,t,"Audio");else throw new Error("Incorrect argument in AudioComponent::fromNative");return a}getProps(){return Zt}get audio(){return this.native.clip}set audio(e){this.native.clip=e}get autoPlay(){return this.native.playOnAwake}set autoPlay(e){this.native.playOnAwake=e}get loop(){return this.native.loop}set loop(e){this.native.loop=e}play(){this.native.play()}stop(){this.native.stop()}pause(){this.native.pause()}resume(){this.native.resume()}reset(){this.native.reset()}}Qt.nativeClasses=["Audio"],Qt.register();var Jt=effect.Amaz;const $t=["position","rotation","scale","size","pivot","flipX","flipY"];class ea extends a{constructor(e,t){e?(super(e,"IFTransform2d"),this.initialize(t,this.getProps())):super()}static register(){a.registerComponentType("ScreenTransform",this.nativeClasses,ea),this.register=()=>void 0}static fromNative(e,t){const a=new ea;if(t instanceof Jt.IFTransform2d)a.initWithNative(e,t,"IFTransform2d");else throw new Error("Incorrect argument in ScreenTransformComponent::fromNative");return a}getProps(){return $t}get position(){return new oe(this.native.position)}set position(e){this.native.position=e.native}get scale(){return new oe(this.native.scale)}set scale(e){this.native.scale=e.native}get rotation(){return this.native.rotation}set rotation(e){this.native.rotation=e}get size(){return new oe(this.native.size)}set size(e){this.native.size=e.native}get pivot(){return new oe(this.native.pivot)}set pivot(e){this.native.pivot=e.native}get flipX(){return this.native.flipX}set flipX(e){this.native.flipX=e}get flipY(){return this.native.flipY}set flipY(e){this.native.flipY=e}}ea.nativeClasses=["IFTransform2d"],ea.register();var ta=effect.Amaz,aa;const na=null==(aa=h.get(exports.Feature.ObjectReferenceInScript))?"":aa,ra=d.doesSDKSupport(na);class ia extends a{constructor(){super(),this.serialzedProperties=[],this._hasInitialized=!1}static register(){a.registerComponentType("Script",this.nativeClasses,ia),this.register=()=>void 0}static create(e,t){const a=e.native.addJsScriptComponent(null==t?void 0:t.scriptPath),n=a.getScript();if(n){const t=n.ref;if(t)return t.initWithNative(e,a,"JSScriptComponent"),t;throw new Error("ScriptComponent: Invalid script instance.")}else throw new Error("ScriptComponent: Invalid script object.")}onInit(){const e=this.entity.getComponents("JSScriptComponent");for(let t=0;t<e.size();t++){const a=e.get(t);if(null!==a&&void 0!==a&&null!==a.getScript()&&void 0!==a.getScript()&&a.getScript().handle===this.script.handle){this.native=a;break}}if(void 0===this.native)throw new Error("ScriptComponent: Initialization failed, native script not found.");for(const e of this.serialzedProperties)this.convertAmazToAmg(e);if(this.serialzedProperties=[],this.sceneObject=Li.scene.sceneObjectFromNative(this.native.entity),this.sceneObject)this.entity=this.sceneObject,this.sceneObject.registerComponent(this),this.scene=Li.scene,this.getComponent=this._getComponent,this._hasInitialized=!0;else throw new Error("ScriptComponent: Initialization failed, cannot find owner SceneObject.")}_getComponent(e){var t;return null==(t=this.sceneObject)?void 0:t.getComponent(e)}onPropertyChanged(e){this._hasInitialized?this.convertAmazToAmg(e):this.serialzedProperties.push(e)}convertAmazToAmg(e){const t=this[e];let a=!1;if(t instanceof ta.Entity)ra?this[e]=Li.scene.sceneObjectFromNative(t):a=!0;else if(t instanceof ta.Component)if(ra){const a=Li.scene.sceneObjectFromNative(t.entity);a&&(this[e]=a.getComponentFromNative(t))}else a=!0;a&&console.warn(`[Amazing JS]: current SDK version[${ta.VERSION}] is lower
        than the minimum required version[${na}]
        for object reference module.`)}hasIntialized(){return this._hasInitialized}}ia.nativeClasses=["JSScriptComponent"],ia.register();var oa=effect.Amaz;const sa=["type","layer"];class da extends a{constructor(e,t){e?(super(e,"Raycaster"),this.initialize(t,this.getProps())):super()}static register(){a.registerComponentType("ScreenRaycaster",this.nativeClasses,da),this.register=()=>void 0}static fromNative(e,t){const a=new da;if(t instanceof oa.Raycaster)a.initWithNative(e,t,"Raycaster");else throw new Error("Incorrect argument in ScreenRaycasterComponent::fromNative");return a}getProps(){return sa}get type(){return this.native.raycasterType}set type(e){this.native.raycasterType=e}get layers(){const e=[];for(let t=0;t<D;++t)this.native.layer.test(t)&&e.push(t);return e}set layers(e){const t=new oa.DynamicBitset(D,0);for(const a of e)if(0<=a&&a<D)t.set(a);else throw new Error("Invalid layer value!");this.native.layer=t}raycastOBB(e){var t;if(null!=(t=this.sceneObject)&&t.camera){const t=[],n=this.native.raycast3D(e.native);for(let e=0;e<n.size();e++){var a;const r=null==(a=this.sceneObject.scene)?void 0:a.sceneObjectFromNative(n.get(e).sceneObject);r&&t.push(r)}return t}throw new Error("No CameraComponent attached on the sceneObject!")}raycastUI(e){var t;if(null!=(t=this.sceneObject)&&t.camera){const t=[],n=this.native.raycastIF(e.native);for(let e=0;e<n.size();e++){var a;const r=null==(a=this.sceneObject.scene)?void 0:a.sceneObjectFromNative(n.get(e).sceneObject);r&&t.push(r)}return t}throw new Error("No CameraComponent attached on the sceneObject!")}raycastGeometricPlane(e,t){var a;if(null!=(a=this.sceneObject)&&a.camera){const a=new $(t.x,t.y,t.z),n=t.w,r=new $(this.native.viewPointHitPlane(e.native,a.native,n));let i=!0;return 9999<r.x&&9999<r.y&&9999<r.z&&(i=!1),{hit:i,hitpos:r}}throw new Error("No CameraComponent attached on the sceneObject!")}}da.nativeClasses=["Raycaster"],da.register();var la=effect.Amaz;class ca extends e{constructor(e,t){if(super(),this._components=new Map,e&&e instanceof ua&&t&&t instanceof la.Entity)this.scene=e,this.native=t,this._transform=this.native.getComponent("Transform"),this.scene.addSceneObjectToCache(this);else{var a;if(this.scene=null!=t&&t.scene?null==t?void 0:t.scene:Li.scene,!this.scene)throw new Error("No active scene found!");const n=e&&"string"==typeof e?e:"Untitled";this.native=this.scene.native.createEntity(n),t&&!(t instanceof la.Entity)&&(this.layer=t.layer?t.layer:0,this.tags=t.tags?t.tags:[]),this._transform=this.native.addComponent("Transform"),null==(a=this.scene)?void 0:a.addSceneObjectToCache(this)}}static fromNative(e,t){if(t instanceof la.Entity)return new ca(e,t);throw new Error("Incorrect argument to SceneObject::fromNative")}get name(){return this.native.name}set name(e){this.native.name=e}get parent(){var e;let t;return this._transform&&this._transform.parent&&(t=this._transform.parent.entity),null==(e=this.scene)?void 0:e.sceneObjectFromNative(t)}get enabled(){return this.native.selfvisible}set enabled(e){this.native.visible=e}get enabledInScene(){return this.native.visible}get layer(){return this.native.layer}set layer(e){if(0<=e&&e<D)this.native.layer=e;else throw new Error("Invalid layer value!")}get tags(){const e=[],t=this.native.tag;for(let a=0;a<w;++a)t&1<<a&&e.push(a);return e}set tags(e){let t=0;for(const a of e)if(0<=a&&a<w)t|=1<<a;else throw new Error(`Invalid tag value: ${a}`);this.native.tag=t}get screenTransform(){return this.getComponent("ScreenTransform")}get camera(){return this.getComponent("Camera")}get model(){return this.getComponent("Model")}get light(){return this.getComponent("Light")}get rigidBody(){return this.getComponent("RigidBody")}get trigger(){return this.getComponent("Trigger")}get collider(){return this.getComponent("Collider")}get particleSystem(){return this.getComponent("ParticleSystem")}get sprite(){return this.getComponent("Sprite")}get image(){return this.getComponent("Image")}get canvas(){return this.getComponent("Canvas")}get canvasScaler(){return this.getComponent("CanvasScaler")}get button(){return this.getComponent("Button")}get uiEventSystem(){return this.getComponent("UIEventSystem")}get uiCollider(){return this.getComponent("UICollider")}get slider(){return this.getComponent("Slider")}get sliderThumb(){return this.getComponent("SliderThumb")}get label(){return this.getComponent("Label")}get seqAnimation(){return this.getComponent("SeqAnimation")}get layout(){return this.getComponent("Layout")}get alignment(){return this.getComponent("Alignment")}get genericJoint(){return this.getComponent("GenericJoint")}get animation(){return this.getComponent("Animation")}get audio(){return this.getComponent("Audio")}get script(){return this.getComponent("Script")}get screenRaycaster(){return this.getComponent("ScreenRaycaster")}addComponent(e,t){const a=this._addComponent(e,t);return this.registerComponent(a)}registerComponent(e){if(e){const t=e.native.handle;if(!this._components.has(t))return this._components.set(t,e),e;else{const a=this._components.get(t);return a!==e&&(e.sceneObject=void 0,e.native=void 0,e.destroy()),a}}}_addComponent(e,t){switch(e){case"ScreenTransform":if(!this.getComponent(e)){this.native.removeComponent("Transform");const e=new ea(this,t);return this._transform=e.native,e}throw new Error(`SceneObject already has ScreenTransform component`);case"Camera":return new U(this,t);case"Model":return new ke(this,t);case"Light":return new pe(this,t);case"RigidBody":return new We(this,t);case"Trigger":return new st(this,t);case"Collider":return new re(this,t);case"ParticleSystem":return new we(this,t);case"Sprite":return new at(this,t);case"Image":return new Ze(this,t);case"Canvas":return new $e(this,t);case"CanvasScaler":return new kt(this,t);case"Button":return new ft(this,t);case"UIEventSystem":return new yt(this,t);case"UICollider":return new St(this,t);case"Slider":return new Rt(this,t);case"SliderThumb":return new bt(this,t);case"Label":return new Bt(this,t);case"SeqAnimation":return new it(this,t);case"Layout":return new wt(this,t);case"Alignment":return new Ut(this,t);case"GenericJoint":return new Wt(this,t);case"Animation":return new qt(this,t);case"Audio":return new Qt(this,t);case"Script":return ia.create(this,t);case"ScreenRaycaster":return new da(this,t);default:throw new Error(`Doesn't support component type: ${e}`);}}removeComponent(e){const t=this.getComponent(e);return!!t&&(this._components.delete(t.native.handle),t.destroy(),"ScreenTransform"===e&&(this._transform=this.native.addComponent("Transform")),!0)}addChild(e){this._transform&&this._transform.addTransform(e.native.getComponent("Transform"))}removeChild(e){this._transform&&this._transform.removeTransform(e.native.getComponent("Transform"))}findByName(e){let t;if(this.name===e)t=this;else for(const a of this.children)if(t=a.findByName(e),t)break;return t}findByTag(e){let t;if(this.hasTag(e))t=this;else for(const a of this.children)if(t=a.findByTag(e),t)break;return t}findAllByName(e){const t=[];this.name===e&&t.push(this);for(const a of this.children)t.push(...a.findAllByName(e));return t}findAllByTag(e){const t=[];this.hasTag(e)&&t.push(this);for(const a of this.children)t.push(...a.findAllByTag(e));return t}get position(){return new $(this._transform.localPosition)}set position(e){this._transform.localPosition=e.native}get scale(){return new $(this._transform.localScale)}set scale(e){this._transform.localScale=e.native}get rotation(){return new $(this._transform.localEulerAngle)}set rotation(e){this._transform.localEulerAngle=e.native}get rotationQuat(){return new ve(this._transform.localOrientation)}set rotationQuat(e){this._transform.localOrientation=e.native}get worldPosition(){return new $(this._transform.worldPosition)}set worldPosition(e){this._transform.worldPosition=e.native}get worldScale(){return new $(this._transform.worldScale)}set worldScale(e){this._transform.worldScale=e.native}get worldRotation(){return new ve(this._transform.worldOrientation)}set worldRotation(e){this._transform.worldOrientation=e.native}get worldEulerAngles(){return new $(this._transform.worldEulerAngle)}set worldEulerAngles(e){this._transform.worldEulerAngle=e.native}addTag(e){if(0<=e&&e<w)this.native.addTag(e);else throw new Error(`Invalid tag:[${e}] number when adding tag. (valid tag: 0-31)`)}hasTag(e){return this.native.hasTag(e)}destroy(){var e,t;for(const e of this._components.values())e.destroy();this._components.clear(),null==(e=this.scene)?void 0:e.removeSceneObjectToCache(this),null==(t=this.scene)?void 0:t.native.removeEntity(this.native),this.native=void 0,this.scene=void 0,this._transform=void 0}get children(){const e=[];for(let a=0;a<this._transform.children.size();++a){var t;const n=this._transform.children.get(a),r=null==(t=this.scene)?void 0:t.sceneObjectFromNative(n.entity);if(r)e.push(r);else throw new Error("SceneObject has invalid child!")}return e}getComponentFromNative(e){let t;if(this._components.has(e.handle))return this._components.get(e.handle);else{const n=a.getComponentFronNative(e);n&&(t=n.fromNative(this,e))}return t}getComponent(e){let t;const n=a.getComponentFromType(e);if(n)for(const e of n.nativeClasses){const a=this.native.getComponent(e);if(a){if(!!this._components.has(a.handle))t=this._components.get(a.handle);else if(n.fromNative)t=n.fromNative(this,a),this._components.set(a.handle,t);else throw new Error("SceneObject::Cannot get component "+n.nativeClasses);break}}else{const a=this.native.getComponents(ia.nativeClasses[0]);for(let n=0;n<a.size();++n){const r=a.get(n),i=r.getScript();if(null===i||void 0===i)continue;const o=i.className;if(o===e){if(!this._components.has(r.handle))throw new Error(`Invalid script:[${o}]: Unregistered user script.`);else t=this._components.get(r.handle);break}}}return t}getComponents(e){const t=[],n=a.getComponentFromType(e);if(n)for(const e of n.nativeClasses){const a=this.native.getComponents(e);for(let e=0;e<a.size();++e){const r=a.get(e);let i;this._components.has(r.handle)?i=this._components.get(r.handle):(i=n.fromNative(this,r),this._components.set(r.handle,i)),t.push(i)}}return t}hasComponent(e){let t=!1;const n=a.getComponentFromType(e);if(n)for(const e of n.nativeClasses)if(t=!!this.native.getComponent(e),t)break;return t}findByComponent(e){let t;if(this.hasComponent(e))t=this;else for(const a of this.children)if(t=a.findByComponent(e),t)break;return t}findAllByComponent(e){const t=[];this.hasComponent(e)&&t.push(this);for(const a of this.children)t.push(...a.findAllByComponent(e));return t}}var pa=effect.Amaz;class ua{constructor(e){if(this.sceneObjects=new Map,this._physicsSystem=void 0,e&&e instanceof pa.Scene){this.native=e;const t=this.native.entities,a=t.empty()?void 0:this.findRoot(t);this.root=a?this.sceneObjectFromNative(a):new ca("Root",{scene:this})}else this.native=new pa.Scene,this.name="string"==typeof e?e:"Untitled",this.root=new ca("Root",{scene:this})}findRoot(e){let t=e.front().getComponent("Transform");for(;t.parent;)t=t.parent;return t.entity}get children(){const e=[];for(let t=0;t<this.native.entities.size();++t){const a=this.native.entities.get(t),n=a.getComponent("Transform");if(!n)throw new Error("Scene has invalid child sceneObject!");else if(!n.parent){const t=this.sceneObjectFromNative(a);if(t)e.push(t);else throw new Error("Scene has invalid child sceneObject!")}}return e}get name(){return this.native.name}set name(e){this.native.name=e}get visible(){return this.native.visible}set visible(e){this.native.visible=e}addSystem(e){this.native.addSystem(e)}addSceneObjectToCache(e){e.native.handle&&this.sceneObjects.set(e.native.handle,e)}removeSceneObjectToCache(e){e.native.handle&&this.sceneObjects.delete(e.native.handle)}sceneObjectFromNative(e){return e?e.handle&&this.sceneObjects.has(e.handle)?this.sceneObjects.get(e.handle):ca.fromNative(this,e):void 0}destroy(){this.sceneObjects.clear(),this.native.visible=!1}rayCast(e,t){const a=[],n=this.physicsSystem.rayTest(e.native,t.native);for(let r=0;r<n.size();++r){const e=n.get(r),t=this.sceneObjectFromNative(e.entity);t&&a.push(t)}return a}findByName(e){let t;for(let a=0;a<this.native.entities.size();++a){const n=this.sceneObjectFromNative(this.native.entities.get(a));if(n&&n.name===e){t=n;break}}return t}findByTag(e){let t;for(let a=0;a<this.native.entities.size();++a){const n=this.sceneObjectFromNative(this.native.entities.get(a));if(n&&n.hasTag(e)){t=n;break}}return t}findByComponent(e){let t;for(let a=0;a<this.native.entities.size();++a){const n=this.sceneObjectFromNative(this.native.entities.get(a));if(n&&n.hasComponent(e)){t=n;break}}return t}findAllByName(e){const t=[];for(let a=0;a<this.native.entities.size();++a){const n=this.sceneObjectFromNative(this.native.entities.get(a));n&&n.name===e&&t.push(n)}return t}findAllByTag(e){const t=[];for(let a=0;a<this.native.entities.size();++a){const n=this.sceneObjectFromNative(this.native.entities.get(a));n&&n.hasTag(e)&&t.push(n)}return t}findAllByComponent(e){const t=[];for(let a=0;a<this.native.entities.size();++a){const n=this.sceneObjectFromNative(this.native.entities.get(a));n&&n.hasComponent(e)&&t.push(n)}return t}get physicsSystem(){return void 0===this._physicsSystem&&(this._physicsSystem=this.native.getSystem("Physics3DSystem")),this._physicsSystem}}var ma=effect.Amaz,ga;(function(e){e[e.TouchStart=0]="TouchStart",e[e.TouchMove=1]="TouchMove",e[e.TouchStationary=2]="TouchStationary",e[e.TouchEnd=3]="TouchEnd",e[e.TouchCancel=4]="TouchCancel"})(ga||(ga={}));class fa{constructor(e,t,a,n,r,i,o,s){this.identifier=-1,this.type=ga.TouchStart,this.x=0,this.y=0,this.force=0,this.size=0,this.time=0,this.count=0,this.valid=!1,e!==void 0&&(this.identifier=e,this.valid=!0),t!==void 0&&(this.type=t),a!==void 0&&(this.x=a),n!==void 0&&(this.y=n),r!==void 0&&(this.force=r),i!==void 0&&(this.size=i),o!==void 0&&(this.time=o),s!==void 0&&(this.count=s)}static fromNative(e){const t=new fa(e.pointerId,fa.convertTouchType(e.type),e.x,e.y,e.force,e.size,e.time,e.count);return t}static convertTouchType(e){return e===ma.TouchType.TOUCH_BEGAN?ga.TouchStart:e===ma.TouchType.TOUCH_MOVED?ga.TouchMove:e===ma.TouchType.TOUCH_STATIONARY?ga.TouchStationary:e===ma.TouchType.TOUCH_ENDED?ga.TouchEnd:e===ma.TouchType.TOUCH_CANCELED?ga.TouchCancel:ga.TouchEnd}}class _a extends e{constructor(e,t){super(),this._width=e,this._height=t}start(){}destroy(){}onEvent(e){if(e.type===ma.EventType.TOUCH){const t=e.args.get(0),a=this.convertTouchEvent(t);switch(a.type){case ga.TouchStart:this.fire("touchstart",a);break;case ga.TouchMove:this.fire("touchmove",a);break;case ga.TouchEnd:this.fire("touchend",a);break;case ga.TouchCancel:this.fire("touchcancel",a);}}}convertTouchEvent(e){var t=Math.round;const a=t(e.x*this._width),n=this._height-t(e.y*this._height),r=fa.fromNative(e);return r.x=a,r.y=n,r}}var ha=effect.Amaz;class ya{constructor(e){const t=e.properties;this._flip=t.flip,this._inputTexture=t.inputTexture,this._renderTexture=Li.customAssets.getNativeObject(e.uuid),this._renderTexture.depth=1,this._renderTexture.filterMag=ha.FilterMode.LINEAR,this._renderTexture.filterMin=ha.FilterMode.LINEAR,this._renderTexture.filterMipmap=ha.FilterMipmapMode.NONE,this._renderTexture.attachment=ha.RenderTextureAttachment.NONE,this._renderTexture.width=ha.AmazingManager.getSingleton("BuiltinObject").getInputTextureWidth(),this._renderTexture.height=ha.AmazingManager.getSingleton("BuiltinObject").getInputTextureHeight();const a=o.createShaders({gles2:{vs:"\n    precision highp float;\n\n    attribute vec3 inPosition;\n    attribute vec2 inTexCoord;\n\n    varying vec2 v_TexCoord;\n\n    uniform mat4 u_Model;\n    uniform float u_FlipVertical;\n\n    void main() {\n      vec2 flipCoord = vec2(inTexCoord.x, 1. - inTexCoord.y);\n      v_TexCoord = mix(inTexCoord, flipCoord, u_FlipVertical);\n      gl_Position = u_Model * vec4(inPosition, 1.0);\n    }\n    ",fs:`
    precision highp float;

    varying vec2 v_TexCoord;

    uniform sampler2D u_CameraTex;

    void main() {
      gl_FragColor = texture2D(u_CameraTex, v_TexCoord);
    }
    `},metal:{vs:`
    #include <metal_stdlib>
    #include <simd/simd.h>
    
    using namespace metal;
    
    struct buffer_t
    {
        float u_FlipVertical;
        float4x4 u_Model;
    };
    
    struct main0_out
    {
        float2 v_TexCoord;
        float4 gl_Position [[position]];
    };
    
    struct main0_in
    {
        float3 inPosition [[attribute(0)]];
        float2 inTexCoord [[attribute(1)]];
    };
    
    vertex main0_out main0(main0_in in [[stage_in]], constant buffer_t& buffer)
    {
        main0_out out = {};
        float2 flipCoord = float2(in.inTexCoord.x, 1.0 - in.inTexCoord.y);
        out.v_TexCoord = mix(in.inTexCoord, flipCoord, float2(buffer.u_FlipVertical));
        out.gl_Position = buffer.u_Model * float4(in.inPosition, 1.0);
        out.gl_Position.z = (out.gl_Position.z + out.gl_Position.w) * 0.5;       // Adjust clip-space for Metal
        return out;
    }
    `,fs:`
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct main0_out
    {
        float4 gl_FragColor [[color(0)]];
    };

    struct main0_in
    {
        float2 v_TexCoord;
    };

    fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> u_CameraTex [[texture(0)]], sampler u_CameraTexSmplr [[sampler(0)]])
    {
        main0_out out = {};
        out.gl_FragColor = u_CameraTex.sample(u_CameraTexSmplr, in.v_TexCoord);
        return out;
    }
    `}});this._screenMaterial=o.createScreenMaterial(a);const n=Li.assets.loadSync(this._inputTexture);this._screenMaterial.setTex("u_CameraTex",null==n?void 0:n.resource);const r=!0===this._flip?1:0;this._screenMaterial.setFloat("u_FlipVertical",r)}onStart(){}onUpdate(){const e=Li.customAssets.cmdBufferHelper;e.cmdBufferSetRenderTexture(this._renderTexture),e.cmdBufferDrawMesh(e.screenMesh,new xe,this._screenMaterial,0,0,new ha.MaterialPropertyBlock)}onLateUpdate(){}onDestroy(){}}class va{constructor(e){this._mgr=e,this._allTrackedIDs=new Map,this._allIDs=new Map}facePartHelper(e,t,a,n){for(let r=e;r<t;r++)n.pushBack(a.get(r));return n}update(){this._allIDs.clear(),this.onUpdate(this._allIDs);for(const[e,t]of this._allTrackedIDs.entries()){const a=this._allIDs.get(e);if(null!=a)for(const n of t.values())a.has(n)||this._mgr.setFaceState(!1,n,e);else console.error(`Can't find lastFaceIdSet with faceType ${exports.FaceType[e]}`)}this._allTrackedIDs.clear(),this._allIDs.forEach((e,t)=>this._allTrackedIDs.set(t,e))}}var Ta=effect.Amaz,Ca;(function(e){e[e.Human=0]="Human",e[e.Pet=1]="Pet"})(Ca||(Ca={}));const xa=new Map([[exports.FaceType.Unknown,Ca.Human],[exports.FaceType.Human,Ca.Human],[exports.FaceType.Dog,Ca.Pet],[exports.FaceType.Cat,Ca.Pet]]);class Sa{constructor(){this.vertexes=new Ta.Vec3Vector,this.landmarks=new Ta.Vec3Vector,this.normals=new Ta.Vec3Vector,this.tangents=new Ta.Vec3Vector,this.mvp=new xe,this.modelMatrix=new xe,this.scale=0}}var Ma=effect.Amaz;class Fa{constructor(){this.type=exports.FaceType.Unknown,this.score=0,this.id=0,this.yaw=0,this.pitch=0,this.roll=0,this.transform=new xe,this.rect=new C,this.expression=exports.FaceExpression.Unknown,this.isValidFace=!1,this.action=exports.FaceAction.None,this.faceMesh=new Sa,this.contour=new Ma.Vec2Vector,this.landmarks106=new Ma.Vec2Vector,this.landmarks240EyeLeft=new Ma.Vec2Vector,this.landmarks240EyeRight=new Ma.Vec2Vector,this.landmarks240EyebrowLeft=new Ma.Vec2Vector,this.landmarks240EyebrowRight=new Ma.Vec2Vector,this.landmarks240Lip=new Ma.Vec2Vector,this.landmarks280LeftIris=new Ma.Vec2Vector,this.landmarks280RightIris=new Ma.Vec2Vector,this.landmarks3d=new Ma.Vec3Vector,this.landmarksPetV2=new Ma.Vec2Vector}isValid(){return this.isValidFace}hasAction(){return this.action!==exports.FaceAction.None}getPartLandmark(e,t,a){let n=new Ma.Vec2Vector;const r=a.get(e);if(r)for(let e=0;e<r.length;e++)n=this.facePartHelper(r[e][0],r[e][1],t,n);else return console.error(`${this.type} doesn't support ${e} yet`),null;return n}facePartHelper(e,t,a,n){for(let r=e;r<t;r++)n.pushBack(a.get(r));return n}}const Pa=new Map([[exports.FacePart.LeftEye,[[52,58],[72,74],[104,105]]],[exports.FacePart.RightEye,[[58,64],[75,78],[105,106]]],[exports.FacePart.Nose,[[43,52],[80,84]]],[exports.FacePart.Mouth,[[84,104]]],[exports.FacePart.LeftEyeBrow,[[33,38],[64,68]]],[exports.FacePart.RightEyeBrow,[[38,43],[68,72]]]]),Ra=new Map([[exports.FacePart.LeftEye,[[64,72],[80,81]]],[exports.FacePart.RightEye,[[72,80],[81,82]]],[exports.FacePart.Nose,[[40,48]]],[exports.FacePart.Mouth,[[48,64]]],[exports.FacePart.LeftEar,[[0,1],[23,33]]],[exports.FacePart.RightEar,[[16,20],[33,40]]],[exports.FacePart.Contour,[[0,26]]]]),Aa=new Map([[exports.FacePart.LeftEye,[[58,66],[74,75]]],[exports.FacePart.RightEye,[[66,74],[75,76]]],[exports.FacePart.Nose,[[26,42]]],[exports.FacePart.Mouth,[[42,58]]],[exports.FacePart.LeftEar,[[0,1],[23,26],[76,83]]],[exports.FacePart.RightEar,[[16,20],[83,90]]],[exports.FacePart.Contour,[[0,26]]]]);class Ia extends Fa{constructor(){super()}getLandmarks(e,t){return t===exports.FaceLandmarkType.Face106?this.get106landmark(e):t===exports.FaceLandmarkType.Face240?this.get240landmark(e):t===exports.FaceLandmarkType.Face280?this.get280landmark(e):(console.log("getLandmarks null"),null)}get106landmark(e){return e==exports.FacePart.Whole?this.landmarks106:e==exports.FacePart.Contour?this.contour:this.getPartLandmark(e,this.landmarks106,Pa)}get240landmark(e){switch(e){case exports.FacePart.Whole:let t=this.facePartHelper(0,this.landmarks240EyeLeft.size(),this.landmarks240EyeLeft,this.landmarks106);return t=this.facePartHelper(0,this.landmarks240EyeRight.size(),this.landmarks240EyeRight,t),t=this.facePartHelper(0,this.landmarks240EyebrowLeft.size(),this.landmarks240EyebrowLeft,t),t=this.facePartHelper(0,this.landmarks240EyebrowRight.size(),this.landmarks240EyebrowRight,t),t=this.facePartHelper(0,this.landmarks240Lip.size(),this.landmarks240Lip,t),t;case exports.FacePart.LeftEye:const a=this.getLandmarks(exports.FacePart.LeftEye,exports.FaceLandmarkType.Face106),n=this.facePartHelper(0,this.landmarks240EyeLeft.size(),this.landmarks240EyeLeft,a);return n;case exports.FacePart.RightEye:const r=this.getLandmarks(exports.FacePart.RightEye,exports.FaceLandmarkType.Face106),i=this.facePartHelper(0,this.landmarks240EyeRight.size(),this.landmarks240EyeRight,r);return i;case exports.FacePart.Nose:const o=this.getLandmarks(exports.FacePart.Nose,exports.FaceLandmarkType.Face106);return o;case exports.FacePart.Mouth:const s=this.getLandmarks(exports.FacePart.Mouth,exports.FaceLandmarkType.Face106),d=this.facePartHelper(0,this.landmarks240Lip.size(),this.landmarks240Lip,s);return d;case exports.FacePart.LeftEyeBrow:const l=this.getLandmarks(exports.FacePart.LeftEyeBrow,exports.FaceLandmarkType.Face106),c=this.facePartHelper(0,this.landmarks240EyebrowLeft.size(),this.landmarks240EyebrowLeft,l);return c;case exports.FacePart.RightEyeBrow:const p=this.getLandmarks(exports.FacePart.RightEyeBrow,exports.FaceLandmarkType.Face106),u=this.facePartHelper(0,this.landmarks240EyebrowRight.size(),this.landmarks240EyebrowRight,p);return u;case exports.FacePart.Contour:const m=this.getLandmarks(exports.FacePart.Contour,exports.FaceLandmarkType.Face106);return m;default:return console.error(`Head 240 doesn't support ${e} yet`),null;}}get280landmark(e){switch(e){case exports.FacePart.Whole:const t=this.getLandmarks(exports.FacePart.Whole,exports.FaceLandmarkType.Face240);let a=this.facePartHelper(0,this.landmarks280LeftIris.size(),this.landmarks280LeftIris,t);return a=this.facePartHelper(0,this.landmarks280RightIris.size(),this.landmarks280RightIris,a),a;case exports.FacePart.LeftEye:const n=this.getLandmarks(exports.FacePart.LeftEye,exports.FaceLandmarkType.Face240),r=this.facePartHelper(0,this.landmarks280LeftIris.size(),this.landmarks280LeftIris,n);return r;case exports.FacePart.RightEye:const i=this.getLandmarks(exports.FacePart.RightEye,exports.FaceLandmarkType.Face240),o=this.facePartHelper(0,this.landmarks280RightIris.size(),this.landmarks280RightIris,i);return o;case exports.FacePart.Nose:const s=this.getLandmarks(exports.FacePart.Nose,exports.FaceLandmarkType.Face240);return s;case exports.FacePart.Mouth:const d=this.getLandmarks(exports.FacePart.Mouth,exports.FaceLandmarkType.Face240);return d;case exports.FacePart.LeftEyeBrow:const l=this.getLandmarks(exports.FacePart.LeftEyeBrow,exports.FaceLandmarkType.Face240);return l;case exports.FacePart.RightEyeBrow:const c=this.getLandmarks(exports.FacePart.RightEyeBrow,exports.FaceLandmarkType.Face240);return c;case exports.FacePart.Contour:const p=this.getLandmarks(exports.FacePart.Contour,exports.FaceLandmarkType.Face240);return p;default:return console.error(`Head 280 doesn't support ${e} yet`),null;}}}var ba=effect.Amaz;class Ea extends va{constructor(e){super(e),this._allTrackedIDs.set(exports.FaceType.Human,new Set)}getLandmark(e,t,a){return a===exports.FaceLandmarkType.Face106?this.get106landmark(e,t):a===exports.FaceLandmarkType.Face240?this.get240landmark(e,t):a===exports.FaceLandmarkType.Face280?this.get280landmark(e,t):a===exports.FaceLandmarkType.Face3d?this.get3dlandmark(e,t):(console.error(`Head doesn't support ${a} yet`),null)}get106landmark(e,t){switch(e){case exports.FacePart.Whole:return this._mgr.faces[t].landmarks106;case exports.FacePart.LeftEye:let a=new ba.Vec2Vector;return a=this.facePartHelper(52,58,this._mgr.faces[t].landmarks106,a),a=this.facePartHelper(72,74,this._mgr.faces[t].landmarks106,a),a=this.facePartHelper(104,105,this._mgr.faces[t].landmarks106,a),a;case exports.FacePart.RightEye:let n=new ba.Vec2Vector;return n=this.facePartHelper(58,64,this._mgr.faces[t].landmarks106,n),n=this.facePartHelper(75,78,this._mgr.faces[t].landmarks106,n),n=this.facePartHelper(105,106,this._mgr.faces[t].landmarks106,n),n;case exports.FacePart.Nose:let r=new ba.Vec2Vector;return r=this.facePartHelper(43,52,this._mgr.faces[t].landmarks106,r),r=this.facePartHelper(80,84,this._mgr.faces[t].landmarks106,r),r;case exports.FacePart.Mouth:let i=new ba.Vec2Vector;return i=this.facePartHelper(84,104,this._mgr.faces[t].landmarks106,i),i;case exports.FacePart.LeftEyeBrow:let o=new ba.Vec2Vector;return o=this.facePartHelper(33,38,this._mgr.faces[t].landmarks106,o),o=this.facePartHelper(64,68,this._mgr.faces[t].landmarks106,o),o;case exports.FacePart.RightEyeBrow:let s=new ba.Vec2Vector;return s=this.facePartHelper(38,43,this._mgr.faces[t].landmarks106,s),s=this.facePartHelper(68,72,this._mgr.faces[t].landmarks106,s),s;case exports.FacePart.Contour:return this._mgr.faces[t].contour;default:return console.error(`Head 106 doesn't support ${e} yet`),null;}}get240landmark(e,t){switch(e){case exports.FacePart.Whole:let a=this.facePartHelper(0,this._mgr.faces[t].landmarks240EyeLeft.size(),this._mgr.faces[t].landmarks240EyeLeft,this._mgr.faces[t].landmarks106);return a=this.facePartHelper(0,this._mgr.faces[t].landmarks240EyeRight.size(),this._mgr.faces[t].landmarks240EyeRight,a),a=this.facePartHelper(0,this._mgr.faces[t].landmarks240EyebrowLeft.size(),this._mgr.faces[t].landmarks240EyebrowLeft,a),a=this.facePartHelper(0,this._mgr.faces[t].landmarks240EyebrowRight.size(),this._mgr.faces[t].landmarks240EyebrowRight,a),a=this.facePartHelper(0,this._mgr.faces[t].landmarks240Lip.size(),this._mgr.faces[t].landmarks240Lip,a),a;case exports.FacePart.LeftEye:const n=this._mgr.getLandmarks(exports.FacePart.LeftEye,t,exports.FaceLandmarkType.Face106),r=this.facePartHelper(0,this._mgr.faces[t].landmarks240EyeLeft.size(),this._mgr.faces[t].landmarks240EyeLeft,n);return r;case exports.FacePart.RightEye:const i=this._mgr.getLandmarks(exports.FacePart.RightEye,t,exports.FaceLandmarkType.Face106),o=this.facePartHelper(0,this._mgr.faces[t].landmarks240EyeRight.size(),this._mgr.faces[t].landmarks240EyeRight,i);return o;case exports.FacePart.Nose:const s=this._mgr.getLandmarks(exports.FacePart.Nose,t,exports.FaceLandmarkType.Face106);return s;case exports.FacePart.Mouth:const d=this._mgr.getLandmarks(exports.FacePart.Mouth,t,exports.FaceLandmarkType.Face106),l=this.facePartHelper(0,this._mgr.faces[t].landmarks240Lip.size(),this._mgr.faces[t].landmarks240Lip,d);return l;case exports.FacePart.LeftEyeBrow:const c=this._mgr.getLandmarks(exports.FacePart.LeftEyeBrow,t,exports.FaceLandmarkType.Face106),p=this.facePartHelper(0,this._mgr.faces[t].landmarks240EyebrowLeft.size(),this._mgr.faces[t].landmarks240EyebrowLeft,c);return p;case exports.FacePart.RightEyeBrow:const u=this._mgr.getLandmarks(exports.FacePart.RightEyeBrow,t,exports.FaceLandmarkType.Face106),m=this.facePartHelper(0,this._mgr.faces[t].landmarks240EyebrowRight.size(),this._mgr.faces[t].landmarks240EyebrowRight,u);return m;case exports.FacePart.Contour:return this._mgr.faces[t].contour;default:return console.error(`Head 240 doesn't support ${e} yet`),null;}}get280landmark(e,t){switch(e){case exports.FacePart.Whole:const a=this._mgr.getLandmarks(exports.FacePart.Whole,t,exports.FaceLandmarkType.Face240);let n=this.facePartHelper(0,this._mgr.faces[t].landmarks280LeftIris.size(),this._mgr.faces[t].landmarks280LeftIris,a);return n=this.facePartHelper(0,this._mgr.faces[t].landmarks280RightIris.size(),this._mgr.faces[t].landmarks280RightIris,n),n;case exports.FacePart.LeftEye:const r=this._mgr.getLandmarks(exports.FacePart.LeftEye,t,exports.FaceLandmarkType.Face240),i=this.facePartHelper(0,this._mgr.faces[t].landmarks280LeftIris.size(),this._mgr.faces[t].landmarks280LeftIris,r);return i;case exports.FacePart.RightEye:const o=this._mgr.getLandmarks(exports.FacePart.RightEye,t,exports.FaceLandmarkType.Face240),s=this.facePartHelper(0,this._mgr.faces[t].landmarks280RightIris.size(),this._mgr.faces[t].landmarks280RightIris,o);return s;case exports.FacePart.Nose:const d=this._mgr.getLandmarks(exports.FacePart.Nose,t,exports.FaceLandmarkType.Face240);return d;case exports.FacePart.Mouth:const l=this._mgr.getLandmarks(exports.FacePart.Mouth,t,exports.FaceLandmarkType.Face240);return l;case exports.FacePart.LeftEyeBrow:const c=this._mgr.getLandmarks(exports.FacePart.LeftEyeBrow,t,exports.FaceLandmarkType.Face240);return c;case exports.FacePart.RightEyeBrow:const p=this._mgr.getLandmarks(exports.FacePart.RightEyeBrow,t,exports.FaceLandmarkType.Face240);return p;case exports.FacePart.Contour:return this._mgr.faces[t].contour;default:return console.error(`Head 280 doesn't support ${e} yet`),null;}}get3dlandmark(e,t){return e===exports.FacePart.Whole?this._mgr.faces[t].landmarks3d:(console.error(`Head 3d doesn't support ${e} yet`),null)}onUpdate(e){const t=new Set,a=Li.algorithms.nativeResult;if(a&&a.getFaceCount){const n=a.getFaceCount();if(0<n)for(let e=0;e<n;e++){const n=a.getFaceBaseInfo(e),r=a.getFaceAttributeInfo(e),i=a.getFaceExtraInfo(e),o=a.getFaceMeshInfo(e),s=a.getFaceNewLandmarkInfo(e);if(null!=n){const e=new Ia;this._mgr.addFaceData(e);const a=n.ID;this._mgr.setFaceState(!0,a,exports.FaceType.Human),t.add(a),e.isValidFace=!0,e.type=exports.FaceType.Human,e.score=n.score,e.id=a,e.yaw=n.yaw,e.pitch=n.pitch,e.roll=n.roll,e.rect=new C(n.rect),e.action=n.action,e.landmarks106=n.points_array,null!=s&&(e.contour=s.points),null!=i&&(e.landmarks240EyeLeft=i.eye_left,e.landmarks240EyeRight=i.eye_right,e.landmarks240EyebrowLeft=i.eyebrow_left,e.landmarks240EyebrowRight=i.eyebrow_right,e.landmarks240Lip=i.lips,e.landmarks280LeftIris=i.left_iris,e.landmarks280RightIris=i.right_iris),null!=r&&(e.expression=r.exp_type),null!=o&&(e.landmarks3d=o.landmarks,e.faceMesh.vertexes=o.vertexes,e.faceMesh.normals=o.normals,e.faceMesh.tangents=o.tangents,e.faceMesh.scale=o.scale,e.faceMesh.mvp=new xe(o.mvp),e.faceMesh.modelMatrix=new xe(o.modelMatrix))}else console.error("Invalid face data:"+e)}e.set(exports.FaceType.Human,t)}}}class za extends Fa{constructor(){super()}getLandmarks(e){return e==exports.FacePart.Whole?this.landmarksPetV2:this.getPartLandmark(e,this.landmarksPetV2,Aa)}}class Ba extends Fa{constructor(){super()}getLandmarks(e){return e==exports.FacePart.Whole?this.landmarksPetV2:this.getPartLandmark(e,this.landmarksPetV2,Ra)}}var La=effect.Amaz;class Oa extends va{constructor(e){super(e),this._allTrackedIDs.set(exports.FaceType.Cat,new Set),this._allTrackedIDs.set(exports.FaceType.Dog,new Set)}getLandmark(e,t,a){if(a&&a!==exports.FaceLandmarkType.PetV2)console.error("Cannot get landmark for non-pet type.");else{const a=this._mgr.faces[t];if(a.type===exports.FaceType.Dog)return this.getLandmarkDog(e,a);if(a.type===exports.FaceType.Cat)return this.getLandmarkCat(e,a);console.error("Cannot get landmark for non-pet type.")}}getLandmarkDog(e,t){switch(e){case exports.FacePart.Whole:return t.landmarksPetV2;case exports.FacePart.LeftEye:let a=new La.Vec2Vector;return a=this.facePartHelper(58,66,t.landmarksPetV2,a),a=this.facePartHelper(74,75,t.landmarksPetV2,a),a;case exports.FacePart.RightEye:let n=new La.Vec2Vector;return n=this.facePartHelper(66,74,t.landmarksPetV2,n),n=this.facePartHelper(75,76,t.landmarksPetV2,n),n;case exports.FacePart.Nose:let r=new La.Vec2Vector;return r=this.facePartHelper(26,42,t.landmarksPetV2,r),r;case exports.FacePart.Mouth:let i=new La.Vec2Vector;return i=this.facePartHelper(42,58,t.landmarksPetV2,i),i;case exports.FacePart.LeftEar:let o=new La.Vec2Vector;return o=this.facePartHelper(0,1,t.landmarksPetV2,o),o=this.facePartHelper(23,26,t.landmarksPetV2,o),o=this.facePartHelper(76,83,t.landmarksPetV2,o),o;case exports.FacePart.RightEar:let s=new La.Vec2Vector;return s=this.facePartHelper(16,20,t.landmarksPetV2,s),s=this.facePartHelper(83,90,t.landmarksPetV2,s),s;case exports.FacePart.Contour:const d=new La.Vec2Vector;return this.facePartHelper(0,26,t.landmarksPetV2,d),d;default:return console.error(`Dog face doesn't support ${e} yet`),null;}}getLandmarkCat(e,t){switch(e){case exports.FacePart.Whole:return t.landmarksPetV2;case exports.FacePart.LeftEye:let a=new La.Vec2Vector;return a=this.facePartHelper(64,72,t.landmarksPetV2,a),a=this.facePartHelper(80,81,t.landmarksPetV2,a),a;case exports.FacePart.RightEye:let n=new La.Vec2Vector;return n=this.facePartHelper(72,80,t.landmarksPetV2,n),n=this.facePartHelper(81,82,t.landmarksPetV2,n),n;case exports.FacePart.Nose:let r=new La.Vec2Vector;return r=this.facePartHelper(40,48,t.landmarksPetV2,r),r;case exports.FacePart.Mouth:let i=new La.Vec2Vector;return i=this.facePartHelper(48,64,t.landmarksPetV2,i),i;case exports.FacePart.LeftEar:let o=new La.Vec2Vector;return o=this.facePartHelper(0,1,t.landmarksPetV2,o),o=this.facePartHelper(23,33,t.landmarksPetV2,o),o;case exports.FacePart.RightEar:let s=new La.Vec2Vector;return s=this.facePartHelper(16,20,t.landmarksPetV2,s),s=this.facePartHelper(33,40,t.landmarksPetV2,s),s;case exports.FacePart.Contour:const d=new La.Vec2Vector;return this.facePartHelper(0,26,t.landmarksPetV2,d),d;default:return console.error(`Cat face doesn't support ${e} yet`),null;}}getFaceType(e){return e===La.FacePetType.CAT?exports.FaceType.Cat:e===La.FacePetType.DOG?exports.FaceType.Dog:exports.FaceType.Human}onUpdate(e){const t=new Set,a=new Set,n=Li.algorithms.nativeResult;if(n&&n.getFacePetInfoCount){const r=n.getFacePetInfoCount();if(0<r)for(let e=0;e<r;e++){const r=n.getFacePetInfo(e);if(null!=r){const e=this.getFaceType(r.face_pet_type),n=r.Id;let i;e==exports.FaceType.Dog?(i=new za,a.add(n)):(i=new Ba,t.add(n)),this._mgr.addFaceData(i),this._mgr.setFaceState(!0,n,e),i.isValidFace=!0,i.type=e,i.score=r.score,i.id=n,i.yaw=-r.yaw,i.pitch=-r.pitch,i.roll=-r.roll,i.rect=new C(r.rect),i.action=r.action,i.landmarksPetV2=r.points_array}else console.error("Invalid face data:"+e)}e.set(exports.FaceType.Cat,t),e.set(exports.FaceType.Dog,a)}}}class ka extends e{constructor(){super(),this.faces=[],this._faceProviders=new Map,this._faceProviders.set(Ca.Human,new Ea(this)),this._faceProviders.set(Ca.Pet,new Oa(this)),this.hasFaceMap=new Map,this.hasFaceMap.set(exports.FaceType.Human,new Map),this.hasFaceMap.set(exports.FaceType.Cat,new Map),this.hasFaceMap.set(exports.FaceType.Dog,new Map)}static getInstance(){return null==this._instance&&(this._instance=new ka),this._instance}static getLandmark(e,t,a){return this.getInstance().getLandmarks(e,t,a)}getLandmarks(e,t,a){const n=this.faces[t],r=xa.get(n.type),i=this._faceProviders.get(r);return i?i.getLandmark(e,t,a):void console.error("Cannot get landmark data for face: "+t)}onUpdate(){this.resetFaceData();for(const e of this._faceProviders.values())e.update()}init(){}resetFaceData(){this.faces.length=0}addFaceData(e){this.faces.push(e)}static get faces(){return this.getInstance().faces}static getFacesByType(e){const t=this.faces.filter(t=>t.type===e);return t}static on(e,t,a){return this.getInstance().on(e,t,a)}static off(e,t,a){return this.getInstance().off(e,t,a)}setFaceState(e,t,a){const n=this.hasFaceMap.get(a);null==n?console.error(`There isn't a faceStatusMap for faceType: ${exports.FaceType[a]}`):(!n.has(t)&&n.set(t,!1),n.get(t)!==e&&(!0===e?this.fire(exports.FaceEvent.Detected,t,exports.FaceType[a]):this.fire(exports.FaceEvent.Lost,t,exports.FaceType[a]),n.set(t,e)))}}var Na=effect.Amaz;class Da{constructor(e){var t,a,n;const r=e.properties;this._initialized=!1,this._faceIndex=r.faceIndex,this._textureResScale=r.textureResScale,this._meshPath=r.meshPath,this._flipUv=r.flipUv,this._renderTexture=Li.customAssets.getNativeObject(e.uuid),this._renderTexture.depth=1,this._renderTexture.width=640,this._renderTexture.height=360,this._renderTexture.filterMag=Na.FilterMode.NEAREST,this._renderTexture.filterMin=Na.FilterMode.NEAREST,this._renderTexture.filterMipmap=Na.FilterMipmapMode.NONE,this._renderTexture.attachment=Na.RenderTextureAttachment.NONE;const i=o.createShaders({gles2:{vs:"precision highp float;\n    attribute vec3 attPosition;\n    attribute vec2 attTexcoord0;\n    uniform mat4 u_Model;\n    uniform mat4 u_MVP;\n    uniform float u_flipUv;\n    varying vec2 g_vary_uv0;\n    varying vec4 v_sampling_pos;\n    void main ()\n    {\n      vec4 homogeneous_pos = vec4(attPosition, 1.0);\n      g_vary_uv0 = attTexcoord0;\n      v_sampling_pos = u_MVP * homogeneous_pos;\n      if (u_flipUv > 0.5) {\n        g_vary_uv0.y = 1. - g_vary_uv0.y;\n      }\n      vec2 uv_pos = g_vary_uv0.xy * 2.0 - vec2(1.0);\n      gl_Position = vec4(uv_pos, 0.0, 1.0);\n    }\n    ",fs:`precision highp float;
    uniform sampler2D u_AlbedoTexture;
    varying vec4 v_sampling_pos;
    
    void main ()
    {
      vec2 sampling_uv = (v_sampling_pos.xy / v_sampling_pos.w) * 0.5 + 0.5;
      vec4 textureColor = texture2D( u_AlbedoTexture, sampling_uv);
      gl_FragColor = textureColor;
    }
    `},metal:{vs:`
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct buffer_t
    {
        float4x4 u_MVP;
        float u_flipUv;
    };

    struct main0_out
    {
        float2 g_vary_uv0;
        float4 v_sampling_pos;
        float4 gl_Position [[position]];
    };

    struct main0_in
    {
        float3 attPosition [[attribute(0)]];
        float2 attTexcoord0 [[attribute(1)]];
    };

    vertex main0_out main0(main0_in in [[stage_in]], constant buffer_t& buffer)
    {
        main0_out out = {};
        float4 homogeneous_pos = float4(in.attPosition, 1.0);
        out.g_vary_uv0 = in.attTexcoord0;
        out.v_sampling_pos = buffer.u_MVP * homogeneous_pos;
        if (buffer.u_flipUv > 0.5)
        {
            out.g_vary_uv0.y = 1.0 - out.g_vary_uv0.y;
        }
        float2 uv_pos = (out.g_vary_uv0 * 2.0) - float2(1.0);
        out.gl_Position = float4(uv_pos, 0.0, 1.0);
        out.gl_Position.z = (out.gl_Position.z + out.gl_Position.w) * 0.5;       // Adjust clip-space for Metal
        return out;
    }
    `,fs:`
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct main0_out
    {
        float4 gl_FragColor [[color(0)]];
    };

    struct main0_in
    {
        float4 v_sampling_pos;
    };

    fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> u_AlbedoTexture [[texture(0)]], sampler u_AlbedoTextureSmplr [[sampler(0)]])
    {
        main0_out out = {};
        float2 sampling_uv = ((in.v_sampling_pos.xy / float2(in.v_sampling_pos.w)) * 0.5) + float2(0.5);
        float4 textureColor = u_AlbedoTexture.sample(u_AlbedoTextureSmplr, sampling_uv);
        out.gl_FragColor = textureColor;
        return out;
    }
    `}});this._faceMaterial=this.createFaceTexMaterial(i);let s;s=sn&&void 0!==r.sourceTexture?Li.assets.loadSync(r.sourceTexture):Li.assets.loadSync("share://input.texture"),this._faceMaterial.setTex("u_AlbedoTexture",null==(t=s)?void 0:t.resource);const d=!0===this._flipUv?1:0;this._faceMaterial.setFloat("u_flipUv",d),this._renderTexture.width=Na.AmazingManager.getSingleton("BuiltinObject").getOutputTextureWidth()*this._textureResScale,this._renderTexture.height=Na.AmazingManager.getSingleton("BuiltinObject").getOutputTextureHeight()*this._textureResScale,this._faceMesh=null==(a=Li.assets.loadSync(this._meshPath))||null==(n=a.resource)?void 0:n.native}onStart(){}onLateUpdate(){}onDestroy(){}onUpdate(){const e=Li.customAssets.cmdBufferHelper;if(this._initialized||(e.cmdBufferSetRenderTexture(this._renderTexture),e.cmdBufferClearRenderTexture(!0,!0,new Na.Color(0,0,0,0),0),this._initialized=!0),null!=this._faceMesh&&null!=this._faceMaterial){const t=ka.faces,a=t.length;if(a<=this._faceIndex)return;const n=t[this._faceIndex].faceMesh;if(null===n)return;const r=n.vertexes,i=n.normals;null!=r&&null!=i&&0<r.size()&&0<i.size()&&(this._faceMaterial.setMat4("u_MVP",n.mvp.native),this._faceMesh.setVertexArray(r),this._faceMesh.setNormalArray(i));const o=new xe;o.identity(),e.cmdBufferSetRenderTexture(this._renderTexture),e.cmdBufferDrawMesh(this._faceMesh,o,this._faceMaterial,0,0,new Na.MaterialPropertyBlock)}else null===this._faceMesh&&console.error("face texture asset: mesh not found!"),null===this._faceMaterial&&console.error("face texture asset: material not found!")}createFaceTexMaterial(e){const t=new Na.Pass;t.shaders=e,t.clearColor=new Na.Color(0,0,0,1),t.clearType=Na.CameraClearType.COLOR_DEPTH;const a=new Na.Map;a.insert("attColor",Na.VertexAttribType.COLOR),a.insert("attPosition",Na.VertexAttribType.POSITION),a.insert("attTexcoord0",Na.VertexAttribType.TEXCOORD0),t.semantics=a;const n=new Na.RenderState;n.viewport=new Na.ViewportState,n.viewport.rect=new Na.Rect(0,0,1,1),n.viewport.minDepth=0,n.viewport.maxDepth=1,n.rasterization=new Na.RasterizationState;const r=new Na.DepthStencilState;r.depthWriteEnable=!1,n.depthstencil=r;const i=new Na.ColorBlendState,s=new Na.ColorBlendAttachmentState;s.blendEnable=!0,s.srcColorBlendFactor=Na.BlendFactor.SRC_ALPHA,s.dstColorBlendFactor=Na.BlendFactor.ONE_MINUS_SRC_ALPHA,s.srcAlphaBlendFactor=Na.BlendFactor.SRC_ALPHA,s.dstAlphaBlendFactor=Na.BlendFactor.ONE_MINUS_SRC_ALPHA,s.ColorBlendOp=Na.BlendOp.ADD,s.AlphaBlendOp=Na.BlendOp.ADD,i.attachments.pushBack(s),n.colorBlend=i,t.renderState=n;const d=o.createMaterial(t);return d.renderQueue=1,d.setMat4("u_MVP",new xe().native),d}}var wa=effect.Amaz;class Va{constructor(){this._segProviderMap=new Map,this._cmdBufferHelper=new s}static getInstance(){return null==this._instance&&(this._instance=new Va),this._instance}static getMask(e,t=0){return this.getInstance().getMask(e,t)}init(){this._segProviderMap.set(exports.SegmentationType.Body.toLowerCase(),new Ha(this)),this._segProviderMap.set(exports.SegmentationType.Head.toLowerCase(),new Ka(this)),this._segProviderMap.set(exports.SegmentationType.Sky.toLowerCase(),new ja(this)),this._segProviderMap.set(exports.SegmentationType.Hair.toLowerCase(),new qa(this)),this._segProviderMap.set(exports.SegmentationType.Building.toLowerCase(),new Ya(this)),this._segProviderMap.set(exports.SegmentationType.Cloth.toLowerCase(),new Wa(this)),this._segProviderMap.set(exports.SegmentationType.Ground.toLowerCase(),new Xa(this)),this._segProviderMap.set(exports.SegmentationType.Hand.toLowerCase(),new Za(this))}get cmdBufferHelper(){return this._cmdBufferHelper}onUpdate(e){this._cmdBufferHelper.onPreUpdate();for(const t of this._segProviderMap.values())t.onUpdate(e);this._cmdBufferHelper.onPostUpdate()}createRenderTextureHelper(e){return new Ga(o.createTexture2D(),o.createRenderTexture(),o.createScreenMaterial(e))}createNomralScreenShader(){return o.createShaders({gles2:{vs:"attribute vec3 inPosition;\n       attribute vec2 inTexCoord;\n       varying vec2 uv;\n       uniform mat4 u_Model;\n       void main() {\n       gl_Position = u_Model * vec4(inPosition, 1.0);\n       uv = inTexCoord;\n       }\n      ",fs:`precision lowp float;
       varying vec2 uv;
       uniform sampler2D tex;
       void main() {
        gl_FragColor = texture2D(tex, uv);
      }
      `},metal:{vs:`
      #include <metal_stdlib>
      #include <simd/simd.h>
  
      using namespace metal;
  
      struct buffer_t
      {
          float4x4 u_Model;
      };
  
      struct main0_out
      {
          float2 uv;
          float4 gl_Position [[position]];
      };
  
      struct main0_in
      {
          float3 inPosition [[attribute(0)]];
          float2 inTexCoord [[attribute(1)]];
      };
  
      vertex main0_out main0(main0_in in [[stage_in]], constant buffer_t& buffer)
      {
          main0_out out = {};
          out.gl_Position = buffer.u_Model * float4(in.inPosition, 1.0);
          out.uv = in.inTexCoord;
          out.gl_Position.z = (out.gl_Position.z + out.gl_Position.w) * 0.5;       // Adjust clip-space for Metal
          return out;
      }
       `,fs:`
      #include <metal_stdlib>
      #include <simd/simd.h>
      
      using namespace metal;
      
      struct main0_out
      {
          float4 gl_FragColor [[color(0)]];
      };
      
      struct main0_in
      {
          float2 uv;
      };
      
      fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> tex [[texture(0)]], sampler texSmplr [[sampler(0)]])
      {
          main0_out out = {};
          out.gl_FragColor = tex.sample(texSmplr, in.uv);
          return out;
      }    
       `}})}getMask(e,t){const a=this._segProviderMap.get(e.toLowerCase());return a?a.getMask(t):(console.error(`Segmentation doesn't support ${e} yet`),null)}}class Ga{constructor(e,t,a){this.texture=e,this.renderTexture=t,this.screenMaterial=a}}class Ua{constructor(e){this._mgr=e,this._texture=null,this._emptyImage=new wa.Image}}class Ha extends Ua{onUpdate(){if(null==this._texture)return;const e=Li.algorithms.nativeResult;if(!e||!e.getBgInfo)return;const t=e.getBgInfo(),a=this.getOrCreateTexture();null==t?a.storage(this._emptyImage):a.storage(t.bgMask)}getOrCreateTexture(){return null==this._texture&&(this._texture=new wa.Texture2D),this._texture}getMask(){return this.getOrCreateTexture()}}class ja extends Ua{onUpdate(){if(null==this._texture)return;const e=Li.algorithms.nativeResult;if(!e||!e.getSkyInfo)return;const t=e.getSkyInfo(),a=this.getOrCreateTexture();null==t?a.storage(this._emptyImage):a.storage(t.skyMask)}getOrCreateTexture(){return null==this._texture&&(this._texture=new wa.Texture2D),this._texture}getMask(){return this.getOrCreateTexture()}}class Wa extends Ua{onUpdate(){if(null==this._texture)return;const e=Li.algorithms.nativeResult;if(!e||!e.getClothesSegInfo)return;const t=e.getClothesSegInfo(),a=this.getOrCreateTexture();null==t?a.storage(this._emptyImage):a.storage(t.alphaMask)}getOrCreateTexture(){return null==this._texture&&(this._texture=new wa.Texture2D),this._texture}getMask(){return this.getOrCreateTexture()}}class Ya extends Ua{constructor(){super(...arguments),this._initialized=!1}onUpdate(){if(!this._initialized)return;const e=Li.algorithms.nativeResult;if(!e||!e.getBuildingSegInfo)return;const t=e.getBuildingSegInfo(),a=this.getOrCreateTexture();null==t?a.storage(this._emptyImage):a.storage(t.mask),this._screenMaterial.setTex("tex",a),this._mgr.cmdBufferHelper.cmdBufferSetRenderTexture(this._renderTexture),this._mgr.cmdBufferHelper.cmdBufferDrawMesh(this._mgr.cmdBufferHelper.screenMesh,new xe,this._screenMaterial,0,0,new wa.MaterialPropertyBlock)}getOrCreateTexture(){return null==this._texture&&(this._texture=new wa.Texture2D),this._texture}getMask(){return this.tryToInit(),this._renderTexture}tryToInit(){if(this._initialized)return;this._initialized=!0,this._renderTexture=o.createRenderTexture();const e=o.createShaders({gles2:{vs:"attribute vec3 inPosition;\n      attribute vec2 inTexCoord;\n      varying vec2 uv; \n      uniform mat4 u_Model;\n      void main() {\n        gl_Position = u_Model * vec4(inPosition, 1.0);\n        uv = inTexCoord;\n      }\n      ",fs:`precision lowp float;
      varying vec2 uv;
      uniform sampler2D tex;
      void main() {
        vec4 color = texture2D(tex, uv);
        gl_FragColor = vec4(color.g, color.g, color.g, 1.0);
      } 
      `},metal:{vs:`
      #include <metal_stdlib>
      #include <simd/simd.h>
      
      using namespace metal;
      
      struct buffer_t
      {
          float4x4 u_Model;
      };
      
      struct main0_out
      {
          float2 uv;
          float4 gl_Position [[position]];
      };
      
      struct main0_in
      {
          float3 inPosition [[attribute(0)]];
          float2 inTexCoord [[attribute(1)]];
      };
      
      vertex main0_out main0(main0_in in [[stage_in]], constant buffer_t& buffer)
      {
          main0_out out = {};
          out.gl_Position = buffer.u_Model * float4(in.inPosition, 1.0);
          out.uv = in.inTexCoord;
          out.gl_Position.z = (out.gl_Position.z + out.gl_Position.w) * 0.5;       // Adjust clip-space for Metal
          return out;
      }    
      `,fs:`
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct main0_out
    {
        float4 gl_FragColor [[color(0)]];
    };

    struct main0_in
    {
        float2 uv;
    };

    fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> tex [[texture(0)]], sampler texSmplr [[sampler(0)]])
    {
        main0_out out = {};
        float4 color = tex.sample(texSmplr, in.uv);
        out.gl_FragColor = float4(color.y, color.y, color.y, 1.0);
        return out;
    }
      `}});this._screenMaterial=o.createScreenMaterial(e)}}class Xa extends Ua{onUpdate(){if(null==this._texture)return;const e=Li.algorithms.nativeResult;if(!e||!e.getGroundSegInfo)return;const t=e.getGroundSegInfo(),a=this.getOrCreateTexture();null==t?a.storage(this._emptyImage):a.storage(t.groundMask)}getOrCreateTexture(){return null==this._texture&&(this._texture=new wa.Texture2D),this._texture}getMask(){return this.getOrCreateTexture()}}class qa extends Ua{onUpdate(){if(null==this._texture)return;const e=Li.algorithms.nativeResult;if(!e||!e.getHairInfo)return;const t=e.getHairInfo(),a=this.getOrCreateTexture();null==t?a.storage(this._emptyImage):a.storage(t.mask)}getOrCreateTexture(){return null==this._texture&&(this._texture=new wa.Texture2D),this._texture}getMask(){return this.getOrCreateTexture()}}class Ka extends Ua{constructor(e){super(e),this._rdMap=new Map}onUpdate(){const e=Li.algorithms.nativeResult;if(e&&e.getHeadSegInfoCount){for(let t=0;t<e.getHeadSegInfoCount();++t)this.getOrCreateRnderTextureHelper(t);for(const t of this._rdMap.keys())this.updateMask(e.getHeadSegInfo(t),this._rdMap.get(t))}}getMask(e){var t;return null==(t=this.getOrCreateRnderTextureHelper(e))?void 0:t.renderTexture}getOrCreateRnderTextureHelper(e){return this._rdMap.has(e)||this._rdMap.set(e,this._mgr.createRenderTextureHelper(this._mgr.createNomralScreenShader())),this._rdMap.get(e)}updateMask(e,t){if(null!=t&&(this._mgr.cmdBufferHelper.cmdBufferSetRenderTexture(t.renderTexture),this._mgr.cmdBufferHelper.cmdBufferClearRenderTexture(!0,!1,new wa.Color(0,0,0,0),1),null!=e)){t.texture.storage(e.alpha);const a=e.width,n=e.height,r=e.srcWidth,i=e.srcHeight,o=e.matrix,s=o.get(0),d=o.get(1),l=o.get(2),c=o.get(3),p=o.get(4),u=o.get(5),m=new xe(s,c,0,0,d,p,0,0,0,0,1,0,l,u,0,1);m.inv();const g=new xe(a/2,0,0,0,0,n/2,0,0,0,0,1,0,a/2,n/2,0,1);m.mul(g);const f=new xe(2/r,0,0,0,0,2/i,0,0,0,0,1,0,-1,-1,0,1);f.mul(m),t.screenMaterial.setTex("tex",t.texture),this._mgr.cmdBufferHelper.cmdBufferDrawMesh(this._mgr.cmdBufferHelper.screenMesh,f,t.screenMaterial,0,0,new wa.MaterialPropertyBlock)}}}class Za extends Ua{constructor(e){super(e),this._handMap=new Map}onUpdate(){const e=Li.algorithms.nativeResult;if(e&&e.getHandCount){for(let t=0;t<e.getHandCount();++t)this.getOrCreateTexture(t);for(const n of this._handMap.keys())if(null==e.getHandInfo(n)){var t;null==(t=this._handMap.get(n))?void 0:t.storage(this._emptyImage)}else{var a;null==(a=this._handMap.get(n))?void 0:a.storage(e.getHandInfo(n).image)}}}getOrCreateTexture(e){return this._handMap.has(e)||this._handMap.set(e,new wa.Texture2D),this._handMap.get(e)}getMask(e){return this.getOrCreateTexture(e)}}var Qa=effect.Amaz;class Ja{constructor(e){const t=e.properties;this._segType=t.segmentationType.toLowerCase(),this._smoothness=t.smoothness,this._invert=t.invert,this._useCutoutTexture=t.useCutoutTexture,this._cutoutTexture=t.cutoutTexture,this._cutoutTextureInverseY=t.cutoutTextureInverseY,this._renderTexture=Li.customAssets.getNativeObject(e.uuid),this._renderTexture.depth=1,this._renderTexture.width=Qa.AmazingManager.getSingleton("BuiltinObject").getInputTextureWidth(),this._renderTexture.height=Qa.AmazingManager.getSingleton("BuiltinObject").getInputTextureHeight(),this._renderTexture.filterMag=Qa.FilterMode.LINEAR,this._renderTexture.filterMin=Qa.FilterMode.LINEAR,this._renderTexture.filterMipmap=Qa.FilterMipmapMode.NONE,this._renderTexture.attachment=Qa.RenderTextureAttachment.NONE;const a=o.createShaders({gles2:{vs:"attribute vec3 inPosition;\n    attribute vec2 inTexCoord;\n    varying vec2 uv;\n    uniform mat4 u_Model;\n    void main() {\n      gl_Position = u_Model * vec4(inPosition, 1.0);\n      uv = inTexCoord;\n    }\n    ",fs:`precision highp float;
    varying vec2 uv;
    uniform sampler2D u_mask;
    uniform float u_smoothness;
    uniform float u_invert;
    uniform float u_useCutoutTexture;
    uniform float u_cutoutTextureInverseY;
    uniform sampler2D u_cutoutTex;
    uniform sampler2D u_mask2;
    uniform float u_useMask2;
    void main() {
      float maskAlpha = texture2D(u_mask, uv).r;
      if (u_useMask2 > 0.5) {
        maskAlpha += texture2D(u_mask2, uv).r;
      }
      maskAlpha = smoothstep(0.0 + (u_smoothness),1.0,maskAlpha);
      if(u_invert > 0.5) {
        maskAlpha = 1.0 - maskAlpha;
      }
      if (u_useCutoutTexture > 0.5) {
        if (u_cutoutTextureInverseY > 0.5) {
          gl_FragColor =  texture2D(u_cutoutTex, vec2(uv.x, 1.0 - uv.y));
        } else {
          gl_FragColor =  texture2D(u_cutoutTex, uv);
        }
        gl_FragColor.a = maskAlpha;
      } else {
        gl_FragColor = vec4(maskAlpha, maskAlpha, maskAlpha, 1.0);
      }
    }
    `},metal:{vs:`
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct buffer_t
    {
        float4x4 u_Model;
    };

    struct main0_out
    {
        float2 uv;
        float4 gl_Position [[position]];
    };

    struct main0_in
    {
        float3 inPosition [[attribute(0)]];
        float2 inTexCoord [[attribute(1)]];
    };

    vertex main0_out main0(main0_in in [[stage_in]], constant buffer_t& buffer)
    {
        main0_out out = {};
        out.gl_Position = buffer.u_Model * float4(in.inPosition, 1.0);
        out.uv = in.inTexCoord;
        out.gl_Position.z = (out.gl_Position.z + out.gl_Position.w) * 0.5;       // Adjust clip-space for Metal
        return out;
    }
    `,fs:`
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct buffer_t
    {
        float u_useMask2;
        float u_smoothness;
        float u_invert;
        float u_useCutoutTexture;
        float u_cutoutTextureInverseY;
    };

    struct main0_out
    {
        float4 gl_FragColor [[color(0)]];
    };

    struct main0_in
    {
        float2 uv;
    };

    fragment main0_out main0(main0_in in [[stage_in]], constant buffer_t& buffer, texture2d<float> u_mask [[texture(0)]], texture2d<float> u_mask2 [[texture(1)]], texture2d<float> u_cutoutTex [[texture(2)]], sampler u_maskSmplr [[sampler(0)]], sampler u_mask2Smplr [[sampler(1)]], sampler u_cutoutTexSmplr [[sampler(2)]])
    {
        main0_out out = {};
        float maskAlpha = u_mask.sample(u_maskSmplr, in.uv).x;
        if (buffer.u_useMask2 > 0.5)
        {
            maskAlpha += u_mask2.sample(u_mask2Smplr, in.uv).x;
        }
        maskAlpha = smoothstep(0.0 + buffer.u_smoothness, 1.0, maskAlpha);
        if (buffer.u_invert > 0.5)
        {
            maskAlpha = 1.0 - maskAlpha;
        }
        if (buffer.u_useCutoutTexture > 0.5)
        {
            if (buffer.u_cutoutTextureInverseY > 0.5)
            {
                out.gl_FragColor =  u_cutoutTex.sample(u_cutoutTexSmplr, float2(in.uv.x, 1.0 - in.uv.y));
            }
            else
            {
                out.gl_FragColor =  u_cutoutTex.sample(u_cutoutTexSmplr, in.uv);
            }
            out.gl_FragColor.w = maskAlpha;
        }
        else
        {
            out.gl_FragColor = float4(maskAlpha, maskAlpha, maskAlpha, 1.0);
        }
        return out;
    }
    `}});if(this._screenMaterial=o.createScreenMaterial(a),this._screenMaterial.setTex("u_mask",Va.getMask(this._segType)),this._screenMaterial.setFloat("u_smoothness",.9*(1-this._smoothness)),this._screenMaterial.setFloat("u_invert",!0===this._invert?1:0),!0===this._useCutoutTexture){const e=Li.assets.loadSync(this._cutoutTexture);null!=e&&(this._useCutoutTexture=!0,this._screenMaterial.setTex("u_cutoutTex",e.resource),this._screenMaterial.setFloat("u_cutoutTextureInverseY",!0===this._cutoutTextureInverseY?1:0))}this._screenMaterial.setFloat("u_useCutoutTexture",!0===this._useCutoutTexture?1:0),this._segType===exports.SegmentationType.Head.toLocaleLowerCase()||this._segType===exports.SegmentationType.Hand.toLocaleLowerCase()?(this._screenMaterial.setFloat("u_useMask2",1),this._screenMaterial.setTex("u_mask2",Va.getMask(this._segType,1))):this._screenMaterial.setFloat("u_useMask2",0)}onUpdate(){const e=Li.customAssets.cmdBufferHelper;e.cmdBufferSetRenderTexture(this._renderTexture),e.cmdBufferDrawMesh(e.screenMesh,new xe,this._screenMaterial,0,0,new Qa.MaterialPropertyBlock)}get type(){return exports.AssetSubType.Segmentation}onDestroy(){}onLateUpdate(){}onStart(){}}var $a=effect.Amaz;class en{constructor(e){const t=e.properties;if(this._builtinObject=$a.AmazingManager.getSingleton("BuiltinObject"),this._outputTexture=Li.customAssets.getNativeObject(e.uuid),this._outputTexture.depth=1,this._outputTexture.filterMag=$a.FilterMode.LINEAR,this._outputTexture.filterMin=$a.FilterMode.LINEAR,this._outputTexture.filterMipmap=$a.FilterMipmapMode.NONE,this._outputTexture.attachment=$a.RenderTextureAttachment.NONE,this._textureKey=t.textureKey,t.defaultImagePath){var a;this._defaultTexture=null==(a=Li.assets.loadSync(t.defaultImagePath))?void 0:a.resource,this._defaultTexture||console.error("Image Picker default texture load failure")}}updateOutputTexture(){const e=Li.customAssets.cmdBufferHelper,t=this._builtinObject.getUserTexture(this._textureKey);t?(this._outputTexture.width=t.width,this._outputTexture.height=t.height,e.cmdBufferBlit(t,this._outputTexture)):this._defaultTexture&&(this._outputTexture.width=this._defaultTexture.width,this._outputTexture.height=this._defaultTexture.height,e.cmdBufferBlit(this._defaultTexture,this._outputTexture))}onUpdate(){this.updateOutputTexture()}onStart(){this.updateOutputTexture()}onLateUpdate(){}onDestroy(){}}var tn=effect.Amaz;class an{constructor(e){this._renderTexture=Li.customAssets.getNativeObject(e.uuid),this._renderTexture.depth=1,this._renderTexture.filterMag=tn.FilterMode.LINEAR,this._renderTexture.filterMin=tn.FilterMode.LINEAR,this._renderTexture.filterMipmap=tn.FilterMipmapMode.NONE,this._renderTexture.attachment=tn.RenderTextureAttachment.NONE;const t=tn.AmazingManager.getSingleton("BuiltinObject");this._renderTexture.width=t.getInputTextureWidth(),this._renderTexture.height=t.getInputTextureHeight();const a=e.properties;this._flip=a.flip;const n=o.createShaders({gles2:{vs:"\n    precision highp float;\n\n    attribute vec3 inPosition;\n    attribute vec2 inTexCoord;\n\n    varying vec2 v_TexCoord;\n\n    uniform mat4 u_Model;\n    uniform float u_FlipVertical;\n\n    void main() {\n      vec2 flipCoord = vec2(inTexCoord.x, 1. - inTexCoord.y);\n      v_TexCoord = mix(inTexCoord, flipCoord, u_FlipVertical);\n      gl_Position = u_Model * vec4(inPosition, 1.0);\n    }\n    ",fs:`
    precision highp float;

    varying vec2 v_TexCoord;

    uniform sampler2D u_CameraTex;

    void main() {
      gl_FragColor = texture2D(u_CameraTex, v_TexCoord);
    }
    `},metal:{vs:`
    #include <metal_stdlib>
    #include <simd/simd.h>
    
    using namespace metal;
    
    struct buffer_t
    {
        float u_FlipVertical;
        float4x4 u_Model;
    };
    
    struct main0_out
    {
        float2 v_TexCoord;
        float4 gl_Position [[position]];
    };
    
    struct main0_in
    {
        float3 inPosition [[attribute(0)]];
        float2 inTexCoord [[attribute(1)]];
    };
    
    vertex main0_out main0(main0_in in [[stage_in]], constant buffer_t& buffer)
    {
        main0_out out = {};
        float2 flipCoord = float2(in.inTexCoord.x, 1.0 - in.inTexCoord.y);
        out.v_TexCoord = mix(in.inTexCoord, flipCoord, float2(buffer.u_FlipVertical));
        out.gl_Position = buffer.u_Model * float4(in.inPosition, 1.0);
        out.gl_Position.z = (out.gl_Position.z + out.gl_Position.w) * 0.5;       // Adjust clip-space for Metal
        return out;
    }
    `,fs:`
    #include <metal_stdlib>
    #include <simd/simd.h>

    using namespace metal;

    struct main0_out
    {
        float4 gl_FragColor [[color(0)]];
    };

    struct main0_in
    {
        float2 v_TexCoord;
    };

    fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> u_CameraTex [[texture(0)]], sampler u_CameraTexSmplr [[sampler(0)]])
    {
        main0_out out = {};
        out.gl_FragColor = u_CameraTex.sample(u_CameraTexSmplr, in.v_TexCoord);
        return out;
    }
    `}});this._sceneOutputRT=Li.scene.native.getOutputRenderTexture(),this._screenMaterial=o.createScreenMaterial(n),this._screenMaterial.setTex("u_CameraTex",this._sceneOutputRT);const r=!0===this._flip?1:0;this._screenMaterial.setFloat("u_FlipVertical",r)}onStart(){}onUpdate(){const e=Li.scene.native.getOutputRenderTexture();this._sceneOutputRT.equals(e)||(this._sceneOutputRT=e,this._screenMaterial.setTex("u_CameraTex",e));const t=Li.customAssets.cmdBufferHelper,a=tn.AmazingManager.getSingleton("BuiltinObject");return this._renderTexture.width=a.getInputTextureWidth(),this._renderTexture.height=a.getInputTextureHeight(),t.cmdBufferSetRenderTexture(this._renderTexture),void t.cmdBufferDrawMesh(t.screenMesh,new xe,this._screenMaterial,0,0,new tn.MaterialPropertyBlock)}onLateUpdate(){}onDestroy(){}}class nn{constructor(e){const t=e.properties;this._faceIndex=t.faceIndex,this._path=t.path,this._faceMesh=Li.customAssets.getNativeObject(e.uuid);const a=Li.assets.loadSync(this._path);if(null!==a){const e=a.resource.native.clone();this._faceMesh.assetMgr=e.assetMgr,this._faceMesh.name=e.name,this._faceMesh.boundingBox=e.boundingBox,this._faceMesh.instanceData=e.instanceData,this._faceMesh.instanceDataStride=e.instanceDataStride,this._faceMesh.materialIndex=e.materialIndex,this._faceMesh.morphers=e.morphers,this._faceMesh.skin=e.skin,this._faceMesh.submeshes=e.submeshes,this._faceMesh.vertexAttribs=e.vertexAttribs,this._faceMesh.vertices=e.vertices,this._faceMesh.seqMesh=e.seqMesh,this._faceMesh.originalVertices=e.originalVertices,this._faceMesh.clearAfterUpload=e.clearAfterUpload,this._faceMesh.setVertexCount(e.getVertexCount()),0!==e.getVertexArray(0,0).size()&&this._faceMesh.setVertexArray(e.getVertexArray(0,0),0,0,!0),0!==e.getNormalArray(0,0).size()&&this._faceMesh.setNormalArray(e.getNormalArray(0,0),0,0),0!==e.getTangentArray(0,0).size()&&this._faceMesh.setTangentArray(e.getTangentArray(0,0),0,0),0!==e.getColorArray(0,0).size()&&this._faceMesh.setColorArray(e.getColorArray(0,0),0,0),0!==e.getUvArray(0,0,0).size()&&this._faceMesh.setUvArray(0,e.getUvArray(0,0,0),0,0),0!==e.getUv3DArray(0,0,0).size()&&this._faceMesh.setUv3DArray(0,e.getUv3DArray(0,0,0),0,0),0!==e.getUserDefineArray(0,0,0).size()&&this._faceMesh.setUserDefineArray(0,e.getUserDefineArray(0,0,0),0,0),this.setUpMorpher(this._faceMesh,!1)}else console.error("face mesh asset: mesh not found!")}onDestroy(){}onStart(){}onUpdate(){if(null!==this._faceMesh){const e=ka.faces,t=e.length;if((0>this._faceIndex||5<this._faceIndex)&&(this._faceIndex=0),t<=this._faceIndex)return;const a=e[this._faceIndex].faceMesh;if(null===a)return;const n=a.vertexes,r=a.normals;null!==n&&null!==r&&0<n.size()&&0<r.size()&&(this._faceMesh.setVertexArray(n),this._faceMesh.setNormalArray(r),this.setUpMorpher(this._faceMesh,!0))}}onLateUpdate(){}setUpMorpher(e,t){if(null!==e){const a=Li.scene.native,n=a.entities;for(let a=0;a<n.size();a++){const r=n.get(a),i=r.getComponent("MorpherComponent");if(null!==i&&i.basemesh.handle===e.handle)if(!t){const t=i.channelWeights.clone(),a=t.getVectorKeys(),n=i.channelAmplifiers.clone(),r=n.getVectorKeys();i.basemesh=null,i.basemesh=e;const o=i.channelWeights,s=i.channelAmplifiers;for(let e=0;e<t.size();e++)o.set(a.get(e),t.get(a.get(e)));for(let e=0;e<n.size();e++)s.set(r.get(e),n.get(r.get(e)))}else i.basemesh=e}}}}var rn;const on=null==(rn=h.get(exports.Feature.RenderChainEvent))?"":rn,sn=d.doesSDKSupport(on),dn=new Map([[exports.AssetSubType.CameraInput.toLowerCase(),ya],[exports.AssetSubType.Face.toLowerCase(),Da],[exports.AssetSubType.Segmentation.toLowerCase(),Ja],[exports.AssetSubType.ImagePicker.toLowerCase(),en]]);function ln(){sn&&dn.set(exports.AssetSubType.CaptureFrame.toLowerCase(),an)}const cn=new Map([[exports.AssetSubType.Face.toLowerCase(),nn]]),pn=new Map([[exports.AssetType.Texture.toLowerCase(),dn],[exports.AssetType.Mesh.toLowerCase(),cn]]);ln();var un=effect.Amaz;function mn(e,t){const a=e.entities;let n=0<a.size()?a.get(0):void 0,r=Number.MIN_VALUE,o=Number.MAX_VALUE,s;for(let d=0;d<a.size();++d){const e=a.get(d),i=e.getComponent("EffectNode");i instanceof un.EffectNode&&(i.renderOrder>t&&i.renderOrder<o&&(o=i.renderOrder,s=e),r<i.renderOrder&&(r=i.renderOrder,n=e))}return s===void 0?n:s}function gn(e){const t=new Uint8Array(e);return String.fromCharCode.apply(null,t)}class fn{constructor(){this._resEntryMap=new Map,this._assets=new Map,this._nativeObjMap=new un.Map,this._cmdBufferHelper=new s,this._renderOrders=new Map,this._renderOrderSet=new Set([])}addListener(e,t){const a=mn(e,t),n=null==a?void 0:a.getComponent("EffectNode"),r=this._assets.get(t),i=null==r?void 0:r.updateFunction;return!!(r&&a&&n&&i)&&(un.AmazingManager.addListener(n,un.EffectNodeEvent.BEFORE_RENDER,i,this),r.effectNodeComponent=n,this._assets.set(t,r),!0)}removeListener(e){var t;if(0===e)return!0;const a=this._assets.get(e),n=null==a?void 0:a.effectNodeComponent,r=null==(t=this._assets.get(e))?void 0:t.updateFunction;return!!(a&&n&&void 0!==r)&&(un.AmazingManager.removeListener(n,un.EffectNodeEvent.BEFORE_RENDER,r,this),a.effectNodeComponent=void 0,this._assets.set(e,a),!0)}getNativeObject(e){return this._nativeObjMap.get(e)}init(){const e=Li.scene.native;if(null==e)return;const t=e.assetMgr.rootDir+"customAssets.json",a=fs.accessSync(t,0);if(!a)return void console.log("No customAssets.json found");const n=fs.readFileSync(t);if(this._assetsConfig=JSON.parse(gn(n)),null!=this._assetsConfig){this._nativeObjMap=e.assetMgr.getAllScriptCustomAssets();for(const e of this._assetsConfig){var r,i;this._resEntryMap.set(e.uuid,e),this._renderOrders.set(e.uuid,null==(r=null==(i=e.properties)?void 0:i.captureOrder)?0:r)}const t=this.analyzeAssetsDependency();for(const e of t){const t=this._resEntryMap.get(e),a=this.createCustomAsset(t),n=this._renderOrders.get(t.uuid);if(void 0!==n&&a)if(this._renderOrderSet.add(n),this._assets.has(n)){var o;null==(o=this._assets.get(n))?void 0:o.assets.push(a)}else this._assets.set(n,{assets:[a],updateFunction:()=>{this.render(n)},effectNodeComponent:void 0})}if(sn)for(const t of this._renderOrderSet)if(0!==t){const a=this.addListener(e,t);a||console.error("Custom-asset of renderOrder: "+t+" failed to be added")}}}get cmdBufferHelper(){return this._cmdBufferHelper}update(){this.render(0)}render(e){var t;this._cmdBufferHelper.onPreUpdate();const a=null==(t=this._assets.get(e))?void 0:t.assets;if(a)for(const e of a)null==e?void 0:e.onUpdate();this._cmdBufferHelper.onPostUpdate()}start(){for(const e of this._assets){const t=e[1].assets;for(const e of t)e.onStart()}}destroy(){if(sn)for(const e of this._renderOrderSet){const t=this.removeListener(e);t||console.error("Custom-asset of renderOrder: "+e+" failed to be removed")}for(const e of this._assets){const t=e[1].assets;for(const e of t)e.onDestroy()}}lateUpdate(e){for(const t of this._assets){const a=t[1].assets;for(const t of a)t.onLateUpdate(e)}}createCustomAsset(e){const t=pn.get(e.type.toLowerCase());if(null===t||void 0===t)return console.error(`Custom asset doesn't support asset type: [${e.type}]`),null;const a=null==t?void 0:t.get(e.subType.toLowerCase());return null===a||void 0===a?(console.error(`[${e.type}] custom asset doesn't support asset subtype: [${e.subType}]`),null):new a(e)}analyzeAssetsDependency(){var e=Math.max;let t=[];const a=new Map,n=new Map,r="custom://";let i=0;for(const e of this._assetsConfig)i+=1,n.set(e.uuid,0);for(const e of this._assetsConfig){const t=e.uuid;if(e.properties)for(const i in e.properties){const o=e.properties[i];if("string"==typeof o&&o.startsWith(r)){const e=o.substr(r.length);console.log(`custom assets: [${t}] depends on [${e}]`),n.set(e,n.get(e)+1),a.has(t)||a.set(t,[]),a.get(t).push(e)}}}const o=[];for(const e of n.keys())0===n.get(e)&&o.push(e);for(;0<o.length;){const e=o.shift();if(t.push(e),a.has(e))for(const t of a.get(e))n.set(t,n.get(t)-1),0===n.get(t)&&o.push(t)}if(t.length===i)t.reverse();else{console.error("Found circular dependency in custom assets"),t=[];for(const e of this._assetsConfig)t.push(e.uuid)}if(sn)for(const n of t){const t=a.get(n);null==t?void 0:t.forEach(t=>{var a,r;this._renderOrders.set(n,e(null==(a=this._renderOrders.get(n))?0:a,null==(r=this._renderOrders.get(t))?0:r))})}return t}}class _n{constructor(e,t){this._inputs=[void 0],this._outputs=[void 0],this._properties=new Map,this._needUpdateTexture=!0,this._needBreak=!1,this._name=e,this.deserialize({name:e,class:this.constructor.name,properties:t})}getInput(e){return this._inputs[e]}getOutput(e){return this._outputs[e]}set needUpdateTexture(e){this._needUpdateTexture=e}get needUpdateTexture(){return this._needUpdateTexture}getNeedBreak(){return this._needBreak}get inputSize(){return this._inputs.length}get outputSize(){return this._outputs.length}setInput(e,t=0){return t>this._inputs.length?void console.warn(`[JS GPUFilter] Index exceed input slot capacity!`):void(this._inputs[t]=e)}addInput(e){this._inputs.push(e)}addOutput(e){this._outputs.push(e)}setOutput(e,t=0){return t>this._outputs.length?void console.warn(`[JS GPUFilter] Index exceed output slot capacity!`):void(this._outputs[t]=e)}get name(){return this._name}get prop(){return this._properties}setProp(e,t){this._properties.set(e,t)}getProp(e){return this._properties.get(e)}deserialize(e){if(this.constructor.name!==e.class)return void console.error(`[JS GPUFilter] Cannot deserialize json: types [${this.constructor.name} vs ${e.class}] mismatch`);this._name=e.name||"";const t=e.properties||{};for(const a in t)this.setProp(a,t[a])}serialize(){const e={};return this._properties.forEach((t,a)=>{e[a]=t}),{name:this._name,class:this.constructor.name,properties:e}}render(){}isReady(){return this.isInputsReady()&&this.isOutputsReady()&&this._inputs[0]!==this._outputs[0]}isInputsReady(){for(let e=0;e<this._inputs.length;++e)if(!this._inputs[e])return!1;return!0}isOutputsReady(){return this._outputs[0]!=null}clear(){for(let e=0;e<this._inputs.length;++e)this._inputs[e]=void 0;for(let e=0;e<this._outputs.length;++e)this._outputs[e]=void 0}getOutRTInfo(e=0,t){var a=Math.floor,n;const r=null==(n=this._inputs[0])?t:n;if(void 0===r)return new Error("Cannot get output render target info because there is no input.");const i=this.getProp("widthScalar")?this.getProp("widthScalar"):1,o=this.getProp("heightScalar")?this.getProp("heightScalar"):1;let s=a(r.width*i),d=a(r.height*o);return this.getProp("width")&&(s=this.getProp("width")),this.getProp("height")&&(d=this.getProp("height")),{width:s,height:d,colorFormat:r.colorFormat,filterMode:r.filterMag}}}class hn{constructor(e,t,a,n,r=8){this.occupied=[],this.available=[],this.maxCapacity=8,this.width=0,this.height=0,this.format=S.RGBA8Unorm,this.filterMode=A.LINEAR,this.width=e,this.height=t,this.format=a,this.filterMode=n,this.maxCapacity=r}clear(){this.occupied.length=0,this.available.length=0}createTexture(){return o.createRenderTexturePlus(this.width,this.height,this.format,this.filterMode)}balance(){return this.occupied.length+this.available.length}get(){if(0<this.available.length){const e=this.available[this.available.length-1];return this.available.pop(),this.occupied.push(e),e}if(this.available.length+this.occupied.length<this.maxCapacity){const e=this.createTexture();return this.occupied.push(e),e}return new Error(`[JS GPUFilter] texture pool exceed capacity ${this.maxCapacity} limit!`)}return(e){const t=this.occupied.indexOf(e);let a;0<=t&&(a=this.occupied[t],this.occupied[t]=this.occupied[this.occupied.length-1],this.occupied.pop());const n=this.available.indexOf(e);0>n&&a&&this.available.push(a)}returnAll(){for(;0<this.occupied.length;){const e=this.occupied[this.occupied.length-1];this.available.push(e),this.occupied.pop()}}}class yn{constructor(e){this._pool=new Map,this._capacity=e}getKey(e,t,a,n){return`${e}-${t}-${a}-${n}`}get(e,t,a,n){const r=this.getKey(e,t,a,n);return this._pool.has(r)||this._pool.set(r,new hn(e,t,a,n,this._capacity)),this._pool.get(r).get()}getUniformPool(e,t,a,n){const r=this.getKey(e,t,a,n);return this._pool.has(r)?this._pool.get(r):void 0}return(e){if(void 0===e)return;const t=e.width,a=e.height,n=e.colorFormat,r=e.filterMin,i=this.getKey(t,a,n,r);this._pool.has(i)&&this._pool.get(i).return(e)}clearAll(){for(const e in this._pool){const t=this._pool.get(e);t.clear()}this._pool.clear()}returnAll(){this._pool.forEach(e=>{e.returnAll()})}totalBalance(){let e=0;return this._pool.forEach((t,a)=>{const n=this._pool.get(a);e+=n.balance()}),e}}class vn extends _n{onUpdate(e,t){this.needUpdateTexture&&this.getOutput(0)&&this.getInput(0)&&(t.blit(this.getInput(0),this.getOutput(0)),this.needUpdateTexture=!1)}}class Tn{static getMetal(e,t=void 0){switch(e){case"common.vs":return`
          #include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

struct main0_out
{
    float2 uv;
    float4 gl_Position [[position]];
};

struct main0_in
{
    float3 inPosition [[attribute(0)]];
    float2 inTexCoord [[attribute(1)]];
};

vertex main0_out main0(main0_in in [[stage_in]])
{
    main0_out out = {};
    out.gl_Position = float4(in.inPosition, 1.0);
    out.uv = in.inTexCoord;
    out.gl_Position.z = (out.gl_Position.z + out.gl_Position.w) * 0.5;       // Adjust clip-space for Metal
    return out;
}
        `;case"mask.fs":return`
          #include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

/* struct buffer_t */
/* { */
/*     int uMaskFlipY; */
/*     int uFlipY; */
/* }; */

struct main0_out
{
    float4 gl_FragColor [[color(0)]];
};

struct main0_in
{
    float2 uv;
};

fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> u_inputTex [[texture(0)]], texture2d<float> u_maskTex [[texture(1)]], sampler u_inputTexSmplr [[sampler(0)]], sampler u_maskTexSmplr [[sampler(1)]], 
    constant int& uMaskFlipY [[buffer(0)]],
    constant int& uFlipY [[buffer(1)]]
                        )
{
    main0_out out = {};
    float2 uv1 = in.uv;
    if (uMaskFlipY > 0)
    {
        uv1.y = 1.0 - uv1.y;
    }
    float2 uv2 = in.uv;
    if (uFlipY > 0)
    {
        uv2.y = 1.0 - uv2.y;
    }
    float3 texDest = u_inputTex.sample(u_inputTexSmplr, uv2).xyz;
    float texMask = u_maskTex.sample(u_maskTexSmplr, uv1).x;
    out.gl_FragColor = float4(texDest, clamp(texMask, 0.0, 1.0));
    return out;
}
        `;case"laplacian.fs":{const{hammersleyNumSample:e}=t;return`
          #pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wmissing-braces"

#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

template<typename T, size_t Num>
struct spvUnsafeArray
{
    T elements[Num ? Num : 1];
    
    thread T& operator [] (size_t pos) thread
    {
        return elements[pos];
    }
    constexpr const thread T& operator [] (size_t pos) const thread
    {
        return elements[pos];
    }
    
    device T& operator [] (size_t pos) device
    {
        return elements[pos];
    }
    constexpr const device T& operator [] (size_t pos) const device
    {
        return elements[pos];
    }
    
    constexpr const constant T& operator [] (size_t pos) const constant
    {
        return elements[pos];
    }
    
    threadgroup T& operator [] (size_t pos) threadgroup
    {
        return elements[pos];
    }
    constexpr const threadgroup T& operator [] (size_t pos) const threadgroup
    {
        return elements[pos];
    }
};

/* struct buffer_t */
/* { */
/*     float uMaskThreshold; */
/*     float2 uDestTextureSize; */
/*     float uIteration; */
/*     float uLevel; */
/*     spvUnsafeArray<float2, ${0|e}> u_hammersley; */
/*     float2 uBlurScale; */
/* }; */

struct main0_out
{
    float4 gl_FragColor [[color(0)]];
};

struct main0_in
{
    float2 uv;
};

static inline __attribute__((always_inline))
float2 hash22(thread const float2& p)
{
    float3 p3 = fract(float3(p.xyx) * float3(0.103100001811981201171875, 0.10300000011920928955078125, 0.097300000488758087158203125));
    p3 += float3(dot(p3, p3.yzx + float3(33.3300018310546875)));
    return fract((p3.xx + p3.yz) * p3.zy);
}

fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> uDestinationTexture [[texture(0)]], texture2d<float> uPrevLvlPassTexture [[texture(1)]], texture2d<float> uPrevPassTexture [[texture(2)]], sampler uDestinationTextureSmplr [[sampler(0)]], sampler uPrevLvlPassTextureSmplr [[sampler(1)]], sampler uPrevPassTextureSmplr [[sampler(2)]], 
    constant float& uMaskThreshold [[buffer(0)]],
    constant float2& uDestTextureSize [[buffer(1)]],
    constant float& uIteration [[buffer(2)]],
    constant float& uLevel [[buffer(3)]],
    constant spvUnsafeArray<float2, ${0|e}>& u_hammersley [[buffer(4)]],
    constant float2& uBlurScale [[buffer(5)]]
                         
                        )
{
    main0_out out = {};
    float4 outColor = uDestinationTexture.sample(uDestinationTextureSmplr, in.uv);
    if (outColor.w > uMaskThreshold)
    {
        float2 param = in.uv * 1000.0;
        float2 rnd = hash22(param);
        float2 texDestSize = uDestTextureSize;
        float minSide = min(texDestSize.x, texDestSize.y);
        if ((uIteration < 9.9999997473787516355514526367188e-05) && (uLevel < 9.9999997473787516355514526367188e-05))
        {
            float2 ratio = texDestSize / float2(minSide);
            float rangeStep = 0.100000001490116119384765625;
            float range = 0.0199999995529651641845703125;
            float weightSum = 0.0;
            float3 sum = float3(0.0);
            for (int j = 0; j < ${0|e}; j++)
            {
                weightSum = 0.0;
                sum = float3(0.0);
                for (int i = 0; i < ${0|e}; i++)
                {
                    float2 hUv = ratio * (u_hammersley[i]);
                    float2 sUv = in.uv + ((fract(hUv + rnd) - float2(0.5)) * range);
                    bool _158 = sUv.x < 0.0;
                    bool _166;
                    if (!_158)
                    {
                        _166 = sUv.x > 1.0;
                    }
                    else
                    {
                        _166 = _158;
                    }
                    bool _173;
                    if (!_166)
                    {
                        _173 = sUv.y < 0.0;
                    }
                    else
                    {
                        _173 = _166;
                    }
                    bool _180;
                    if (!_173)
                    {
                        _180 = sUv.y > 1.0;
                    }
                    else
                    {
                        _180 = _173;
                    }
                    if (_180)
                    {
                        continue;
                    }
                    float4 rndTex = uDestinationTexture.sample(uDestinationTextureSmplr, sUv);
                    if (rndTex.w < uMaskThreshold)
                    {
                        sum += rndTex.xyz;
                        weightSum += 1.0;
                    }
                }
                if (weightSum > 0.5)
                {
                    break;
                }
                range += rangeStep;
            }
            outColor = float4(sum / float3(weightSum), 1.0);
        }
        else
        {
            if ((uIteration < 9.9999997473787516355514526367188e-05) && (uLevel > 9.9999997473787516355514526367188e-05))
            {
                outColor = uPrevLvlPassTexture.sample(uPrevLvlPassTextureSmplr, in.uv);
            }
            else
            {
                float2 ratioRcp = float2(minSide) / texDestSize;
                float3 ret = float3(0.0);
                float size = 4.0;
                float _244 = -size;
                for (float i_1 = _244; i_1 <= size; i_1 += 1.0)
                {
                    if (abs(i_1) < 0.5)
                    {
                        continue;
                    }
                    float4 smpl = uPrevPassTexture.sample(uPrevPassTextureSmplr, (in.uv + ((uBlurScale * i_1) * ratioRcp)));
                    float weight = ((size + 1.0) - abs(i_1)) / 20.0;
                    ret += (smpl.xyz * weight);
                }
                outColor = float4(ret, 1.0);
                float3 _304 = outColor.xyz + float3((((rnd.x + rnd.y) - 1.0) / 255.0) / 20.0);
                outColor = float4(_304.x, _304.y, _304.z, outColor.w);
            }
        }
    }
    out.gl_FragColor = outColor;
    return out;
}
        `}case"resolve.fs":return`
          #include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

/* struct buffer_t */
/* { */
/*     int uMaskFlipY; */
/*     float uMaskThreshold; */
/* }; */

struct main0_out
{
    float4 gl_FragColor [[color(0)]];
};

struct main0_in
{
    float2 uv;
};

fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> uTopLevelTexture [[texture(0)]], texture2d<float> u_maskTex [[texture(1)]], sampler uTopLevelTextureSmplr [[sampler(0)]], sampler u_maskTexSmplr [[sampler(1)]], 
    constant int& uMaskFlipY [[buffer(0)]],
    constant float& uMaskThreshold [[buffer(1)]]
                        )
{
    main0_out out = {};
    float2 uv1 = in.uv;
    if (uMaskFlipY > 0)
    {
        uv1.y = 1.0 - uv1.y;
    }
    float4 tex = uTopLevelTexture.sample(uTopLevelTextureSmplr, in.uv);
    float mask = u_maskTex.sample(u_maskTexSmplr, uv1).x;
    if (mask < uMaskThreshold)
    {
        discard_fragment();
    }
    float alpha = (tex.w - uMaskThreshold) / (1.0 - uMaskThreshold);
    tex.w = clamp(alpha, 0.0, 1.0);
    out.gl_FragColor = tex;
    return out;
}
        `;case"grow.fs":{let e="";for(let t=-1;1>=t;++t)for(let a=-1;1>=a;++a)e+=`
              if (maskTexture.sample(maskTextureSmplr, (in.uv + (u_texelSize * float2(${0|t}, ${0|a}))))[u_channelIndex] > u_threshold)
    {
        out.gl_FragColor = float4(1.0);
        return out;
    }
                        `;return`
          #include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

/* struct buffer_t */
/* { */
/*     float2 u_texelSize; */
/*     int u_channelIndex; */
/*     float u_threshold; */
/* }; */

struct main0_out
{
    float4 gl_FragColor [[color(0)]];
};

struct main0_in
{
    float2 uv;
};

fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> maskTexture [[texture(0)]], sampler maskTextureSmplr [[sampler(0)]], 
                         constant float2& u_texelSize [[buffer(0)]],
                         constant int& u_channelIndex [[buffer(1)]],
                         constant float& u_threshold [[buffer(2)]]
                        )
{
    main0_out out = {};
    ${e}
    out.gl_FragColor = float4(0.0);
    return out;
}
                `}case"operator.fs":{const{snippetMetal:e,operandNum:a,declMetal:n,uniforms:r}=t;let o="",s="",d="",l="";for(let e=0;e<r.length;++e){const t=r[e];l+=`, constant ${t.type}& ${t.name} [[buffer(${0|e+2})]]`}for(let e=0;e<a;++e)o+=`, texture2d<float> u_inputTex${e} [[texture(${e})]]`,s+=`, sampler u_inputTex${e}Smplr [[sampler(${e})]]`,d+=`
              float4 input${e} = u_inputTex${e}.sample(u_inputTex${e}Smplr, in.uv);
            `;return`
#pragma clang diagnostic ignored "-Wmissing-prototypes"

#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

struct main0_out
{
    float4 gl_FragColor [[color(0)]];
};

struct main0_in
{
    float2 uv;
};

${n}

fragment main0_out main0(main0_in in [[stage_in]]${o}${s}${l})
{
    main0_out out = {};
    float4 result = float4(1.0, 0.0, 1.0, 1.0);
    ${d};
    ${e};
    out.gl_FragColor = result;
    return out;
}
        `.replace(/;[\s\r\n]*;/gm,";")}case"conv.fs":{const{core:e}=t,a=5;let n=``;for(const t of e)n+=`
              result += (u_inputTex.sample(u_inputTexSmplr, (in.uv + float2(${t[0].toFixed(a)} * invWidth, ${t[1].toFixed(a)} * invHeight))) * ${t[2].toFixed(a)});
              `;return`
          #include <metal_stdlib>
          #include <simd/simd.h>
          
          using namespace metal;
          
          /* struct buffer_t */
          /* { */
          /*     float invWidth; */
          /*     float invHeight; */
          /* }; */
          
          struct main0_out
          {
              float4 gl_FragColor [[color(0)]];
          };
          
          struct main0_in
          {
              float2 uv;
          };
          
          fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> u_inputTex [[texture(0)]], sampler u_inputTexSmplr [[sampler(0)]], constant float& invWidth [[buffer(0)]], constant float& invHeight [[buffer(1)]])
          {
              main0_out out = {};
              float4 result = float4(0.0);
              ${n}
              out.gl_FragColor = result;
              return out;
          }
          `}case"blur.fs":return``;default:return console.log(`Cannot find shader [${e}]!`),"";}}static get(e,t=void 0){switch(e){case"common.vs":return`

attribute vec3 inPosition;
attribute vec2 inTexCoord;
varying vec2 uv;
void main() {
    gl_Position = vec4(inPosition, 1.0);
    uv = inTexCoord;
}
        `;case"mask.fs":return`
precision highp float;
varying vec2 uv;
uniform sampler2D u_maskTex;
uniform sampler2D u_inputTex;
uniform int uFlipY;
uniform int uMaskFlipY;
uniform float uMaskThreshold;

void main() {
    vec2 uv1 = uv;
    if (uMaskFlipY > 0) {
        uv1.y = 1.0 - uv1.y;
    }

    vec2 uv2 = uv;
    if (uFlipY > 0) {
        uv2.y = 1.0 - uv2.y;
    }
    
    vec3 texDest = texture2D(u_inputTex, uv2).rgb;
    float texMask = texture2D(u_maskTex, uv1).r;
    gl_FragColor = vec4(
        texDest,
        clamp(texMask, 0.0, 1.0)
    );
}
        `;case"laplacian.fs":{const{hammersleyNumSample:e}=t;return`
    precision highp float;
    uniform sampler2D uDestinationTexture;
    uniform sampler2D uPrevPassTexture;
    uniform sampler2D uPrevLvlPassTexture;
    uniform float uIteration;
    uniform float uLevel;
    uniform vec2 uBlurScale;
    uniform float uMaskThreshold;
    uniform vec2 uDestTextureSize;
    uniform vec2 u_hammersley[${0|e}];

    varying vec2 uv;

    const float kTriangleKernelSum = 20.0;
    const float kTriangleKernelSize = 4.0;
    const float EPSILON = 0.0001;

    // https://www.shadertoy.com/view/4djSRW
    // TODO: SLOW!
    vec2 hash22(vec2 p) {
        vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));
        p3 += dot(p3, p3.yzx+33.33);
        return fract((p3.xx+p3.yz)*p3.zy);
    }


    void main() {
        vec4 outColor = texture2D(uDestinationTexture, uv);

        if (outColor.a > uMaskThreshold) {

            // Mutiply by 1000.0 for better hash distribution.
            vec2 rnd = hash22(1000.0*uv);
            vec2 texDestSize = uDestTextureSize;
            float minSide = min(texDestSize.x, texDestSize.y);

            if (uIteration < EPSILON && uLevel < EPSILON) {
                vec2 ratio = texDestSize / vec2(minSide);
                float rangeStep = 0.1;
                float range = 0.02;
                float weightSum = 0.0;
                vec3 sum = vec3(0.0);

                for (int j = 0; j < ${0|e}; ++j) {
                    weightSum = 0.0;
                    sum = vec3(0.0);

                    for (int i = 0; i < ${0|e}; ++i) {
                        // Multiply by ratio to compensate for the difference
                        // between pyramid and dest resolution difference.
                        vec2 hUv = ratio * u_hammersley[i];
                        vec2 sUv = uv + range * (fract(hUv + rnd) - 0.5);
                        if (sUv.x < 0.0 || sUv.x > 1.0
                            || sUv.y < 0.0 || sUv.y > 1.0) {
                            continue;
                        }
                        vec4 rndTex = texture2D(uDestinationTexture, sUv);
                        if (rndTex.a < uMaskThreshold) {
                            sum += rndTex.rgb;
                            weightSum += 1.0;
                        }
                    }

                    if (weightSum > 0.5) {
                        break;
                    }

                    range += rangeStep;
                }

                outColor = vec4(sum/weightSum, 1.0);
            }
            else if (uIteration < EPSILON && uLevel > EPSILON) {
                outColor = texture2D(uPrevLvlPassTexture, uv);
            }
            else {
                vec2 ratioRcp = vec2(minSide) / texDestSize;
                vec3 ret = vec3(0.0);
                float size = kTriangleKernelSize;
                for (float i = -size; i <= size; ++i) {
                    if (abs(i) < 0.5)
                        continue;

                    // Mutiliply sample uv by ratioRcp to compensate for the difference
                    // between pyramid and dest resolution difference.
                    vec4 smpl = texture2D(uPrevPassTexture, uv + i * uBlurScale * ratioRcp);
                    float weight = (size + 1.0 - abs(i)) / kTriangleKernelSum;
                    ret += weight * smpl.rgb;
                }

                outColor = vec4(ret, 1.0);
                // Add random value to compensate for banding due to low texture precission
                outColor.rgb += (rnd.r + rnd.g - 1.0) / 255.0 / kTriangleKernelSum;
            }
        }
        gl_FragColor = outColor;
    }    
        `}case"resolve.fs":return`
    uniform sampler2D uTopLevelTexture;
    uniform sampler2D u_maskTex;
    uniform float uMaskThreshold;

    uniform int uFlipY;
    uniform int uMaskFlipY;

    varying vec2 uv;

    void main()
    {
        vec2 uv1 = uv;
        if (uMaskFlipY > 0) {
            uv1.y = 1.0 - uv1.y;
        }

        vec4 tex = texture2D(uTopLevelTexture, uv);
        float mask = texture2D(u_maskTex, uv1).r;
        if(mask < uMaskThreshold) {
            discard;
        }
        float alpha = (tex.a - uMaskThreshold) / (1.0 - uMaskThreshold);
        tex.a = clamp(alpha, 0.0, 1.0);
        gl_FragColor = tex;
    }
        `;case"grow.fs":{let e="";for(let t=-1;1>=t;++t)for(let a=-1;1>=a;++a)e+=`

                        if(texture2D(maskTexture, uv + u_texelSize*vec2(${0|t}, ${0|a}) )[u_channelIndex] > u_threshold) {
                            gl_FragColor = vec4(1.0);
                            return;
                        }

                        `;return`
precision lowp float;
precision lowp sampler2D;
uniform sampler2D maskTexture;
uniform vec2 u_texelSize;
uniform float u_threshold;
uniform int u_channelIndex;
varying vec2 uv;
void main()
{
    /* if (u_flipY > 0) { */
    /*     uv.y = 1.0 - uv.y; */
    /* } */
    ${e}
    gl_FragColor = vec4(0.0);
}
                `}case"operator.fs":{const{snippet:e,operandNum:a,decl:n,uniforms:r}=t;let o="",s="",d="";for(const e in r){const t=r[e];d+=`
            uniform ${t.type} ${t.name};
            `}for(let e=0;e<a;++e)o+=`
            uniform sampler2D u_inputTex${e};
            `,s+=`
                vec4 input${e} = texture2D(u_inputTex${e}, uv);
            `;return`
precision lowp float;
precision lowp sampler2D;
${o};
varying vec2 uv;
${d};

${n}

void main()
{
    vec4 result = vec4(1.0, 0.0, 1.0, 1.0); // purple screen
    ${s};
    ${e};
    gl_FragColor = result;
}
        `.replace(/;[\s\r\n]*;/gm,";")}case"conv.fs":{const{core:e}=t,a=5;let n=``;for(const t of e)n+=`
              result += ${t[2].toFixed(a)}*texture2D(u_inputTex, uv + vec2((${t[0].toFixed(a)})*invWidth, (${t[1].toFixed(a)})*invHeight));
              `;return`
precision lowp float;
precision lowp sampler2D;
varying vec2 uv;
uniform sampler2D u_inputTex;
uniform float invWidth;
uniform float invHeight;
void main()
{
    vec4 result = vec4(0.0);
    ${n};
    gl_FragColor = result;
}
          `}case"blur.fs":return``;default:return console.log(`Cannot find shader [${e}]!`),"";}}}class Cn extends _n{constructor(e,t){super(e,t);const a=this.getProp("operandNum")?this.getProp("operandNum"):1,n=this.getProp("snippet")||"vec4 result = input0",r=!!this.getProp("blend"),i=this.getProp("decl")?this.getProp("decl"):"",s=this.getProp("uniforms")?this.getProp("uniforms"):[];for(;this.inputSize<a;)this.addInput(void 0);const d=this.getProp("vs")?this.getProp("vs"):Tn.get("common.vs"),l=Tn.get("operator.fs",{operandNum:a,snippet:n,decl:i,uniforms:s}),c=Tn.getMetal("common.vs"),p=Tn.getMetal("operator.fs",{operandNum:a,snippetMetal:this.getProp("snippetMetal")?this.getProp("snippetMetal"):this.toMetal(n),declMetal:this.getProp("declMetal")?this.getProp("declMetal"):this.toMetal(i),uniforms:s.map(e=>({type:this.toMetal(e.type),name:e.name}))});this._opMat=o.createEmptyMaterial(),o.addPassToMaterial(this._opMat,{gles2:{vs:d,fs:l},metal:{vs:c,fs:p}},!1,r)}get material(){return this._opMat}toMetal(e){return e=e.replace(/(vec)([1234]+)/gm,"float$2"),e=e.replace(/(mat)([1234])/gm,"float$2x$2"),e=e.replace(/(texture2D)\((.*),(.*)\)/gm,"$2.sample($2Smplr, $3)"),e}onUpdate(e,t){if(this.needUpdateTexture)if(this.isInputsReady()&&this.isOutputsReady()){for(let e=0;e<this.inputSize;++e)this._opMat.setTex(`u_inputTex${e}`,this.getInput(e));t.blitWithMaterial(this.getInput(0),this.getOutput(0),this._opMat,0),this.needUpdateTexture=!1}else console.warn(`[JS GPUFilter] OperatorFilter[${this.name}] cannot get inputs or output ready, check if your link is correct!`)}static predefinedOperators(e,t){return`OP_ADD`===t?new Cn(e,{operandNum:2,snippet:`
                result = input0 + input1;
                `}):`OP_BLEND`===t?new Cn(e,{operandNum:2,snippet:`
                // base input0
                result.rgb = mix(input0.rgb, input1.rgb, input0.a);
                result.a = 1.0;
                `}):`OP_MUL`===t?new Cn(e,{operandNum:2,snippet:`
                // base input0
                result.rgb = input0.rgb*input1.rgb;
                result.a = 1.0;
                `}):new Cn(e,{operandNum:1,snippet:`
                // base input0
                result.rgb = input0;
                result.a = 1.0;
                `})}}var xn=effect.Amaz;class Sn extends _n{constructor(e,t){super(e,t);const a=!!this.getProp("blend");this.getProp("iterations")===void 0&&this.setProp("iterations",2);const n=this.getProp("vs")?this.getProp("vs"):Tn.get("common.vs"),r=this.getProp("fs"),i=this.getProp("vsMetal")?this.getProp("vsMetal"):Tn.getMetal("common.vs"),s=this.getProp("fsMetal");this._pingpongMat=o.createEmptyMaterial(),o.addPassToMaterial(this._pingpongMat,{gles2:{vs:n,fs:r},metal:{vs:i,fs:s}},!1,a)}handleMaterialProp(){}onUpdate(e,t,a){if(this.needUpdateTexture)if(this.isReady()){const e=this.getInput(0).width,n=this.getInput(0).height;(0===e||0===n)&&console.error(`[JS GPUFilter] Pingpong Filter [${this.name}] width/height not correct!`);const r=S.RGBA8Unorm,o=a.get(e,n,r,A.LINEAR),s=this.getProp("iterations");let d=this.getInput(0),l=this.getOutput(0);for(let e=0;e<s;++e){const a=new xn.MaterialPropertyBlock;if(a.setTexture("u_inputTex",d),a.setFloat("invWidth",1/d.width),a.setFloat("invHeight",1/d.height),this.handleMaterialProp(a),t.blitWithMaterialAndProperties(d,l,this._pingpongMat,0,a),0==e)d=this.getOutput(0),l=o;else{const e=d;d=l,l=e}}d!==this.getOutput(0)&&t.blit(d,this.getOutput(0)),a.return(o),this.needUpdateTexture=!1}else console.warn(`[JS GPUFilter] Pingpong Filter [${this.name}] cannot get inputs or output ready, check if your link is correct!`)}}class Mn extends Sn{constructor(e,t){const{core:a,iterations:n,blend:r}=t,i=Tn.get("conv.fs",{core:a||[[0,0,1]]}),o=Tn.getMetal("conv.fs",{core:a||[[0,0,1]]});super(e,{iterations:n,fs:i,fsMetal:o,blend:r})}}function Fn(){return Fn=Object.assign||function(e){for(var t=1,a;t<arguments.length;t++)for(var n in a=arguments[t],a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n]);return e},Fn.apply(this,arguments)}var Pn=effect.Amaz;const Rn=new Uint32Array(1);function An(e){return Rn[0]=e,Rn[0]=(Rn[0]<<16|Rn[0]>>16)>>>0,Rn[0]=(1431655765&Rn[0])<<1|(2863311530&Rn[0])>>>1>>>0,Rn[0]=(858993459&Rn[0])<<2|(3435973836&Rn[0])>>>2>>>0,Rn[0]=(252645135&Rn[0])<<4|(4042322160&Rn[0])>>>4>>>0,Rn[0]=(16711935&Rn[0])<<8|(4278255360&Rn[0])>>>8>>>0,23283064365386963e-26*Rn[0]}function In(e,t){return new Pn.Vector2f(e/t,An(e))}class bn extends _n{constructor(e,t){super(e,Fn({},{quality:"low",blendEnable:!0,maskFlip:!0,inputFlip:!0,maskThreshold:.5},t)),this._pingpongPyramids=new Pn.Vector,this.addInput(void 0);const{numOfSamples:a,pyramidIterations:n,pyramidTopSize:r}=bn.PREDEFINED[this.getProp("quality")],i=Tn.get("common.vs"),s=Tn.getMetal("common.vs"),d=Tn.get("mask.fs"),l=Tn.getMetal("mask.fs"),c=a,p=Tn.get("laplacian.fs",{hammersleyNumSample:c}),u=Tn.getMetal("laplacian.fs",{hammersleyNumSample:c}),m=Tn.get("resolve.fs"),g=Tn.getMetal("resolve.fs"),f=S.RGBA8Unorm;this._inpaintMat=o.createEmptyMaterial(),o.addPassToMaterial(this._inpaintMat,{gles2:{vs:i,fs:d},metal:{vs:s,fs:l}},!1),o.addPassToMaterial(this._inpaintMat,{gles2:{vs:i,fs:p},metal:{vs:s,fs:u}},!1),o.addPassToMaterial(this._inpaintMat,{gles2:{vs:i,fs:m},metal:{vs:s,fs:g}},!1,this.getProp("blendEnable")),this._hammersleySamples=new Pn.Vec2Vector,this._pingpongPyramids.pushBack(this.buildPyramid(r,n.length,f,A.NEAREST)),this._pingpongPyramids.pushBack(this.buildPyramid(r,n.length,f,A.NEAREST));for(let a=0;a<c;++a)this._hammersleySamples.pushBack(In(a,c))}buildPyramid(e,t,a,n){const r=new Pn.Vector;for(let s=0;s<t;++s){const t=e<<s;r.pushBack(o.createRenderTexturePlus(t,t,a,n))}return r}onUpdate(e,t){this.needUpdateTexture&&(this.isInputsReady()&&this.isOutputsReady()?(this.buildCmd(t),this.needUpdateTexture=!1):console.warn(`[JS GPUFilter] OperatorFilter[${this.name}] cannot get inputs or output ready, check if your link is correct!`))}buildCmd(e){const t=this.getInput(0),a=this.getInput(1),n=this.getOutput(0);if(this._inpaintMat.setTex("u_inputTex",t),this._inpaintMat.setTex("u_maskTex",a),this._inpaintMat.setInt("uMaskFlipY",this.getProp("maskFlip")?1:0),this._inpaintMat.setInt("uFlipY",this.getProp("inputFlip")?1:0),this._inpaintMat.setFloat("uMaskThreshold",this.getProp("maskThreshold")),e.blitWithMaterial(t,n,this._inpaintMat,0),this._inpaintMat.setTex("uDestinationTexture",n),this._inpaintMat.setVec2("uDestTextureSize",new Pn.Vector2f(n.width,n.height)),!this._pingpongPyramids.empty()){const{pyramidIterations:t}=bn.PREDEFINED[this.getProp("quality")],a=t.length;let r=this._pingpongPyramids.get(0),o=this._pingpongPyramids.get(1),s=n;for(let d=0;d<a;++d){const a=0==d?n:r.get(d-1);for(let s=0;s<t[d];++s){const t=r.get(d),i=o.get(d),l=new Pn.MaterialPropertyBlock;l.setVec2Vector("u_hammersley",this._hammersleySamples),l.setTexture("uPrevPassTexture",t),l.setTexture("uPrevLvlPassTexture",a),l.setFloat("uIteration",s),l.setFloat("uLevel",d);const c=0==s%2?1/t.width:0,p=1==s%2?1/t.height:0,u=new Pn.Vec2Vector;u.pushBack(new Pn.Vector2f(c,p)),l.setVec2Vector("uBlurScale",u),e.blitWithMaterialAndProperties(n,i,this._inpaintMat,1,l);const m=o;o=r,r=m}const i=r.get(d);s=i}this._inpaintMat.setTex("uTopLevelTexture",s),e.blitWithMaterial(s,n,this._inpaintMat,2)}}}bn.PREDEFINED={low:{numOfSamples:16,pyramidIterations:[5,5,3],pyramidTopSize:32},medium:{numOfSamples:32,pyramidIterations:[5,11,5,3],pyramidTopSize:64},high:{numOfSamples:64,pyramidIterations:[5,11,11,5,5],pyramidTopSize:64}};class En extends _n{constructor(e,t){super(e,t),this._quadMat=this.getProp("material")?this.getProp("material"):o.createEmptyMaterial(),this._updater=this.getProp("updater")?this.getProp("updater"):()=>{}}onUpdate(e,t){if(this.needUpdateTexture)if(this.isReady()){this._updater(this._quadMat);const e=this.getInput(0),a=this.getOutput(0);t.blitWithMaterial(e,a,this._quadMat,0),this.needUpdateTexture=!1}else console.warn(`[JS GPUFilter] Material Filter [${this.name}] cannot get inputs or output ready, check if your link is correct!`)}getOutRTInfo(e=0,t){var a=Math.floor;const n=super.getOutRTInfo(e,t),r=this.getProp("widthScalar")?this.getProp("widthScalar"):1,i=this.getProp("heightScalar")?this.getProp("heightScalar"):1;return n.width=a(n.width*r),n.height=a(n.height*i),n}}var zn=effect.Amaz;class Bn extends _n{constructor(e,t){super(e,Fn({},{threshold:.5,channel:"red",growAmount:5},t));const a=Tn.get("common.vs"),n=Tn.get("grow.fs"),r=Tn.getMetal("common.vs"),i=Tn.getMetal("grow.fs");this._growMat=o.createEmptyMaterial(),o.addPassToMaterial(this._growMat,{gles2:{vs:a,fs:n},metal:{vs:r,fs:i}},!1)}buildCmd(e,t){const a=this.getInput(0),n=this.getOutput(0),r=this.getProp("channel");let o=this.getProp("growAmount");o=Math.min(Bn.MAX_GROW_ITERATION,o);const s=this.getProp("threshold"),d=1/n.width,l=1/n.height,c=Bn.CHANNEL_MAP.get(r)||0;this._growMat.setInt("u_channelIndex",c),this._growMat.setVec2("u_texelSize",new zn.Vector2f(d,l)),this._growMat.setFloat("u_threshold",s),e.blit(a,n);let p=n;const u=t.get(n.width,n.height,n.colorFormat,n.filterMag);let m=u,g=p;for(let a=0;a<o;++a){const t=new zn.MaterialPropertyBlock;t.setTexture("maskTexture",p),e.blitWithMaterialAndProperties(p,m,this._growMat,0,t);const a=m;m=p,p=a,g=p}t.return(u),g!==n&&e.blit(g,n)}onUpdate(e,t,a){this.needUpdateTexture&&(this.isInputsReady()&&this.isOutputsReady()?(this.buildCmd(t,a),this.needUpdateTexture=!1):console.warn(`[JS GPUFilter] OperatorFilter[${this.name}] cannot get inputs or output ready, check if your link is correct!`))}}Bn.MAX_GROW_ITERATION=32,Bn.CHANNEL_MAP=new Map([["red",0],["green",1],["blue",2],["alpha",3]]);var Ln=effect.Amaz,On=Ln.CommandBuffer;const kn=effect.Amaz;class Nn{constructor(){this.engine=new kn.JSWrapByteNNEngine,this.engineConfig=new kn.JSWrapByteNNConfig}loadModel(e){const t=Li.scene.native.assetMgr.rootDir+e.get("modelPath"),a=fs.readFileSync(t);this.engineConfig.modelBuffer=a,this.engineConfig.modelBufferSize=null==a?void 0:a.byteLength,this.engineConfig.numThread=e.has("numThread")?e.get("numThread"):2,this.engineConfig.oclKernelBinPath=e.has("oclKernelBinPath")?e.get("oclKernelBinPath"):"./",this.engineConfig.type=e.has("forwardType")?e.get("forwardType"):exports.ByteNNForwardType.AUTO;const n=this.engine.Init(this.engineConfig);return 0!=n&&console.error(`[Init]: bytenn init error ${n}`),n}destory(){this.engine.Release()}inference(e){let t=this.engine.SetInput(e);0!=t&&console.error(`[Inference]: bytenn setInput error ${t}`),t=this.engine.Inference(),0!=t&&console.error(`[Inference]: bytenn Infernece error ${t}`);const a=[];return t=this.engine.GetOutput(a),0!=t&&console.error(`[Inference]: bytenn GetOutput error ${t}`),a}}exports.InferenceEngine=Nn;const Dn={SUCCESS:0,ERR_MEMORY_ALLOC:1,NOT_IMPLEMENTED:2,ERR_UNEXPECTED:3,ERR_DATANOMATCH:4,INPUT_DATA_ERROR:5,CALL_BACK_STOP:6,BACKEND_FALLBACK:7,NULL_POINTER:8,INVALID_POINTER:9,INVALID_MODEL:10,INFER_SIZE_ERROR:11,NOT_SUPPORT:12,DESTROYED_ERROR:13,WRONG_LICENSE:14,BROKEN_MODEL:15,EARLY_STOP:16};exports.ByteNNErrorCode=Dn;var wn=effect.Amaz;const Vn=wn.JSWrapCV;class Gn{constructor(e){this._properties=new Map,this.deserialize(e),this._modelPath=this.getProp("modelPath"),this._outTextureSize=this.getProp("outTextureSize"),this._tensorSize=this.getProp("tensorSize"),this._convertToIn=this.getProp("affineIn"),this._convertToOut=this.getProp("affineOut"),this.preF=Function,this.hasPreF=!1,this.postF=Function,this.hasPostF=!1,this.faceType=this.getProp("faceType")?this.getProp("faceType"):exports.FaceType.Human,this.inColorMat=Vn.Mat(),this.outColorMat=Vn.Mat(),this.inResizeMat=Vn.Mat(),this.outResizeMat=Vn.Mat(),this.inAffineMat=Vn.Mat(),this.outAffineMat=Vn.Mat(),this._width=0,this._height=0,this._outputType=0,null!=this.getProp("outputType")&&(this._outputType=1),this.inferenceEngine=new Nn,this.setModel()}setModel(e){const t=new Map;if(null==this.getProp("modelPath"))return 1;null==e?t.set("modelPath",this.getProp("modelPath")):t.set("modelPath",e);const a=this.getProp("numThread")?this.getProp("numThread"):2;t.set("numThread",a);const n=this.getProp("oclKernelBinPath")?this.getProp("oclKernelBinPath"):"./";t.set("oclKernelBinPath",n);const r=this.getProp("forwardType")?this.getProp("forwardType"):4;t.set("forwardType",r);const i=this.inferenceEngine.loadModel(t);return i}setInputTensor(e){let t=Vn.Mat(e);if(this.getProp("scale")){const a=this.getProp("scale");this._width=a*e.width,this._height=a*e.height,Vn.resize(t,this.inResizeMat,[this._width,this._height]),t=this.inResizeMat}if(this.hasPreF){const e=ka.getFacesByType(this.faceType).length;if(console.error(e),0!=e){const e=ka.getFacesByType(this.faceType)[0],a=this.preF(e.getLandmarks(exports.FacePart.Whole,exports.FaceLandmarkType.Face106));this.affineMatrix=a,Vn.warpAffine(t,this.inResizeMat,a,this._tensorSize,0,0),t=this.inResizeMat}}else null!=this._tensorSize&&(Vn.resize(t,this.inResizeMat,this._tensorSize),t=this.inResizeMat);null!=this.getProp("cvColorIn")&&(Vn.cvtColor(t,this.inColorMat,this.getProp("cvColorIn")),t=this.inColorMat),null!=this._convertToIn&&(t.convertTo(this.inAffineMat,this._convertToIn[0],this._convertToIn[1],this._convertToIn[2]),t=this.inAffineMat);const a=t.toTensor();return a}getOutputImage(e){let t=Vn.Mat(e);if(null!=this._convertToOut&&(t.convertTo(this.outAffineMat,this._convertToOut[0],this._convertToOut[1],this._convertToOut[2]),t=this.outAffineMat),null!=this.getProp("cvColorOut")&&(Vn.cvtColor(t,this.outColorMat,this.getProp("cvColorOut")),t=this.outColorMat),this.hasPreF&&null!=this.affineMatrix){const e=Vn.Mat();Vn.invertAffineTransform(this.affineMatrix,e),Vn.warpAffine(t,this.outResizeMat,e,[this._width,this._height],0,0),t=this.outResizeMat}else null!=this._outTextureSize&&(Vn.resize(t,this.outResizeMat,this._outTextureSize),t=this.outResizeMat);this.hasPostF&&(t=this.postF(t)),t.flip(0);const a=t.toImage(wn.PixelFormat.RGBA8Unorm,!1);return a}inference(e){const t=[];for(let a=0;a<e.length;++a){const n=this.setInputTensor(e[a]);t.push(n)}const a=this.inferenceEngine.inference(t);if(this._outputType)return a;const n=[];for(let t=0;t<a.length;++t){const e=this.getOutputImage(a[t]);n.push(e)}return n}deserialize(e){const t=e||{};for(const a in t)this._properties.set(a,t[a])}getProp(e){return this._properties.get(e)}addPreF(e){this.preF=e,this.hasPreF=!0}addPostF(e){this.postF=e,this.hasPostF=!0}destory(){this.inferenceEngine.destory()}}var Un=effect.Amaz;class Hn extends _n{constructor(e,t){super(e,t),this._isModelLoaded=!0,this.nnInference=new Gn(t),this._needBreak=!0,this.cmdBuffer=new On,this.resultTexture=new Un.Texture2D}updateModel(e){return null==this.nnInference?void console.error("Neural filter does not load properly"):void this.nnInference.setModel(e)}onUpdate(){this.needUpdateTexture&&(!this._isModelLoaded&&console.log("The model has not been loaded properly"),this.isReady()&&this._isModelLoaded&&(console.error("updateing!!!!!"),this.cmdBuffer.blit(this.resultTexture,this.getOutput(0)),this.needUpdateTexture=!1))}render(){if(!this.needUpdateTexture){const e=[];for(let t=0;t<this.inputSize;++t){const a=this.getInput(t);e.push(a)}const t=this.nnInference.inference(e)[0];this.resultTexture.storage(t),Li.scene.native.commitCommandBuffer(this.cmdBuffer)}}addPreF(e){this.nnInference.addPreF(e)}addPostF(e){this.nnInference.addPostF(e)}destroy(){this.nnInference.destory()}}const jn="internal_blit",Wn="BlitFilter",Yn="OperatorFilter",Xn="PingpongFilter",qn="MaterialFilter",Kn="InpaintFilter",Zn="GrowFilter",Qn="ConvFilter",Jn="NeuralFilter";class $n{static makeFilter(e){const t=e.class,a=e.name;switch(t){case Wn:return new vn(a,e.properties);case Yn:return new Cn(a,e.properties);case Xn:return new Sn(a,e.properties);case Qn:return new Mn(a,e.properties);case qn:return new En(a,e.properties);case Kn:return new bn(a,e.properties);case Zn:return new Bn(a,e.properties);case Jn:return new Hn(a,e.properties);default:const n=Cn.predefinedOperators(a,t);return n;}}}var er=effect.Amaz,tr=er.Texture;class ar{constructor(e,t){if(this.from=void 0,this.fromIndex=0,this.to=void 0,this.toIndex=0,this._filterGraph=t,this.deserialize(e),void 0===this.to&&void 0===this.from)throw new Error(`[JS GPUFilter] Invalid filter node linking`)}unlink(){this.from&&this.from.setOutput(void 0,this.fromIndex),this.to&&this.to.setInput(void 0,this.toIndex)}serialize(){return{from:this.from?this.from.name:void 0,fromIndex:this.fromIndex,to:this.to?this.to.name:void 0,toIndex:this.toIndex}}getKey(){return JSON.stringify(this.serialize())}static getKeyFrom(e,t,a,n){return JSON.stringify({from:e,fromIndex:t,to:a,toIndex:n})}deserialize(e){this.from=this._filterGraph.getFilter(e.from)||void 0,this.to=this._filterGraph.getFilter(e.to)||void 0,this.fromIndex=e.fromIndex,this.toIndex=e.toIndex}}class nr{constructor(e,t=void 0){this.filter=e,this.hook=t}}class rr{constructor(){this.camera=void 0,this.cameraRenderEvent=exports.CameraRenderEvent.AfterRender,this.cameraCallback=()=>{}}clear(){this.camera=void 0,this.cameraRenderEvent=exports.CameraRenderEvent.AfterRender,this.cameraCallback=()=>{}}isBound(){return this.camera!==void 0}}const ir=32;class or{constructor(){this._inputs=[void 0],this._outputs=[void 0],this._orderedFilters=[],this._filters=new Map,this._links=new Map,this._sorted=!1,this._cmdBufferQueue=[],this._currentCmdBufferIndex=0,this._texturePool=new yn(ir),this._linkTexturePool=new yn(ir),this._cameraInfo=new rr,this._debug=!1,this._running=!0,this._lastAutoLinkedName=void 0,this._autoLinkNow=!1}init(){}clear(){this.clearTexture();for(let e=0;e<this._orderedFilters.length;++e)if(this._orderedFilters[e]instanceof Hn){const t=this._orderedFilters[e];t.destroy()}this._orderedFilters.length=0,this._links.clear(),this._filters.clear(),this.commandBuffer.clearAll(),this._texturePool.clearAll(),this._linkTexturePool.clearAll()}get inputSize(){return this._inputs.length}get outputSize(){return this._outputs.length}getInput(e){return this._inputs[e]}getOutput(e){return this._outputs[e]}setInput(e,t){this._inputs[t]=e}setOutput(e,t){this._outputs[t]=e}clearTexture(){this._inputs.length=0,this._outputs.length=0}deserialize(e,t){this.clear();for(const a of e.nodes){const e=t(a);this._orderedFilters.push(e),this.addFilter(a.name,e,!1)}for(const a of e.links){const e=new ar(a,this);this._links.set(e.getKey(),e)}}serialize(){const e=[];this._links.forEach(t=>{e.push(t.serialize())});const t=[];for(const e of this._orderedFilters)t.push(e.serialize());return{links:e,nodes:t}}render(){if(!this._running)return;let e=0;for(const t in this._orderedFilters){const a=this._orderedFilters[t];if(a.getNeedBreak()&&this._commitCommandBuffer(e++),a.render(),this._debug){const t=this._filters.get(a.name).hook;this._commitCommandBuffer(e++),void 0!==t&&this._commitCommandBuffer(e++)}}this._commitCommandBuffer(e)}_commitCommandBuffer(e){e<this._cmdBufferQueue.length?Li.scene.native.commitCommandBuffer(this._cmdBufferQueue[e]):console.warn(`[JS GPUFilter] command buffer index out of boundary! Render failed!`)}set debug(e){this._debug=e}get debug(){return this._debug}get commandBuffer(){return 0===this._cmdBufferQueue.length&&this.addCmdBuffer(),this._cmdBufferQueue[this._currentCmdBufferIndex]}addCmdBuffer(){this._cmdBufferQueue.push(new On),this._currentCmdBufferIndex=this._cmdBufferQueue.length-1}bind(e,t,a=[],n=void 0,r=!1){this._cameraInfo.isBound()&&this.unbind(),this._cameraInfo.camera=e,this._cameraInfo.cameraRenderEvent=t,this._cameraInfo.cameraCallback=()=>{this.render()},er.AmazingManager.addListener(this._cameraInfo.camera.native,this._cameraInfo.cameraRenderEvent,this._cameraInfo.cameraCallback,void 0),this._inputs[0]=n instanceof tr?n:e.renderTexture,this._outputs[0]=e.renderTexture;for(const i of a)this._inputs.push(i);if(!r){const e=$n.makeFilter({class:Wn,name:jn});e?(this.add(e),console.info("[JS Filter] internal_blit filter was created to avoid read/write the same render target. Please use internal_blit.inputs[0] as the systems inputs[0]!!!")):console.warn("[JS Filter] Failed to create internal_blit filter as requested in the options.")}}onEnable(){this._running=!0}onDisable(){this._running=!1}unbind(e=!0){var t;er.AmazingManager.removeListener(null==(t=this._cameraInfo.camera)?void 0:t.native,this._cameraInfo.cameraRenderEvent,this._cameraInfo.cameraCallback,void 0),this._cameraInfo.clear(),e&&this.clear()}_autolink(e,t,a){var n=Math.min;const r=e?e.outputSize:this._inputs.length,o=a?a.inputSize:this._outputs.length;for(let o=0;o<n(r,t.inputSize);++o)this._autoLinkNow=!0,this.link(e?e.name:void 0,o,t.name,o);for(let r=0;r<n(o,t.inputSize);++r)this._autoLinkNow=!0,this.link(t.name,r,a?a.name:void 0,r)}addFilter(e,t,a=!0){if(this.removeFilter(e),this._filters.set(e,new nr(t)),this._sorted=!1,a){if(0>=this._orderedFilters.length)this._autolink(void 0,t,void 0);else{const e=this._orderedFilters[this._orderedFilters.length-1];for(let t=0;t<e.outputSize;++t){const a=ar.getKeyFrom(e.name,t,void 0,t);e.setOutput(void 0,t),this._links.delete(a)}this._autolink(e,t,void 0)}this._lastAutoLinkedName=e}}add(e,t=!0){e instanceof _n?this.addFilter(e.name,e,t):this.addFilter(e.name,$n.makeFilter(e),t)}getFilter(e){var t;return null==(t=this._filters.get(e))?void 0:t.filter}removeFilter(e){const t=this.getFilter(e);if(t){for(const e of this._links.keys()){const a=this._links.get(e);if(a.from===t||a.to===t){if(this._links.delete(e),void 0===a.from||void 0===a.to)continue;const n=a.from===t?a.toIndex:a.fromIndex;a.from===t?a.to.setInput(void 0,n):a.from.setOutput(void 0,n)}}this._filters.delete(t.name),this.topsort(),this.optimizeRT()}}link(e,t,a,n){const r=new ar({from:e,to:a,fromIndex:t,toIndex:n},this);this._links.has(r.getKey())||this._links.set(r.getKey(),r),this._lastAutoLinkedName===void 0||e===this._lastAutoLinkedName||a!==void 0||this._autoLinkNow||(this.unlink(this._lastAutoLinkedName,0,void 0,0),this._lastAutoLinkedName=void 0),this._autoLinkNow=!1,this.graphChanged()}graphChanged(){this.topsort(),this.optimizeRT()}unlink(e,t,a,n){const r=new ar({from:e,to:a,fromIndex:t,toIndex:n},this);this._links.has(r.getKey())&&(this._links.delete(r.getKey()),r.unlink(),this.graphChanged())}topsort(){const e={};this._links.forEach(t=>{t.from&&t.to&&(!e[t.from.name]&&(e[t.from.name]=new Set),e[t.from.name].add(t.to.name))}),this._orderedFilters.length=0;const t=new Map;this._filters.forEach((a,n)=>{if(!this._topsort(n,e,t,this._orderedFilters))throw new Error(`[JS GPUFilter] Cannot sort filter, and system will not sort it again but give up :(!`)}),this._orderedFilters.reverse(),this._sorted=!0}optimizeRT(){if(!this._sorted)return;this._linkTexturePool.returnAll();const e={},t={};this._links.forEach(t=>{t.from!==void 0&&(!e.hasOwnProperty(t.from.name)&&(e[t.from.name]={in:[],out:[]}),e[t.from.name].out.push(t)),t.to!==void 0&&(!e.hasOwnProperty(t.to.name)&&(e[t.to.name]={in:[],out:[]}),e[t.to.name].in.push(t))});const a=e=>`${void 0===e.from?void 0:e.from.name}.${e.fromIndex}`;for(const n in this._orderedFilters){const r=this._orderedFilters[n],i=e[r.name]?e[r.name].in:[];for(const e of i)if(e.from!==void 0){const r=a(e);t.hasOwnProperty(r)||(t[r]=+n),t[r]=Math.max(t[r],+n)}r.clear()}for(const n in this._orderedFilters){const r=this._orderedFilters[n],i=e[r.name]?e[r.name].out:[];for(const e of i)this.populateTextureSlots(e);const o=e[r.name]?e[r.name].in:[];for(const e of o)if(e.from!==void 0){const r=a(e);t[r]<=+n&&this._linkTexturePool.return(e.from.getOutput(e.fromIndex))}else this.populateTextureSlots(e)}}populateTextureSlots(e){const t=e.fromIndex,a=e.toIndex;let n,r;n=e.from?e.from.getOutput(t):this.getInput(t),r=e.to?e.to.getInput(a):this.getOutput(a);let i;if(n===void 0&&r===void 0){if(e.from===void 0)return new Error("Invalid from-filter-node in filter link.");const a=e.from.getOutRTInfo(t,this._inputs[0]),n=this._linkTexturePool.get(a.width,a.height,a.colorFormat,a.filterMode);if(n instanceof Error)return n;i=n}if(void 0===n){var o;const a=null==(o=r)?i:o;e.from?e.from.setOutput(a,t):this.setInput(a,t)}if(void 0===r){var s;const t=null==(s=n)?i:s;e.to?e.to.setInput(t,a):this.setOutput(t,a)}e.to&&(e.to.needUpdateTexture=!0),e.from&&(e.from.needUpdateTexture=!0)}_topsort(e,t,a,n){if(a.has(e)&&1===a.get(e))return!0;if(a.has(e)&&0===a.get(e))return!1;if(a.set(e,0),t[e])for(const r of t[e])if(!this._topsort(r,t,a,n))return!1;return n.push(this._filters.get(e).filter),a.set(e,1),!0}setHook(e,t){this._filters.get(e).hook=t}onUpdate(e){if(!this._running)return;let t=!1;this._sorted||(console.warn(`[JS GPUFilter] Och, have to sort filter because you forgot to do that!`),this.topsort(),this.optimizeRT(),t=!0);for(const a of this._orderedFilters)if(a.needUpdateTexture){t=!0,this.clearCommandBuffer();break}for(const a of this._orderedFilters){if(t&&(a.needUpdateTexture=!0),a.getNeedBreak()&&a.needUpdateTexture&&this.addCmdBuffer(),a.onUpdate(e,this.commandBuffer,this._texturePool),this._debug){const e=this._filters.get(a.name).hook;void 0!==e&&this.addCmdBuffer()}this._texturePool.returnAll()}}clearCommandBuffer(){for(const e of this._cmdBufferQueue)e.clearAll();this._currentCmdBufferIndex=0}toString(){return JSON.stringify(this.serialize())}}class sr{constructor(){this._filterGraphs=new Map}static getInstance(){return null==this._instance&&(this._instance=new sr),this._instance}static create(e){const t=this.getInstance();if(t._filterGraphs.has(e))return new Error("Cannot create duplicated graph name.");if(""===e)return new Error("Cannot create empty name graph.");else{const a=new or;return t._filterGraphs.set(e,a),a}}static remove(e){const t=this.getInstance();let a="";if(e instanceof or){for(const[n,r]of t._filterGraphs)if(r===e){a=n;break}}else a=e;if(t._filterGraphs.has(a)){const e=t._filterGraphs.get(a);null==e?void 0:e.clear(),t._filterGraphs.delete(a)}else return new Error("Cannot find target graph in the system!")}static get(e){const t=this.getInstance();return t._filterGraphs.has(e)?t._filterGraphs.get(e):new Error("Cannot find target graph!")}static get size(){const e=this.getInstance();return e._filterGraphs.size}init(){for(const e of this._filterGraphs.values())e.init()}onUpdate(e){for(const t of this._filterGraphs.values())t.onUpdate(e)}}class dr extends e{constructor(){super(),this.hands=[],this._handProvider=new cr(this)}static getInstance(){return null==this._instance&&(this._instance=new dr),this._instance}static get hands(){return this.getInstance().hands}static on(e,t,a){return this.getInstance().on(e,t,a)}static off(e,t,a){return this.getInstance().off(e,t,a)}onUpdate(){this._handProvider.onUpdate()}init(){}setHandState(e,t){e?this.fire(exports.HandEvent.Detected,t):this.fire(exports.HandEvent.Lost,t)}setHandActionState(e,t){t!==exports.HandStaticGesture.None&&t!==exports.HandStaticGesture.Unknown&&this.fire(exports.HandEvent.StaticGesture,e,t)}setHandSeqActionState(e,t){t!==exports.HandDynamicGesture.None&&this.fire(exports.HandEvent.DynamicGesture,e,t)}}class lr{constructor(){this._handInfo=null}getKeyPoint2D(e){return 1===this._handInfo.key_points_is_detect.get(e)?new oe(this._handInfo.key_points_xy.get(e)):null}getKeyPointOffset3D(e){return 1===this._handInfo.key_points_3d_is_detect.get(e)?new $(this._handInfo.key_points_3d.get(e)):null}get isLeftProbability(){return this._handInfo.left_prob}get isLeft(){return!(.5>this.isLeftProbability)}get id(){return this._handInfo.ID}get scale(){return this._handInfo.scale}get rotation(){const e=this.getKeyPoint2D(9),t=this.getKeyPoint2D(12);if(null==t||null==e)return 0;const a=t.x-e.x,n=t.y-e.y,r=Math.sqrt(a*a+n*n);return 180*(-a/Math.abs(a)*Math.acos(n/r))/Math.PI}get staticGesture(){return this._handInfo.action}get dynamicGesture(){return this._handInfo.seq_action}}class cr{constructor(e){this._mgr=e,this.lastHandIdSet=new Set,this.ActIDMap=new Map,this.SeqActIDMap=new Map}onUpdate(){const e=Li.algorithms.nativeResult;if(e&&e.getHandCount){const t=e.getHandCount();this._mgr.hands=Array(t);const a=new Set;if(0<t){for(let n=0;n<t;n++){const t=e.getHandInfo(n),r=new lr;this._mgr.hands[n]=r,null!=t&&(r._handInfo=t,!this.lastHandIdSet.has(r.id)&&this._mgr.setHandState(!0,r.id),this.ActIDMap.has(r.id)?this.ActIDMap.get(r.id)!==r.staticGesture&&(this._mgr.setHandActionState(r.id,r.staticGesture),this.ActIDMap.set(r.id,r.staticGesture)):(this.ActIDMap.set(r.id,r.staticGesture),this._mgr.setHandActionState(r.id,r.staticGesture)),this.SeqActIDMap.has(r.id)?this.SeqActIDMap.get(r.id)!==r.dynamicGesture&&(this._mgr.setHandSeqActionState(r.id,r.dynamicGesture),this.SeqActIDMap.set(r.id,r.dynamicGesture)):(this.SeqActIDMap.set(r.id,r.dynamicGesture),this._mgr.setHandSeqActionState(r.id,r.dynamicGesture)),a.add(r.id))}for(const e of this.lastHandIdSet.values())a.has(e)||this._mgr.setHandState(!1,e);for(const e of this.ActIDMap.keys())a.has(e)||this.ActIDMap.delete(e);for(const e of this.SeqActIDMap.keys())a.has(e)||this.SeqActIDMap.delete(e);this.lastHandIdSet.clear(),a.forEach(e=>this.lastHandIdSet.add(e))}else{this.ActIDMap.clear(),this.SeqActIDMap.clear();for(const e of this.lastHandIdSet.values())this._mgr.setHandState(!1,e);this.lastHandIdSet.clear()}}}}class pr extends e{constructor(){super(),this.bodies=[],this._body2dProvider=new mr(this)}static getInstance(){return null==this._instance&&(this._instance=new pr),this._instance}static get bodies(){return this.getInstance().bodies}static on(e,t,a){return this.getInstance().on(e,t,a)}static off(e,t,a){return this.getInstance().off(e,t,a)}onUpdate(){this._body2dProvider.onUpdate()}init(){}setBodyState(e,t){e?this.fire(exports.BodyEvent.Detected,t):this.fire(exports.BodyEvent.Lost,t)}setBodyActionState(e,t){-1!==t&&this.fire(exports.BodyEvent.Action,e,t)}}class ur{constructor(){this._skeletonInfo=null,this._actionRecognitionInfo=null}get rect(){return new C(this._skeletonInfo.rect)}get id(){return this._skeletonInfo.ID}get keyPointDetected(){return this._skeletonInfo.key_points_detected}get keyPointsScore(){return this._skeletonInfo.key_points_score}get keyPoints(){return this._skeletonInfo.key_points_xy}get isActionValid(){var e,t;return null!=(e=null==(t=this._actionRecognitionInfo)?void 0:t.isValid)&&e}get actionLabel(){var e,t;return null==(e=null==(t=this._actionRecognitionInfo)?void 0:t.actionLabel)?-1:e}get actionScore(){var e,t;return null==(e=null==(t=this._actionRecognitionInfo)?void 0:t.actionScore)?0:e}}class mr{constructor(e){this._mgr=e,this.lastSkeletonIdSet=new Set,this.ActIDMap=new Map}onUpdate(){const e=Li.algorithms.nativeResult;if(e&&e.getSkeletonCount){const t=e.getSkeletonCount();this._mgr.bodies=Array(t);const a=new Set;if(0<t){for(let n=0;n<t;n++){const t=e.getSkeletonInfo(n);let r=null;e.getActionRecognitionInfo&&(r=e.getActionRecognitionInfo(n));const i=new ur;this._mgr.bodies[n]=i,null!=t&&(i._skeletonInfo=t,!this.lastSkeletonIdSet.has(i.id)&&this._mgr.setBodyState(!0,i.id),null!=r&&(i._actionRecognitionInfo=r,this.ActIDMap.has(i.id)?this.ActIDMap.get(i.id)!==i.actionLabel&&(this._mgr.setBodyActionState(i.id,i.actionLabel),this.ActIDMap.set(i.id,i.actionLabel)):(this.ActIDMap.set(i.id,i.actionLabel),this._mgr.setBodyActionState(i.id,i.actionLabel))),a.add(i.id))}for(const e of this.lastSkeletonIdSet.values())a.has(e)||this._mgr.setBodyState(!1,e);for(const e of this.ActIDMap.keys())a.has(e)||this.ActIDMap.delete(e);this.lastSkeletonIdSet.clear(),a.forEach(e=>this.lastSkeletonIdSet.add(e))}else{this.ActIDMap.clear();for(const e of this.lastSkeletonIdSet.values())this._mgr.setBodyState(!1,e);this.lastSkeletonIdSet.clear()}}}}class gr extends e{constructor(){super(),this._trackingMode=!1,this.bodies=[],this._Body3dProvider=new _r(this)}static getInstance(){return null==this._instance&&(this._instance=new gr),this._instance}static get bodies(){return this.getInstance().bodies}static on(e,t,a){return this.getInstance().on(e,t,a)}static off(e,t,a){return this.getInstance().off(e,t,a)}static get trackingMode(){return this.getInstance()._trackingMode}onUpdate(){this._Body3dProvider.onUpdate()}init(){}setBodyState(e,t){e?this.fire(exports.BodyEvent.Detected,t):this.fire(exports.BodyEvent.Lost,t)}}class fr{constructor(){this._avatar3DInfo=null}get id(){return this._avatar3DInfo.tracking_id}get root(){return new $(this._avatar3DInfo.root)}get focalLength(){return this._avatar3DInfo.focal_length}get isDetected(){return this._avatar3DInfo.detected}get jointRotations(){return this._avatar3DInfo.quaternion}get jointPositions(){return this._avatar3DInfo.joints}get imageHeight(){return this._avatar3DInfo.imageHeight}get imageWidth(){return this._avatar3DInfo.imageWidth}}class _r{constructor(e){this._mgr=e,this.lastAvatar3dIdSet=new Set}onUpdate(){const e=Li.algorithms.nativeResult;if(e&&e.getAvatar3DInfoTracking){this._mgr._trackingMode=e.getAvatar3DInfoTracking();const t=e.getAvatar3DInfoCount();this._mgr.bodies=Array(t);const a=new Set;if(0<t){for(let n=0;n<t;n++){const t=e.getAvatar3DInfo(n),r=new fr;this._mgr.bodies[n]=r,null!=t&&(r._avatar3DInfo=t,!this.lastAvatar3dIdSet.has(r.id)&&this._mgr.setBodyState(!0,r.id),a.add(r.id))}for(const e of this.lastAvatar3dIdSet.values())a.has(e)||this._mgr.setBodyState(!1,e);this.lastAvatar3dIdSet.clear(),a.forEach(e=>this.lastAvatar3dIdSet.add(e))}else{for(const e of this.lastAvatar3dIdSet.values())this._mgr.setBodyState(!1,e);this.lastAvatar3dIdSet.clear()}}}}class hr extends e{constructor(){super(),this.faces=[],this._AvatarDriveProvider=new vr(this)}static getInstance(){return null==this._instance&&(this._instance=new hr),this._instance}static get faces(){return this.getInstance().faces}static on(e,t,a){return this.getInstance().on(e,t,a)}static off(e,t,a){return this.getInstance().off(e,t,a)}onUpdate(){this._AvatarDriveProvider.onUpdate()}init(){}setAvatarDriveState(e,t){e?this.fire(exports.AvatarDriveEvent.Detected,t):this.fire(exports.AvatarDriveEvent.Lost,t)}}class yr{constructor(){this._avatarDriveInfo=null}get id(){return this._avatarDriveInfo.ID}get isTracking(){return!(1!==this._avatarDriveInfo.succ)}get channels(){return this._avatarDriveInfo.beta}}class vr{constructor(e){this._mgr=e,this.lastAvatarDriveIdSet=new Set}onUpdate(){const e=Li.algorithms.nativeResult;if(e&&e.getAvatarDriveCount){const t=e.getAvatarDriveCount();this._mgr.faces=Array(t);const a=new Set;if(0<t){for(let n=0;n<t;n++){const t=e.getAvatarDriveInfo(n),r=new yr;this._mgr.faces[n]=r,null!=t&&(r._avatarDriveInfo=t,!this.lastAvatarDriveIdSet.has(r.id)&&this._mgr.setAvatarDriveState(!0,r.id),a.add(r.id))}for(const e of this.lastAvatarDriveIdSet.values())a.has(e)||this._mgr.setAvatarDriveState(!1,e);this.lastAvatarDriveIdSet.clear(),a.forEach(e=>this.lastAvatarDriveIdSet.add(e))}else{for(const e of this.lastAvatarDriveIdSet.values())this._mgr.setAvatarDriveState(!1,e);this.lastAvatarDriveIdSet.clear()}}}}class Tr{constructor(){this._plugins={}}bufferToStr(e){const t=new Uint8Array(e),a=t.length,n=Array(a);for(let r=0;r<a;r++)n[r]=String.fromCharCode.call(null,t[r]);return n.join("")}start(){for(const e in this.loadPlugins(),this._plugins){const t=this._plugins[e];"function"==typeof t.onStart&&t.onStart()}}loadPlugins(){const e=Li.scene.native.assetMgr.rootDir,t=e+"js/plugins.json",a=fs.accessSync(t,0);if(a){const e=fs.readFileSync(t);if(null!=e)try{const t=this.bufferToStr(e),a=JSON.parse(t),n=a.plugins;for(const e in n){const t=n[e];this.initPlugin(t,e)}}catch(t){console.error("Failed to load plugins.json"),console.error(t)}}}initPlugin(e,t){if(0>=t.length)return null;const a=i.toPascalCase(t),n=require(a)[a],r=new n;return this._plugins[t]=r,r.init(Li.scene,e.config),r}update(e){for(const t in this._plugins){const a=this._plugins[t];"function"==typeof a.onUpdate&&a.onUpdate(e)}}lateUpdate(e){for(const t in this._plugins){const a=this._plugins[t];"function"==typeof a.onLateUpdate&&a.onLateUpdate(e)}}destroy(){for(const e in this._plugins){const t=this._plugins[e];"function"==typeof t.onDestroy&&t.onDestroy()}}event(e){for(const t in this._plugins){const a=this._plugins[t];"function"==typeof a.onEvent&&this._plugins[t].onEvent(e)}}get plugins(){return this._plugins}}var Cr=effect.Amaz;class xr{constructor(e,t){if(this._supportMemoryMapping=d.doesSDKSupport(u),e instanceof Cr.AABB)this._native=e;else if(e instanceof $&&t instanceof $){var a,n;this._native=new Cr.AABB(null==(a=e.native)?new Cr.Vector3f:a,null==(n=t.native)?new Cr.Vector3f:n)}else this._native=new Cr.AABB;this._supportMemoryMapping?(this._minVectorValues=new Float32Array(this._native.getMinVectorBuffer()),this._maxVectorValues=new Float32Array(this._native.getMaxVectorBuffer())):(this._minVectorValues=new Float32Array,this._maxVectorValues=new Float32Array)}static fromNative(e){return new xr(e)}static eq(e,t){return t&&e&&e.minX===t.minX&&e.minY===t.minY&&e.minZ===t.minZ&&e.maxX===t.maxX&&e.maxY===t.maxY&&e.maxZ===t.maxZ}get native(){return this._native}get minX(){return this._supportMemoryMapping?this._minVectorValues[xr.X]:this._native.min_x}set minX(e){this._supportMemoryMapping?this._minVectorValues[xr.X]=Math.fround(e):this._native.min_x=e}get minY(){return this._supportMemoryMapping?this._minVectorValues[xr.Y]:this._native.min_y}set minY(e){this._supportMemoryMapping?this._minVectorValues[xr.Y]=Math.fround(e):this._native.min_y=e}get minZ(){return this._supportMemoryMapping?this._minVectorValues[xr.Z]:this._native.min_z}set minZ(e){this._supportMemoryMapping?this._minVectorValues[xr.Z]=Math.fround(e):this._native.min_z=e}get maxX(){return this._supportMemoryMapping?this._maxVectorValues[xr.X]:this._native.max_x}set maxX(e){this._supportMemoryMapping?this._maxVectorValues[xr.X]=Math.fround(e):this._native.max_x=e}get maxY(){return this._supportMemoryMapping?this._maxVectorValues[xr.Y]:this._native.max_y}set maxY(e){this._supportMemoryMapping?this._maxVectorValues[xr.Y]=Math.fround(e):this._native.max_y=e}get maxZ(){return this._supportMemoryMapping?this._maxVectorValues[xr.Z]:this._native.max_z}set maxZ(e){this._supportMemoryMapping?this._maxVectorValues[xr.Z]=Math.fround(e):this._native.max_z=e}eq(e){return e&&this.minX===e.minX&&this.minY===e.minY&&this.minZ===e.minZ&&this.maxX===e.maxX&&this.maxY===e.maxY&&this.maxZ===e.maxZ}toString(){return`AABB(min: ${this.minX.toFixed(5)}, ${this.minY.toFixed(5)}, ${this.minZ.toFixed(5)},\n     max: ${this.maxX.toFixed(5)}, ${this.maxY.toFixed(5)}, ${this.maxZ.toFixed(5)})`}copy(e){return this.minX=e.minX,this.minY=e.minY,this.minZ=e.minZ,this.maxX=e.maxX,this.maxY=e.maxY,this.maxZ=e.maxZ,this}clone(){return new xr(this._native)}}xr.X=0,xr.Y=1,xr.Z=2;var Sr=effect.Amaz;class Mr{constructor(e=void 0){this.native=new Sr.SubMesh,this.name="no-name",this._primitive=P.TRIANGLES,this._mesh=void 0,e?this.native=e:(this.native=new Sr.SubMesh,this.native.primitive=this.primitive)}setIndices(e){e.forEach(e=>{this.native.indices16.pushBack(e)}),this.native.indicesCount=this.native.indices16.size()}get primitive(){return this._primitive}set primitive(e){this._primitive=e,this.native.primitive=this._primitive}get mesh(){return this._mesh?this._mesh:void 0}set mesh(e){e&&(this._mesh=e,this.native.mesh=e.native)}}class Fr{constructor(){this.vertexAttributeMapped=0,this._attributeCount=0,this.vertexAttributeMapped=0}setAttribute(e,t){this.hasAttribute(e)===t||(!0===t?this.attributeCount++:this.attributeCount--,this.vertexAttributeMapped|=+t<<+e)}hasAttribute(e){return 0<(this.vertexAttributeMapped&1<<e)}reset(){this.vertexAttributeMapped=0,this.attributeCount=0}get attributeCount(){return this._attributeCount}set attributeCount(e){this._attributeCount=e}}var Pr=effect.Amaz;class Rr{constructor(){this.mask=new Fr,this.native=new Pr.Mesh,this.name="no name",this._submeshses=[]}addSubMesh(e){var t;return null==(t=this.submeshes)?void 0:t.push(e),this.submeshes[this.submeshes.length-1].mesh=this,this.native.addSubMesh(e.native),this.submeshes[this.submeshes.length-1]}setSubMeshPrimitive(e,t){return e>=this.submeshes.length||0>e?void console.error("Index: "+e+" is out of range"):void(this.submeshes[e].primitive=t)}getSubMesh(e){return e>=this.submeshes.length?void console.error("Index: "+e+" is out of range"):this.submeshes[e]}getSubMeshCount(){return this.submeshes.length}clearVertexData(){this.mask.reset()}get submeshes(){return this._submeshses}set submeshes(e){if(e){this._submeshses=e,this.native.submeshes.clear();for(let t=0;t<e.length;++t)this.native.submeshes.pushBack(e[t].native)}}}var Ar=effect.Amaz.VertexAttribType,Ir=effect.Amaz;class br extends Rr{constructor(e,t){if(super(),this._aabb=new xr,e instanceof Ir.Mesh)this.native=e;else{const a=e;this.populateVertexDesc(a);const n=a.positions;if(n&&0<n.length){const e=new Ir.Vec3Vector;n.forEach(t=>{e.pushBack(new Ir.Vector3f(t.x,t.y,t.z))}),this.native.setVertexArray(e,0,e.size(),!1)}const r=a.colors;if(r&&0<r.length){const e=new Ir.Vec4Vector;r.forEach(t=>{e.pushBack(new Ir.Vector4f(t.r,t.g,t.b,t.a))}),this.native.setColorArray(e,0,e.size())}const i=a.uvs;if(i&&0<i.length){const e=new Ir.Vec2Vector;i.forEach(t=>{e.pushBack(new Ir.Vector2f(t.x,t.y))}),this.native.setUvArray(0,e,0,e.size())}const o=a.uv3ds;if(o&&0<o.length){const e=new Ir.Vec3Vector;o.forEach(t=>{e.pushBack(new Ir.Vector3f(t.x,t.y,t.z))}),this.native.setUv3DArray(0,e,0,e.size())}const s=a.normals;if(s&&0<s.length){const e=new Ir.Vec3Vector;s.forEach(t=>{e.pushBack(new Ir.Vector3f(t.x,t.y,t.z))}),this.native.setNormalArray(e,0,e.size())}const d=t;let l=!1,c=P.TRIANGLES,p=0,u=this.native.getVertexCount();if(d&&(l=!!d.customIndices&&d.customIndices,c=d.primitive?d.primitive:P.TRIANGLES,p=d.offset?d.offset:0,u=d.vertCount?d.vertCount:u),c===P.TRIANGLES||l){if(null!=e&&e.submeshes&&Array.isArray(null==e?void 0:e.submeshes[0])){const t=null==e?void 0:e.submeshes;for(let e=0;e<t.length;++e){const a=this.addSubMesh(new Mr);for(let n=0;n<t[e].length;++n)a.native.indices16.pushBack(t[e][n]);a.native.indicesCount=a.native.indices16.size(),a.primitive=c}}else if(null!=e&&e.submeshes&&Array.isArray(null==e?void 0:e.submeshes)){const t=null==e?void 0:e.submeshes,a=this.addSubMesh(new Mr);for(let e=0;e<t.length;++e)a.native.indices16.pushBack(t[e]);a.native.indicesCount=a.native.indices16.size(),a.primitive=c}}else if(c===P.TRIANGLE_FAN||c===P.TRIANGLE_STRIP){const e=this.addSubMesh(new Mr);for(let t=p,a=0;a<u;++t,++a)e.native.indices16.pushBack(t);e.native.indicesCount=e.native.indices16.size(),e.primitive=c}a.calculateTangents&&this.calculateTangents();const m=a.tangents;if(m&&0<m.length){const e=new Ir.Vec4Vector;m.forEach(t=>{e.pushBack(new Ir.Vector4f(t.x,t.y,t.z,t.w))}),this.native.setTangentArray(e,0,e.size())}this.calculateAABB()}}populateVertexDesc(e){const t=new Ir.Vector;if(e.positions&&0<e.positions.length){const e=new Ir.VertexAttribDesc;e.semantic=Ar.POSITION,this.mask.setAttribute(e.semantic,!0),t.pushBack(e)}if(e.colors&&0<e.colors.length){const e=new Ir.VertexAttribDesc;e.semantic=Ar.COLOR,this.mask.setAttribute(e.semantic,!0),t.pushBack(e)}if(e.uvs&&0<e.uvs.length){const e=new Ir.VertexAttribDesc;e.semantic=Ar.TEXCOORD0,this.mask.setAttribute(e.semantic,!0),t.pushBack(e)}if(e.uv3ds&&0<e.uv3ds.length){const e=new Ir.VertexAttribDesc;e.semantic=Ar.TEXCOORD0,t.pushBack(e)}if(e.normals&&0<e.normals.length){const e=new Ir.VertexAttribDesc;e.semantic=Ar.NORMAL,this.mask.setAttribute(e.semantic,!0),t.pushBack(e)}if(e.tangents&&0<e.tangents.length||e.calculateTangents){const e=new Ir.VertexAttribDesc;e.semantic=Ar.TANGENT,this.mask.setAttribute(e.semantic,!0),t.pushBack(e)}this.native.vertexAttribs=t}calculateAABB(){var e=Number.MAX_VALUE,t=Number.MIN_VALUE,a=Math.min,n=Math.max;const r=this.native.getVertexCount(),o=this.native.getVertexArray(0,r);if(this.aabb&&0<o.size()){this.aabb.minX=e,this.aabb.minY=e,this.aabb.minZ=e,this.aabb.maxX=t,this.aabb.maxY=t,this.aabb.maxZ=t;for(let e=0;e<o.size();++e){const t=o.get(e);this.aabb.minX=a(t.x,this.aabb.minX),this.aabb.minY=a(t.y,this.aabb.minY),this.aabb.minZ=a(t.z,this.aabb.minZ),this.aabb.maxX=n(t.x,this.aabb.maxX),this.aabb.maxY=n(t.y,this.aabb.maxY),this.aabb.maxZ=n(t.z,this.aabb.maxZ)}}}calculateTangents(){if(!this.mask.hasAttribute(Ar.TANGENT))return console.error("Mesh did not have a tangents vertex attribute"),[];if(!this.mask.hasAttribute(Ar.POSITION))return console.error("Mesh did not have a position vertex attribute"),[];if(!this.mask.hasAttribute(Ar.NORMAL))return console.error("Mesh did not have a normals vertex attribute"),[];if(!this.mask.hasAttribute(Ar.TEXCOORD0))return console.error("Mesh did not have a uvs vertex attribute"),[];const e=new Ir.Vec4Vector,t=this.native.getVertexCount();for(let a=0;a<t;++a)e.pushBack(new Ir.Vector4f(0,0,0,0));this.native.setTangentArray(e,0,e.size()),this.native.reCalculateTangents();const a=[],n=this.native.getTangentArray(0,t);for(let e=0;e<n.size();++e){const t=n.get(e);a.push(new me(t.x,t.y,t.z,t.w))}return a}get aabb(){return this._aabb}set aabb(e){this._aabb=e,this.native.boundingBox=this._aabb.native}}class Er{constructor(e,t){this.name=e,this.resource=t}}class zr{constructor(){this._registry={x:""}}static getInstance(){return null==this._instance&&(this._instance=new zr),this._instance}bufferToStr(e){const t=new Uint8Array(e),a=t.length,n=Array(a);for(let r=0;r<a;r++)n[r]=String.fromCharCode.call(null,t[r]);return n.join("")}init(){try{const e=this.bufferToStr(fs.readFileSync(Li.scene.native.assetMgr.rootDir+"resourceMap.json"));this._registry=JSON.parse(e)}catch(t){console.warn("Unable to load resource map")}}getAssetUri(e){const t=this._registry[e];return t}}var Br=effect.Amaz;class Lr{destroy(){}get rootDir(){return Li.scene.native.assetMgr.rootDir}loadSync(e){if(!e.startsWith("share://")&&!e.startsWith("custom://")&&!fs.accessSync(this.rootDir+e,0))return console.error(`Cannot find asset at: ${e}`),null;let t=Li.scene.native.assetMgr.SyncLoad(e);if(t){t instanceof Br.Material?t=new Be({native:t}):t instanceof Br.Mesh&&(t=new br(t));const a=i.getFilename(e);t=new Er(a,t)}else console.error(`Failed to load: ${e}`);return t}loadResource(e){const t=zr.getInstance().getAssetUri(e),a=t?this.loadSync(t):this.loadSync(e);return a}}var Or=effect.Amaz;class kr{constructor(){this._nativeAlgoResult=null,this._nativeAlgoMgr=Or.AmazingManager.getSingleton("Algorithm")}get nativeResult(){return this._nativeAlgoResult}update(){var e;const t=null==(e=this._nativeAlgoMgr)?void 0:e.getAEAlgorithmResult();if(null==t)return void(this._nativeAlgoResult=null);const a=()=>null;"function"!=typeof t.getHandInfo&&(t.getHandInfo=a),"function"!=typeof t.getAvatar3DInfo&&(t.getAvatar3DInfo=a),"function"!=typeof t.getSkeletonInfo&&(t.getSkeletonInfo=a),"function"!=typeof t.getActionRecognitionInfo&&(t.getActionRecognitionInfo=a),"function"!=typeof t.getAvatar3DInfoCount&&(t.getAvatar3DInfoCount=()=>0),"function"!=typeof t.getFaceMeshInfo&&(t.getFaceMeshInfo=a),"function"!=typeof t.getFaceBaseInfo&&(t.getFaceBaseInfo=a),"function"!=typeof t.getFaceAttributeInfo&&(t.getFaceAttributeInfo=a),"function"!=typeof t.getFaceExtraInfo&&(t.getFaceExtraInfo=a),"function"!=typeof t.getFaceNewLandmarkInfo&&(t.getFaceNewLandmarkInfo=a),"function"!=typeof t.getAvatarDriveInfo&&(t.getAvatarDriveInfo=a),this._nativeAlgoResult=t}}class Nr extends e{constructor(e,t){super(),this._type=e,this._state=exports.GestureRecognizerState.Possible,this._touchGesture=t}get type(){return this._type}get state(){return this._state}set state(e){this._state=e,(e===exports.GestureRecognizerState.Began||e===exports.GestureRecognizerState.Ended||e===exports.GestureRecognizerState.Changed)&&this._touchGesture.fire(this._type,this)}reset(){}update(){}handleTouch(){}}var Dr=effect.Amaz;class wr extends Nr{constructor(e){super(exports.GestureType.Tap,e),this._tp1Pos=new Dr.Vector2f(0,0),this._tp1Time=0,this._touchPos=new Dr.Vector2f(0,0),this._maxDuration=.5,this._maxDeltaMovement=.02}get position(){return new oe(this._touchPos)}reset(){this._tp1Pos=new Dr.Vector2f(0,0),this._tp1Time=0,this._touchPos=new Dr.Vector2f(0,0)}handleTouch(e){if(this.state!==exports.GestureRecognizerState.Failed){const t=e.type;if(t===Dr.TouchType.TOUCH_BEGAN)1!==e.count&&(this.state=exports.GestureRecognizerState.Failed),this.state!==exports.GestureRecognizerState.Failed&&(this._tp1Pos=new Dr.Vector2f(e.x,e.y),this._tp1Time=e.time);else if(t===Dr.TouchType.TOUCH_MOVED){const t=new Dr.Vector2f(e.x,e.y),a=this._tp1Pos;(e.time-this._tp1Time>1e6*this._maxDuration||t.distance(a)>this._maxDeltaMovement)&&(this.state=exports.GestureRecognizerState.Failed)}else if(t===Dr.TouchType.TOUCH_ENDED||t===Dr.TouchType.TOUCH_CANCELED){const t=new Dr.Vector2f(e.x,e.y),a=this._tp1Pos;e.time-this._tp1Time<1e6*this._maxDuration&&t.distance(a)<this._maxDeltaMovement?(this._touchPos=t,this.state=exports.GestureRecognizerState.Ended):this.state=exports.GestureRecognizerState.Failed}}}}var Vr=effect.Amaz;class Gr extends Nr{constructor(e){super(exports.GestureType.Pan,e),this._initPos=new Vr.Vector2f(0,0),this._curPos=new Vr.Vector2f(0,0)}get initPosition(){return new oe(this._initPos)}get currentPosition(){return new oe(this._curPos)}get offset(){const e=new oe(this._curPos);return e.sub(new oe(this._initPos))}reset(){this._initPos=new Vr.Vector2f(0,0),this._curPos=new Vr.Vector2f(0,0)}handleTouch(e){if(this.state!==exports.GestureRecognizerState.Failed){const t=e.type;t===Vr.TouchType.TOUCH_BEGAN?(1!==e.count&&(this.state=exports.GestureRecognizerState.Failed),this.state!==exports.GestureRecognizerState.Failed&&(this._initPos=new Vr.Vector2f(e.x,e.y),this.state=exports.GestureRecognizerState.Began)):t===Vr.TouchType.TOUCH_MOVED?(this.state===exports.GestureRecognizerState.Began||this.state===exports.GestureRecognizerState.Changed)&&(this._curPos=new Vr.Vector2f(e.x,e.y),this.state=exports.GestureRecognizerState.Changed):(t===Vr.TouchType.TOUCH_ENDED||t===Vr.TouchType.TOUCH_CANCELED)&&(this.state===exports.GestureRecognizerState.Changed?this.state=exports.GestureRecognizerState.Ended:this.state=exports.GestureRecognizerState.Failed)}}}var Ur=effect.Amaz;class Hr extends Nr{constructor(e){super(exports.GestureType.Rotation,e),this._tp1Id=99,this._tp1Pos=new Ur.Vector2f(0,0),this._tp2Id=99,this._tp2Pos=new Ur.Vector2f(0,0),this._initDir=new Ur.Vector2f(0,0),this._lastYaw=0,this._deltaYaw=0,this._yaw=0}reset(){this._tp1Id=99,this._tp1Pos=new Ur.Vector2f(0,0),this._tp2Id=99,this._tp2Pos=new Ur.Vector2f(0,0),this._initDir=new Ur.Vector2f(0,0),this._lastYaw=0,this._deltaYaw=0,this._yaw=0}get rotation(){return this._yaw}get delta(){return this._deltaYaw}handleTouch(e){const t=e.type;if(this.state!==exports.GestureRecognizerState.Failed)if(t===Ur.TouchType.TOUCH_BEGAN){if(2<e.count)return void(this.state=exports.GestureRecognizerState.Failed);99===this._tp1Id?(this._tp1Id=e.pointerId,this._tp1Pos=new Ur.Vector2f(e.x,e.y)):99!==this._tp1Id&&this._tp1Id!==e.pointerId&&99===this._tp2Id&&(this._tp2Id=e.pointerId,this._tp2Pos=new Ur.Vector2f(e.x,e.y),this._initDir=this._tp1Pos.copy(),this._initDir.sub(this._tp2Pos),this.state=exports.GestureRecognizerState.Began)}else if(t!==Ur.TouchType.TOUCH_MOVED)(t===Ur.TouchType.TOUCH_ENDED||t===Ur.TouchType.TOUCH_CANCELED)&&(this.state===exports.GestureRecognizerState.Began||99!==this._tp1Id&&99===this._tp2Id?this.state=exports.GestureRecognizerState.Failed:this.state===exports.GestureRecognizerState.Changed&&(this.state=exports.GestureRecognizerState.Ended));else if(this._tp1Id===e.pointerId?this._tp1Pos=new Ur.Vector2f(e.x,e.y):this._tp2Id===e.pointerId&&(this._tp2Pos=new Ur.Vector2f(e.x,e.y)),this.state===exports.GestureRecognizerState.Began||this.state===exports.GestureRecognizerState.Changed){const e=this._tp1Pos.copy();e.sub(this._tp2Pos);const t=this._initDir;let a=e.angle(t);const n=t.x*e.y-t.y*e.x;0<n&&(a=-a),this._deltaYaw=a-this._lastYaw,this._yaw+=this._deltaYaw,this._lastYaw=a,this.state=exports.GestureRecognizerState.Changed}}}var jr=effect.Amaz;class Wr extends Nr{constructor(e){super(exports.GestureType.Pinch,e),this._tp1Id=99,this._tp1Pos=new jr.Vector2f(0,0),this._tp2Id=99,this._tp2Pos=new jr.Vector2f(0,0),this._scale=1,this._deltaScale=0,this._initDis=1,this._lastScale=1}get scale(){return this._scale}get delta(){return this._deltaScale}reset(){this._tp1Id=99,this._tp1Pos=new jr.Vector2f(0,0),this._tp2Id=99,this._tp2Pos=new jr.Vector2f(0,0),this._scale=1,this._initDis=1,this._deltaScale=0,this._lastScale=1}handleTouch(e){const t=e.type;if(this.state!==exports.GestureRecognizerState.Failed)if(t===jr.TouchType.TOUCH_BEGAN){if(2<e.count)return void(this.state=exports.GestureRecognizerState.Failed);99===this._tp1Id?(this._tp1Id=e.pointerId,this._tp1Pos=new jr.Vector2f(e.x,e.y)):99!==this._tp1Id&&this._tp1Id!==e.pointerId&&99===this._tp2Id&&(this._tp2Id=e.pointerId,this._tp2Pos=new jr.Vector2f(e.x,e.y),this._initDis=this._tp1Pos.distance(this._tp2Pos),this.state=exports.GestureRecognizerState.Began)}else t===jr.TouchType.TOUCH_MOVED?(this._tp1Id===e.pointerId?this._tp1Pos=new jr.Vector2f(e.x,e.y):this._tp2Id===e.pointerId&&(this._tp2Pos=new jr.Vector2f(e.x,e.y)),(this.state===exports.GestureRecognizerState.Began||this.state===exports.GestureRecognizerState.Changed)&&(this._lastScale=this._scale,this._scale=this._tp1Pos.distance(this._tp2Pos)/(this._initDis+1e-7),this._deltaScale=this._scale-this._lastScale,this.state=exports.GestureRecognizerState.Changed)):(t===jr.TouchType.TOUCH_ENDED||t===jr.TouchType.TOUCH_CANCELED)&&(this.state===exports.GestureRecognizerState.Began||99!==this._tp1Id&&99===this._tp2Id?this.state=exports.GestureRecognizerState.Failed:this.state===exports.GestureRecognizerState.Changed&&(this.state=exports.GestureRecognizerState.Ended))}}var Yr=effect.Amaz;class Xr extends Nr{constructor(e){super(exports.GestureType.LongPress,e),this._tp1Pos=new Yr.Vector2f(0,0),this._tp1Time=0,this._touchPos=new Yr.Vector2f(0,0),this._minDuration=.501,this._maxDeltaMovement=.02}get position(){return new oe(this._touchPos)}reset(){this._tp1Pos=new Yr.Vector2f(0,0),this._tp1Time=0,this._touchPos=new Yr.Vector2f(0,0)}handleTouch(e){if(this.state!==exports.GestureRecognizerState.Failed){const t=e.type;if(t===Yr.TouchType.TOUCH_BEGAN)1!==e.count&&(this.state=exports.GestureRecognizerState.Failed),this.state!==exports.GestureRecognizerState.Failed&&(this._tp1Pos=new Yr.Vector2f(e.x,e.y),this._tp1Time=e.time);else if(t===Yr.TouchType.TOUCH_MOVED){const t=new Yr.Vector2f(e.x,e.y),a=this._tp1Pos;t.distance(a)>this._maxDeltaMovement&&(this.state=exports.GestureRecognizerState.Failed)}else if(t===Yr.TouchType.TOUCH_ENDED||t===Yr.TouchType.TOUCH_CANCELED){const t=new Yr.Vector2f(e.x,e.y),a=this._tp1Pos;e.time-this._tp1Time>1e6*this._minDuration&&t.distance(a)<this._maxDeltaMovement?(this._touchPos=t,this.state=exports.GestureRecognizerState.Ended):this.state=exports.GestureRecognizerState.Failed}}}}var qr=effect.Amaz;class Kr extends Nr{constructor(e){super(exports.GestureType.DoubleTap,e),this._tp1Pos=new qr.Vector2f(0,0),this._tp1Time=0,this._tp1leaveTime=0,this._touchPos=new qr.Vector2f(0,0),this._maxDuration=.5,this._maxInterval=.2,this._maxDeltaMovement=.02,this._firstReady=!1,this._curTime=0}get position(){return new oe(this._touchPos)}reset(){this._tp1Pos=new qr.Vector2f(0,0),this._tp1Time=0,this._tp1leaveTime=0,this._touchPos=new qr.Vector2f(0,0),this._firstReady=!1}update(e){this._curTime+=e,this._firstReady&&this._curTime>this._maxInterval&&(this.state=exports.GestureRecognizerState.Failed,this._firstReady=!1,this._curTime=0)}handleTouch(e){if(this._curTime=0,this.state!==exports.GestureRecognizerState.Failed){const t=e.type;if(t===qr.TouchType.TOUCH_BEGAN){if(1!==e.count&&(this.state=exports.GestureRecognizerState.Failed),this.state!==exports.GestureRecognizerState.Failed){if(this._firstReady&&e.time-this._tp1leaveTime>1e6*this._maxInterval)return void(this.state=exports.GestureRecognizerState.Failed);this._tp1Pos=new qr.Vector2f(e.x,e.y),this._tp1Time=e.time,this._touchPos=new qr.Vector2f(e.x,e.y)}}else if(t===qr.TouchType.TOUCH_MOVED){const t=new qr.Vector2f(e.x,e.y),a=this._tp1Pos;(e.time-this._tp1Time>1e6*this._maxDuration||t.distance(a)>this._maxDeltaMovement)&&(this.state=exports.GestureRecognizerState.Failed)}else if(t===qr.TouchType.TOUCH_ENDED||t===qr.TouchType.TOUCH_CANCELED){const t=new qr.Vector2f(e.x,e.y),a=this._tp1Pos;if(e.time-this._tp1Time<1e6*this._maxDuration&&t.distance(a)<this._maxDeltaMovement){if(this._firstReady)return void(this.state=exports.GestureRecognizerState.Ended);this._tp1leaveTime=e.time,this._firstReady=!0}else this.state=exports.GestureRecognizerState.Failed}}}}var Zr=effect.Amaz;class Qr extends e{constructor(){super(),this._currentTouchNum=0,this._mockPoint=[],this._gestureRecognizers=new Map,this._gestureRecognizers.set(exports.GestureType.Tap,new wr(this)),this._gestureRecognizers.set(exports.GestureType.Pan,new Gr(this)),this._gestureRecognizers.set(exports.GestureType.Rotation,new Hr(this)),this._gestureRecognizers.set(exports.GestureType.Pinch,new Wr(this)),this._gestureRecognizers.set(exports.GestureType.LongPress,new Xr(this)),this._gestureRecognizers.set(exports.GestureType.DoubleTap,new Kr(this))}start(){}destroy(){}get tap(){return this._gestureRecognizers.get(exports.GestureType.Tap)}get pan(){return this._gestureRecognizers.get(exports.GestureType.Pan)}get rotation(){return this._gestureRecognizers.get(exports.GestureType.Rotation)}get pinch(){return this._gestureRecognizers.get(exports.GestureType.Pinch)}get longPress(){return this._gestureRecognizers.get(exports.GestureType.LongPress)}get doubleTap(){return this._gestureRecognizers.get(exports.GestureType.DoubleTap)}pushMockTouch(e){this._mockPoint.push(e.native)}popMockTouch(){this._mockPoint.pop()}update(e){for(const t of this._gestureRecognizers.keys()){const a=this._gestureRecognizers.get(t);a.update(e)}}_reset(){for(const e of this._gestureRecognizers.keys()){const t=this._gestureRecognizers.get(e);t.state=exports.GestureRecognizerState.Possible,t.reset()}}_countTouch(e){e.type===Zr.TouchType.TOUCH_BEGAN?this._currentTouchNum++:(e.type===Zr.TouchType.TOUCH_ENDED||e.type===Zr.TouchType.TOUCH_CANCELED)&&this._currentTouchNum--}_needReset(){for(const e of this._gestureRecognizers.keys()){const t=this._gestureRecognizers.get(e);if(t.state===exports.GestureRecognizerState.Possible)return!1}return!0}_handleTouch(e){0>=this._currentTouchNum&&this._needReset()&&(this._currentTouchNum=0,this._reset()),this._countTouch(e);for(const t of this._gestureRecognizers.keys()){const a=this._gestureRecognizers.get(t);a.handleTouch(e)}}_handleMockTouch(e){for(let t=0;t<this._mockPoint.length;t++){const a=this._mockPoint[t],n=new Zr.TouchPointer;n.x=a.x,n.y=a.y,n.type=e.type,n.pointerId=e.pointerId+t+1,n.time=e.time,n.size=e.size,n.force=e.force,n.count=e.count+t+1,this._handleTouch(n)}}onEvent(e){if(e.type===Zr.EventType.TOUCH){const t=e.args.get(0);this._handleTouch(t),this._handleMockTouch(t)}}}class Jr{constructor(e,t,a){this._type=e,this._caster=t,this._sceneObjects=a}get type(){return this._type}get caster(){return this._caster}get sceneObjects(){return this._sceneObjects}}var $r=effect.Amaz;class ei extends e{constructor(){super(...arguments),this._raycasterComps=new Map([[exports.ScreenRaycasterType.UI,[]],[exports.ScreenRaycasterType.TwoD,[]],[exports.ScreenRaycasterType.ThreeD,[]],[exports.ScreenRaycasterType.Other,[]],[exports.ScreenRaycasterType.AR,[]]]),this._respondOrder=[exports.ScreenRaycasterType.UI,exports.ScreenRaycasterType.TwoD,exports.ScreenRaycasterType.ThreeD,exports.ScreenRaycasterType.Other,exports.ScreenRaycasterType.AR],this._curTouchNum=0,this._touched=!1,this._fireEndedDirty=!1,this._respondType=exports.TouchRespondType.Once}get type(){return this._respondType}set type(e){this._respondType=e}get order(){return this._respondOrder}set order(e){this._respondOrder=e}start(){const e=Li.scene.findAllByComponent("ScreenRaycaster");for(let a=0;a<e.length;a++){var t;const n=e[a],r=n.getComponent("ScreenRaycaster");null==(t=this._raycasterComps.get(r.type))?void 0:t.push(r)}}destroy(){}update(){this._fireEndedDirty&&(this.fire(exports.ScreenRespondType.Ended),this._fireEndedDirty=!1)}_fireRespondEvent(e){for(const t of this._respondOrder){if(!this._raycasterComps.has(t))continue;const a=this._raycasterComps.get(t);for(let n=0;n<a.length;n++){const r=a[n];let i;if(i=t===exports.ScreenRaycasterType.UI?r.raycastUI(new oe(e.x,1-e.y)):r.raycastOBB(new oe(e.x,1-e.y)),0<i.length){const e=new Jr(r.type,r,i);this.fire(exports.ScreenRespondType.Respond,e),this._touched=!0}}}}onEvent(e){if(e.type===$r.EventType.TOUCH){const t=e.args.get(0);if(t.type===$r.TouchType.TOUCH_BEGAN){if(0>=this._curTouchNum&&(this._curTouchNum=0,this.fire(exports.ScreenRespondType.Began)),this._curTouchNum++,this._touched&&this._respondType===exports.TouchRespondType.Once)return;this._fireRespondEvent(new oe(t.x,t.y))}else t.type===$r.TouchType.TOUCH_MOVED?this._respondType===exports.TouchRespondType.Continuous&&this._fireRespondEvent(new oe(t.x,t.y)):(t.type===$r.TouchType.TOUCH_ENDED||t.type===$r.TouchType.TOUCH_CANCELED)&&(this._curTouchNum--,0>=this._curTouchNum&&(this._curTouchNum=0,this._fireEndedDirty=!0,this._touched=!1))}}}var ti=effect.Amaz;class ai extends e{constructor(){super(),this._volume=.5,this._lastNode=new ti.AMGAudioNode,this._module=ti.AmazingManager.getSingleton("AMGAudioModule"),this._audioProxy=this._module.createAudioProxy(new ti.Map),this._audioGraph=this._audioProxy.createAudioGraph(),this._volumeNode=this._audioGraph.createAudioNode("GainNode",new ti.Map),this._sinkNode=this._audioGraph.createAudioNode("SinkNode",new ti.Map),this._effectExtractorList=[]}addEffect(e){const t=e.toEffectNode(this._audioGraph,new ti.Map);this._effectExtractorList.push(t),this._lastNode.connect(t),this._lastNode=t}addExtractor(e){const t=e.toExtractorNode(this._audioGraph,new ti.Map);this._effectExtractorList.push(t),this._lastNode.connect(t),this._lastNode=t}onUpdate(){}onDestroy(){this._audioProxy.stop(),this._module.destroyAudioProxy(this._audioProxy)}get volume(){return this._volume}set volume(e){this._volume=e,this._volumeNode.gain=this._volume}}class ni extends ai{constructor(){super(),this._filePath="",this._numLoops=1,this._loopsDone=0,this._sourceConnected=!1,this._fileStarted=!1,this._startTime=0,this._endTime=-1,this._fileNode=this._audioGraph.createAudioNode("FileSourceNode",new ti.Map),this._lastNode=this._fileNode}init(){this._sourceConnected&&!this._fileStarted?(this._fileStarted=!0,0<this._startTime&&this._fileNode.setStartTime(this._startTime),this._endTime!==this._fileNode.getDuration()&&this._fileNode.setEndTime(this._endTime),(-1===this._numLoops||1<this._numLoops)&&this._fileNode.setLoop(!0),this._lastNode.connect(this._volumeNode),this._volumeNode.connect(this._sinkNode),this._volumeNode.pout(0).connect(this._sinkNode.pin(1)),this._audioProxy.useAudioGraph(this._audioGraph),this._audioProxy.start()):console.error("File source not set")}stop(){this._fileNode.stop(),this.fire(exports.AudioEvent.Stop)}onUpdate(){this._fileStarted&&this._loopsDone<this.loopsCompleted&&(this.fire(exports.AudioEvent.LoopCompletion),this._loopsDone=this.loopsCompleted,this.loopsCompleted===this._numLoops&&this.stop())}start(){this._fileNode.start(),this.fire(exports.AudioEvent.Play)}pause(){this._fileNode.pause(),this.fire(exports.AudioEvent.Pause)}resume(){this._fileNode.resume(),this.fire(exports.AudioEvent.Resume)}get filePath(){return this._filePath}set filePath(e){this._filePath=e,this._fileNode.setSource(this._filePath),0===this._fileNode.getDuration()?console.error("File not found"):(this._sourceConnected=!0,this._endTime=this._fileNode.getDuration())}get loopCount(){return this._numLoops}set loopCount(e){this._fileStarted?console.error("Cannot change loop count while file is running"):this._numLoops=e}get loopsCompleted(){return this._fileNode.getLoopCount()}get fileState(){return this._fileNode.getState()}get position(){return this._fileNode.getProgress()}get startTime(){return this._startTime}set startTime(e){this._fileStarted?console.error("Cannot change Start Time while file is running"):this._startTime=e}get endTime(){return this._endTime}set endTime(e){this._fileStarted?console.error("Cannot change End Time while file is running"):this._endTime=e}}class ri extends ai{constructor(){super(),this._musicNode=this._audioGraph.createAudioNode("MusicSourceNode",new ti.Map),this._lastNode=this._musicNode}init(){this._lastNode.connect(this._volumeNode),this._volumeNode.connect(this._sinkNode),this._volumeNode.pout(0).connect(this._sinkNode.pin(1)),this._audioProxy.useAudioGraph(this._audioGraph),this._audioProxy.start()}start(){this._musicNode.start(),this.fire(exports.AudioEvent.Play)}stop(){this._musicNode.stop(),this.fire(exports.AudioEvent.Stop)}}class ii extends ai{constructor(){super(),this._micNode=this._audioGraph.createAudioNode("MicSourceNode",new ti.Map),this._lastNode=this._micNode}init(){this._lastNode.connect(this._volumeNode),this._volumeNode.connect(this._sinkNode),this._volumeNode.pout(0).connect(this._sinkNode.pin(1)),this._audioProxy.useAudioGraph(this._audioGraph),this._audioProxy.start()}start(){this._micNode.start(),this.fire(exports.AudioEvent.Play)}stop(){this._micNode.stop(),this.fire(exports.AudioEvent.Stop)}}var oi=effect.Amaz;class si{constructor(){this._extractorNodeName="",this._nodeCreated=!1,this._resultsSet=!1,this._extractorNode=new oi.AMGAudioExtractorNode,this._extractorResults=new oi.AudioFeature,this._paramters=new Map}toExtractorNode(e,t){this._extractorNode=e.createAudioExtractorNode(this._extractorNodeName,t);for(const[a,n]of this._paramters)this._extractorNode.setParameter(a,n);return this._nodeCreated=!0,this._extractorNode}setNodeParamter(e,t){this._nodeCreated?console.error("Extractor Paramters can only be set before an AudioController starts"):this._paramters.set(e,t)}updateResults(){if(this._nodeCreated){const e=this._extractorNode.getResult();null!=e&&(this._extractorResults=e.featureList.popBack(),this._resultsSet=!0)}}parseSingleResult(){return this._resultsSet?this._extractorResults.values.get(0):-1}}class di extends si{constructor(){super(),this._numBands=8,this._extractorNodeName="spectrum_display",this._bands=[],this.setNodeParamter("num_output_bin",this._numBands)}get bandNumber(){return this._numBands}set bandNumber(e){1<e&&0==Math.log2(e)%1?(this._numBands=e,this.setNodeParamter("num_output_bin",this._numBands),this._bands=Array(this._numBands)):console.error("The band number must be a power of 2")}get bands(){this.updateResults();const e=this._extractorResults.values;for(let t=0;t<this._numBands;++t)this._bands[t]=e.get(t);return this._bands}get averageBand(){return this.bands.reduce((e,t)=>e+t,0)/this._numBands}}class li extends si{constructor(){super(),this._extractorNodeName="f0_detection"}get pitch(){return this.updateResults(),this.parseSingleResult()}}class ci extends si{constructor(){super(),this._extractorNodeName="beat_tracking"}get beats(){return this.updateResults(),this.parseSingleResult()}}class pi extends si{constructor(){super(),this._extractorNodeName="volume_detection"}get volumeAmplitude(){return this.updateResults(),this.parseSingleResult()}}class ui extends si{constructor(){super(),this._threshold=50,this._extractorNodeName="onset_detection"}get threshold(){return this._threshold}set threshold(e){this._threshold=e,this.setNodeParamter("threshold",e)}get rhythmPointAmplitude(){return this.updateResults(),this.parseSingleResult()}}var mi=effect.Amaz;class gi{constructor(){this._effectNodeName="",this._nodeCreated=!1,this._map=new mi.Map,this._effectNode=new mi.AMGAudioEffectNode}toEffectNode(e,t){return this._effectNode=e.createAudioEffectNode(this._effectNodeName,t),this._effectNode.setParameters(this._map),this._nodeCreated=!0,this._effectNode}setNodeParamter(e,t){this._nodeCreated?this._effectNode.setParameter(e,t):this._map.insert(e,t)}}class fi extends gi{constructor(){super(),this._roomSize=1.5,this._damping=.5,this._stereoBalance=.5,this._wet=.5,this._dry=.5,this._wetGain=.5,this._dryGain=.5,this._effectNodeName="reverb1"}get roomSize(){return this._roomSize}set roomSize(e){this._roomSize=e,this.setNodeParamter("room_size",this._roomSize)}get damping(){return this._damping}set damping(e){this._damping=e,this.setNodeParamter("damping",this._roomSize)}get stereoBalance(){return this._stereoBalance}set stereoBalance(e){this._stereoBalance=e,this.setNodeParamter("stereo_depth",this._roomSize)}get wet(){return this._wet}set wet(e){this._wet=e,this.setNodeParamter("wet",this._roomSize)}get dry(){return this._dry}set dry(e){this._dry=e,this.setNodeParamter("dry",this._roomSize)}get wetGain(){return this._wetGain}set wetGain(e){this._wetGain=e,this.setNodeParamter("wet_gaindB",this._roomSize)}get dryGain(){return this._dryGain}set dryGain(e){this._dryGain=e,this.setNodeParamter("dry_gaindB",this._roomSize)}}class _i extends gi{constructor(){super(),this._lowPass=4e3,this._highPass=500,this._effectNodeName="megaphone"}get lowPass(){return this._lowPass}set lowPass(e){this._lowPass=e,this.setNodeParamter("lpf_fc",this._lowPass)}get highPass(){return this._highPass}set highPass(e){this._highPass=e,this.setNodeParamter("hpf_fc",this._highPass)}}class hi extends gi{constructor(){super(),this._preGain=0,this._threshold=-24,this._attack=.003,this._release=.25,this._preDelay=.006,this._postGain=0,this._wet=1,this._effectNodeName="compressor"}get preGain(){return this._preGain}set preGain(e){this._preGain=e,this.setNodeParamter("pre_gain",this._preGain)}get threshold(){return this._threshold}set threshold(e){this._threshold=e,this.setNodeParamter("threshold",this._threshold)}get attack(){return this._attack}set attack(e){this._attack=e,this.setNodeParamter("attack",this._attack)}get release(){return this._release}set release(e){this._release=e,this.setNodeParamter("release",this._release)}get preDelay(){return this._preDelay}set preDelay(e){this._preDelay=e,this.setNodeParamter("pre_delay",this._preDelay)}get postGain(){return this._postGain}set postGain(e){this._postGain=e,this.setNodeParamter("post_gain",this._postGain)}get wet(){return this._wet}set wet(e){this._wet=e,this.setNodeParamter("wet",this._wet)}}class yi extends gi{constructor(){super(),this._delayTime=234,this._feedback=.2,this._wet=.2,this._dry=1,this._effectNodeName="delay"}get delayTime(){return this._delayTime}set delayTime(e){this._delayTime=e,this.setNodeParamter("delay_time",this._delayTime)}get feedback(){return this._feedback}set feedback(e){this._feedback=e,this.setNodeParamter("feedback",this._feedback)}get wet(){return this._wet}set wet(e){this._wet=e,this.setNodeParamter("wet",this._wet)}get dry(){return this._dry}set dry(e){this._dry=e,this.setNodeParamter("dry",this._dry)}}class vi extends gi{constructor(){super(),this._frequency=100,this._gain=1,this._quality=1,this._filterType=exports.AudioEffectFilterType.LowPass,this._effectNodeName="biquad_filter"}get frequency(){return this._frequency}set frequency(e){this._frequency=e,this.setNodeParamter("freq",this._frequency)}get gain(){return this._gain}set gain(e){this._gain=e,this.setNodeParamter("gain",this._gain)}get quality(){return this._quality}set quality(e){this._quality=e,this.setNodeParamter("quality",this._quality)}get filterType(){return this._filterType}set filterType(e){this._filterType=e,this.setNodeParamter("filter_type",this._filterType)}}class Ti extends gi{constructor(){super(),this._rate=1,this._amount=1,this._effectNodeName="vibrato"}get rate(){return this._rate}set rate(e){this._rate=e,this.setNodeParamter("rate",this._rate)}get amount(){return this._amount}set amount(e){this._amount=e,this.setNodeParamter("semitones",this._amount)}}class Ci extends gi{constructor(){super(),this._gate=.99,this._preGain=0,this._effectNodeName="climiter"}get gate(){return this._gate}set gate(e){this._gate=e,this.setNodeParamter("gate",this._gate)}get preGain(){return this._preGain}set preGain(e){this._preGain=e,this.setNodeParamter("pregain_dB",this._preGain)}}var xi=effect.Amaz,Si;const Mi=null==(Si=h.get(exports.Feature.Audio))?"":Si;class Fi{constructor(){this._audioControllers=[]}static getInstance(){return d.doesSDKSupport(Mi)?(null==this._instance&&(this._instance=new Fi),this._instance):(console.warn(`[Amazing JS]: current SDK version[${xi.VERSION}] is lower than the minimum required version[${Mi}] for audio module.`),null)}static createAudioController(e){if(!d.doesSDKSupport(Mi))return null;switch(e){case exports.AudioControllerType.File:const t=new ni;return this.getInstance()._audioControllers.push(t),t;case exports.AudioControllerType.Music:const a=new ri;return this.getInstance()._audioControllers.push(a),a;case exports.AudioControllerType.Mic:const n=new ii;return this.getInstance()._audioControllers.push(n),n;default:return console.error(`There is no audio ${e} controller`),null;}}static createAudioEffect(e){if(!d.doesSDKSupport(Mi))return null;return e===exports.AudioEffectType.Reverb?new fi:e===exports.AudioEffectType.Megaphone?new _i:e===exports.AudioEffectType.Compressor?new hi:e===exports.AudioEffectType.Delay?new yi:e===exports.AudioEffectType.Filter?new vi:e===exports.AudioEffectType.Vibrato?new Ti:e===exports.AudioEffectType.Limiter?new Ci:(console.error(`There is no ${e} effect`),null)}static createAudioExtractor(e){if(!d.doesSDKSupport(Mi))return null;return e===exports.AudioExtractorType.Energy?new di:e===exports.AudioExtractorType.PitchDetection?new li:e===exports.AudioExtractorType.BeatsDetection?new ci:e===exports.AudioExtractorType.VolumeDetection?new pi:e===exports.AudioExtractorType.OnsetDetection?new ui:(console.error(`There is no ${e} effect`),null)}onUpdate(){for(const e of this._audioControllers)e.onUpdate()}onDestroy(){for(const e of this._audioControllers)e.onDestroy()}}var Pi=effect.Amaz,Ri;const Ai=null==(Ri=h.get(exports.Feature.Analytics))?"":Ri,Ii="effect_api_js";class bi{constructor(){this._globalConfigs=new Map}static getInstance(){return d.doesSDKSupport(Ai)?(null==bi._instance&&(bi._instance=new bi),bi._instance):(console.warn(`[Amazing JS]: current SDK version[${Pi.VERSION}] is lower
        than the minimum required version[${Ai}]
        for analytics module.`),null)}destroy(){this._globalConfigs.clear()}static isTypeSupported(t){return["number","string"].includes(typeof t)}static packArray(e){return Array.isArray(e)?e.filter(bi.isTypeSupported).join(","):""}packData(e){const t=new Pi.Map;for(const[a,n]of this._globalConfigs)t.insert(a,n);for(const a in e){const n=e[a];Array.isArray(n)?t.set(a,bi.packArray(n)):bi.isTypeSupported(n)&&t.set(a,n)}return t}sendEvent(e,t){e||(e={}),t||(t=Ii);const a=this.packData(e),n=Pi.AmazingManager.getSingleton("AnalyticsManager");n.reportEvent(t,a)}setGlobalConfig(e){if(e)for(const t in e){const a=e[t];Array.isArray(a)?this._globalConfigs.set(t,bi.packArray(a)):bi.isTypeSupported(a)&&this._globalConfigs.set(t,a)}}hasGlobalProperty(e){return this._globalConfigs.has(e)}getGlobalProperty(e){return this.hasGlobalProperty(e)?this._globalConfigs.get(e):void 0}}class Ei extends e{constructor(e){super(),this._native=e}instantiate(e,t){let a;if(a=t?this._native.instantiateToEntity(t.native.scene,t.native,e):this._native.instantiateToScene(Li.scene.native,e),a)return Li.scene.sceneObjectFromNative(a);throw new Error("Cannot instantiate instance from prefab.")}get root(){return Li.scene.sceneObjectFromNative(this._native.getRootEntity())}}class zi extends e{constructor(){super(),this.prefabManager=effect.Amaz.AmazingManager.getSingleton("PrefabManager")}load(e){const t=this.prefabManager.loadPrefab(Li.assets.rootDir,e);return new Ei(t)}}var Bi=effect.Amaz;class Li extends e{constructor(e){super(),d.doesSDKSupport(c)||console.error(`[Amazing JS]: current SDK version[${Bi.VERSION}] is lower than the minimum required version[${c}]. Amazing JS might not be able run properly.`),this._algorithms=new kr,this._scene=new ua(e),this._assets=new Lr,this._customAssets=new fn;const t=e.getOutputRenderTexture();this._touch=new _a(t.width,t.height),this._plugins=new Tr,d.doesSDKSupport(p)?(this._touchRespond=new ei,this._touchGesture=new Qr):(this._touchRespond=null,this._touchGesture=null,console.warn(`[Amazing JS]: current SDK version[${Bi.VERSION}] is lower than the minimum required version[${p}] for touch gesture module.`)),this._audioFactory=Fi.getInstance(),this._analytics=bi.getInstance(),this._prefabs=new zi,Li._engine=this}static get sdkVersion(){return effect.Amaz.VERSION}static getFeatureMinSDKVersion(e){var t;return null==(t=h.get(e))?"":t}static get minRequiredSDKVersion(){return c}static get version(){return l}static get engine(){return this._engine}static get scene(){return this._engine._scene}static get plugins(){return this._engine._plugins}static get customAssets(){return this._engine._customAssets}static get touch(){return this._engine._touch}static get assets(){return this._engine._assets}static get algorithms(){return this._engine._algorithms}static get touchRespond(){return this._engine._touchRespond}static get touchGesture(){return this._engine._touchGesture}static get audioFactory(){return this._engine._audioFactory}static get analytics(){return this._engine._analytics}static get prefabs(){return this._engine._prefabs}static init(e){return void 0===this._engine?void(this._engine=new Li(e),this._engine.initModules()):void console.warn("Engine already initialized")}initModules(){Va.getInstance().init(),ka.getInstance().init(),dr.getInstance().init(),pr.getInstance().init(),gr.getInstance().init(),hr.getInstance().init(),sr.getInstance().init(),zr.getInstance().init(),this._customAssets.init()}static start(){var e,t;this.touch.start(),null==(e=this.touchRespond)?void 0:e.start(),null==(t=this.touchGesture)?void 0:t.start(),this.customAssets.start(),this.plugins.start();const a=this.plugins.plugins;for(const e in a)this._engine[e]=a[e];this._engine.fire("start")}static update(e){var t,a,n;this.algorithms.update(),null==(t=this.audioFactory)?void 0:t.onUpdate(),Va.getInstance().onUpdate(e),ka.getInstance().onUpdate(),dr.getInstance().onUpdate(),pr.getInstance().onUpdate(),gr.getInstance().onUpdate(),hr.getInstance().onUpdate(),null==(a=this.touchRespond)?void 0:a.update(e),null==(n=this.touchGesture)?void 0:n.update(e),sr.getInstance().onUpdate(e),this.customAssets.update(),this.plugins.update(e)}static lateUpdate(e){this.customAssets.lateUpdate(e),this.plugins.lateUpdate(e)}static destroy(){var e,t,a,n,r,i;null==(e=this.audioFactory)?void 0:e.onDestroy(),this.plugins.destroy(),this.customAssets.destroy(),this.assets.destroy(),null==(t=this.touch)?void 0:t.destroy(),null==(a=this.scene)?void 0:a.destroy(),null==(n=this.touchRespond)?void 0:n.destroy(),null==(r=this.touchGesture)?void 0:r.destroy(),null==(i=this.analytics)?void 0:i.destroy(),Li._engine=void 0}static event(e){this.touch&&this.touch.onEvent(e),this.touchRespond&&this.touchRespond.onEvent(e),this.touchGesture&&this.touchGesture.onEvent(e),this.plugins.event(e)}}Li._engine=void 0;class Oi extends e{constructor(){super(),this.hasGyroStarted=!1,this.hasGyroStarted=!1}destroy(){}start(){this.hasGyroStarted=!0}get hasStarted(){return this.hasGyroStarted}}var ki=effect.Amaz.VertexAttribType,Ni=effect.Amaz;class Di extends Rr{populateVertexDesc(e){const t=new Ni.Vector;if(e.positions&&0<e.positions.length){const e=new Ni.VertexAttribDesc;e.semantic=ki.POSITION,this.mask.setAttribute(e.semantic,!0),t.pushBack(e)}if(e.colors&&0<e.colors.length){const e=new Ni.VertexAttribDesc;e.semantic=ki.COLOR,t.pushBack(e)}this.native.vertexAttribs=t}constructor(e,t){if(super(),e instanceof Ni.Mesh)this.native=e;else{const a=e;this.populateVertexDesc(a);const n=a.positions;if(n){const e=new Ni.Vec3Vector;n.forEach(t=>{e.pushBack(new Ni.Vector3f(t.x,t.y,t.z))}),this.native.setVertexArray(e,0,e.size(),!1)}const r=a.colors;if(r){const e=new Ni.Vec4Vector;r.forEach(t=>{e.pushBack(new Ni.Vector4f(t.r,t.g,t.b,t.a))}),this.native.setColorArray(e,0,e.size())}const i=t;let o=!1,s=P.LINES,d=0,l=this.native.getVertexCount();if(i&&(o=!!i.customIndices&&i.customIndices,s=i.primitive?i.primitive:P.LINES,d=i.offset?i.offset:0,l=i.vertCount?i.vertCount:l),s===P.LINES||o){if(null!=e&&e.submeshes&&Array.isArray(e.submeshes[0])){const t=null==e?void 0:e.submeshes;for(let e=0;e<t.length;++e){const a=this.addSubMesh(new Mr);for(let n=0;n<t[e].length;++n)a.native.indices16.pushBack(t[e][n]);a.native.indicesCount=a.native.indices16.size(),a.primitive=s}}else if(null!=e&&e.submeshes&&Array.isArray(e.submeshes)){const t=null==e?void 0:e.submeshes,a=this.addSubMesh(new Mr);for(let e=0;e<t.length;++e)a.native.indices16.pushBack(t[e]);a.native.indicesCount=a.native.indices16.size(),a.primitive=s}}else if(s===P.LINE_LOOP||s===P.LINE_STRIP){const e=this.addSubMesh(new Mr);for(let t=d,a=0;a<l;++t,++a)e.native.indices16.pushBack(t);e.native.indicesCount=e.native.indices16.size(),e.primitive=s}}}}var wi=effect.Amaz.DrawTexture,Vi=effect.Amaz;class Gi extends Pe{constructor(e=void 0,t=0,a=0,n=0,r=void 0,i=void 0){super(),this._attachment=F.NONE,this._inputTexture=new Pe,this._massMode=M.NONE,this._colorFormat=S.RGBA8Unorm,this._realColorFormat=S.RGBA8Unorm,this._depthTexture=new wi,this._stencilTexture=new wi,this.native=new Vi.RenderTexture,e?e instanceof Vi.RenderTexture&&(this.native=e):(this.height=t,this.width=a,this.depth=n,r&&(this.wrapMode=r),i&&(this.filterMode=i),this.native.attachment=this.attachment,this.inputTexture.native&&(this.native.inputTexture=this.inputTexture.native),this.native.massMode=this.massMode,this.native.colorFormat=this.colorFormat,this.native.realColorFormat=this.realColorFormat,this.native.depthTexture=this.depthTexture,this.native.stencilTexture=this.stencilTexture)}get attachment(){return this._attachment}set attachment(e){this._attachment=e,this.native.attachment=this._attachment}get inputTexture(){return this._inputTexture}set inputTexture(e){this._inputTexture=e,this._inputTexture.native&&(this.native.inputTexture=this._inputTexture.native)}get massMode(){return this._massMode}set massMode(e){this._massMode=e,this.native.massMode=this._massMode}get colorFormat(){return this._colorFormat}set colorFormat(e){this._colorFormat=e,this.native.colorFormat=this._colorFormat}get realColorFormat(){return this._realColorFormat}set realColorFormat(e){this._realColorFormat=e,this.native.realColorFormat=this._realColorFormat}get depthTexture(){return this._depthTexture}set depthTexture(e){this._depthTexture=e,this.native.depthTexture=this._depthTexture}get stencilTexture(){return this._stencilTexture}set stencilTexture(e){this._stencilTexture=e,this.native.stencilTexture=this._stencilTexture}}class Ui{static getPlaneData(e,t,a,n,r,i,o,s=!1){const d=1/i,l=1/o,p=i+1,u=[],m=[],g=[],f=[];for(let c=0;c<o+1;c++){const i=c*(n*l)-.5*n;for(let n=0;n<p;n++){const o=n*(a*d)-.5*a,s=new $(o*e,i*t,.5*r);u.push(s);const p=new $(0,0,0<r?1:-1);m.push(p);const f=new oe(n*d,1-c*l);g.push(f)}}for(let l=0;l<o;l++)for(let e=0;e<i;e++){const t=e+p*l,a=e+p*(l+1),n=e+1+p*(l+1),r=e+1+p*l;f.push(t,a,r),f.push(a,n,r)}return{positions:u,normals:m,uvs:g,colors:[],uv3ds:[],tangents:[],calculateTangents:s,submeshes:f}}static createPlane(e,t,a,n,r,i,o){const s=Ui.getPlaneData(e,t,a,n,r,i,o),d=new br(s);return d}static createBoxMesh(e,t,a,n=!1){e*=2,t*=2,a*=2;const r=1,i=1,o=1;let s=0;const d=[],l=[],c=[],p=[],u=[],m=[],g=[],f=[],_=[];{const r=Ui.getPlaneData(-1,-1,a,t,e,o,i,n),u=r.positions.length;for(let e=0;e<u;++e)d.push(new $(r.positions[e].z,r.positions[e].y,r.positions[e].x)),l.push(new $(r.normals[e].z,r.normals[e].y,r.normals[e].x)),c.push(new oe(r.uvs[e].y,r.uvs[e].x));for(let e=0;e<r.submeshes.length;++e)p.push(r.submeshes[e]+s);s+=u}{const r=Ui.getPlaneData(1,-1,a,t,-e,o,i,n),p=r.positions.length;for(let e=0;e<p;++e)d.push(new $(r.positions[e].z,r.positions[e].y,r.positions[e].x)),l.push(new $(r.normals[e].z,r.normals[e].y,r.normals[e].x)),c.push(new oe(r.uvs[e].y,r.uvs[e].x));if(r.submeshes)for(let e=0;e<r.submeshes.length;++e)u.push(r.submeshes[e]+s);s+=p}{const p=this.getPlaneData(1,1,e,a,t,r,o,n),u=p.positions.length;for(let e=0;e<u;++e)d.push(new $(p.positions[e].x,p.positions[e].z,p.positions[e].y)),l.push(new $(p.normals[e].x,p.normals[e].z,p.normals[e].y)),c.push(new oe(p.uvs[e].x,p.uvs[e].y));for(let e=0;e<p.submeshes.length;++e)m.push(p.submeshes[e]+s);s+=u}{const p=this.getPlaneData(1,-1,e,a,-t,r,o,n),u=p.positions.length;for(let e=0;e<u;++e)d.push(new $(p.positions[e].x,p.positions[e].z,p.positions[e].y)),l.push(new $(p.normals[e].x,p.normals[e].z,p.normals[e].y)),c.push(new oe(p.uvs[e].x,p.uvs[e].y));for(let e=0;e<p.submeshes.length;++e)g.push(p.submeshes[e]+s);s+=u}{const o=this.getPlaneData(1,-1,e,t,a,r,i,n),p=o.positions.length;for(let e=0;e<p;++e)d.push(new $(o.positions[e].x,o.positions[e].y,o.positions[e].z)),l.push(new $(o.normals[e].x,o.normals[e].y,o.normals[e].z)),c.push(new oe(o.uvs[e].x,o.uvs[e].y));for(let e=0;e<o.submeshes.length;++e)f.push(o.submeshes[e]+s);s+=p}{const o=this.getPlaneData(-1,-1,e,t,-a,r,i,n),p=o.positions.length;for(let e=0;e<p;++e)d.push(new $(o.positions[e].x,o.positions[e].y,o.positions[e].z)),l.push(new $(o.normals[e].x,o.normals[e].y,o.normals[e].z)),c.push(new oe(o.uvs[e].x,o.uvs[e].y));for(let e=0;e<o.submeshes.length;++e)_.push(o.submeshes[e]+s);s+=p}const h=new br({positions:d,normals:l,uvs:c,calculateTangents:n,submeshes:[p,u,m,g,f,_]});return h}static getSphereData(e,t="full",a=16,n=16,r=0,i=!1){var o=Math.PI,s=Math.sin,d=Math.cos;const l=1/a,c=1/n,p=n/2,u=0;let m=n,g=1;"top"===t?m=p:"bottom"===t&&(m=p,g=-1);const f=[],_=[],h=[],y=[];for(let p=u;p<=m;++p){const t=p*o*c,n=s(t),i=d(t);for(let t=0;t<=a;++t){const a=2*t*o*l-.5*o,m=s(a),T=d(a),C=T*n,x=g*i,y=m*n,S=1-t*l,u=1-p*c;f.push(new $(C*e,r+x*e,y*e)),_.push(new $(C,x,y)),h.push(new oe(S,u))}}for(let o=u;o<m;++o)for(let e=0;e<a;++e){const t=o*(a+1)+e,n=t+a+1;0<g?(y.push(t+1,n,t),y.push(t+1,n+1,n)):(y.push(t,n,t+1),y.push(n,n+1,t+1))}return{positions:f,normals:_,uvs:h,colors:[],uv3ds:[],tangents:[],calculateTangents:i,submeshes:y}}static createSphereMesh(e,t=16,a=16,n=0){const r=Ui.getSphereData(e,"full",t,a,n);return new br(r)}static getCircleData(e,t=20,a=0,n=!1){var r=Math.PI,o=Math.sin,s=Math.cos;const d=0<=a?1:-1,l=[],c=[],p=[],u=[];if(0<e)for(let n=0;n<t;++n){const i=2*(n*(1/t))*r,m=o(i),g=s(i);l.push(new $(m*e,a,g*e)),c.push(new $(0,d,0)),p.push(new oe(1-.5*(m+1),.5*(g+1))),1<n&&(0<d?u.push(n-1,n,0):u.push(0,n,n-1))}return{positions:l,normals:c,uvs:p,colors:[],uv3ds:[],tangents:[],calculateTangents:n,submeshes:u}}static getConeData(e,t,a,n=5,r=20,i=!1){var o=Math.PI,s=Math.sin,d=Math.cos;const l=.5*e,c=[],p=[],u=[],m=[];if(0<e)for(let e=0;e<=n;++e)for(let i=0;i<=r;++i){const g=i*(1/r),f=e*(1/n),_=2*g*o,h=s(_),y=d(_),v=new $(h*t,-l,y*t),T=new $(h*a,l,y*a),C=$.lerp(v,T,f),x=T.sub(v).normalize(),S=new $(y,0,-h),M=$.cross(S,x).normalize();if(c.push(C.clone()),p.push(M.clone()),u.push(new oe(g,f)),e<n&&i<r){const t=e*(r+1)+i,a=e*(r+1)+(i+1),n=(e+1)*(r+1)+i,o=(e+1)*(r+1)+(i+1);m.push(t,a,n),m.push(a,o,n)}}return{positions:c,normals:p,uvs:u,colors:[],uv3ds:[],tangents:[],calculateTangents:i,submeshes:m}}static createCylinderMesh(e,t,a=5,n=20){const r=[],o=[],s=[],d=[],l=[],c=[];let p=0;{const a=this.getCircleData(e,n,.5*-t),l=a.positions.length;for(let e=0;e<l;++e)r.push(new $(a.positions[e].x,a.positions[e].y,a.positions[e].z)),o.push(new $(a.normals[e].x,a.normals[e].y,a.normals[e].z)),s.push(new oe(a.uvs[e].x,a.uvs[e].y));for(let e=0;e<a.submeshes.length;++e)d.push(a.submeshes[e]+p);p+=l}{const d=this.getConeData(t,e,e,a,n),c=d.positions.length;for(let e=0;e<c;++e)r.push(new $(d.positions[e].x,d.positions[e].y,d.positions[e].z)),o.push(new $(d.normals[e].x,d.normals[e].y,d.normals[e].z)),s.push(new oe(d.uvs[e].x,d.uvs[e].y));for(let e=0;e<d.submeshes.length;++e)l.push(d.submeshes[e]+p);p+=c}{const a=this.getCircleData(e,n,.5*t),d=a.positions.length;for(let e=0;e<d;++e)r.push(new $(a.positions[e].x,a.positions[e].y,a.positions[e].z)),o.push(new $(a.normals[e].x,a.normals[e].y,a.normals[e].z)),s.push(new oe(a.uvs[e].x,a.uvs[e].y));for(let e=0;e<a.submeshes.length;++e)c.push(a.submeshes[e]+p);p+=d}const u=new br({positions:r,normals:o,uvs:s,submeshes:[d,l,c]});return u}static createCapsule(e,t,a=5,n=20){let r=0;const o=[],s=[],d=[],l=[],c=[],p=[];{const c=this.getConeData(t,e,e,a,n),p=c.positions.length;for(let e=0;e<p;++e)o.push(new $(c.positions[e].x,c.positions[e].y,c.positions[e].z)),s.push(new $(c.normals[e].x,c.normals[e].y,c.normals[e].z)),d.push(new oe(c.uvs[e].x,c.uvs[e].y));for(let e=0;e<c.submeshes.length;++e)l.push(c.submeshes[e]+r);r+=p}{const a=this.getSphereData(e,"top",n,n,.5*t),l=a.positions.length;for(let e=0;e<l;++e)o.push(new $(a.positions[e].x,a.positions[e].y,a.positions[e].z)),s.push(new $(a.normals[e].x,a.normals[e].y,a.normals[e].z)),d.push(new oe(a.uvs[e].x,a.uvs[e].y));for(let e=0;e<a.submeshes.length;++e)c.push(a.submeshes[e]+r);r+=l}{const a=this.getSphereData(e,"bottom",n,n,.5*-t),l=a.positions.length;for(let e=0;e<l;++e)o.push(new $(a.positions[e].x,a.positions[e].y,a.positions[e].z)),s.push(new $(a.normals[e].x,a.normals[e].y,a.normals[e].z)),d.push(new oe(a.uvs[e].x,a.uvs[e].y));for(let e=0;e<a.submeshes.length;++e)p.push(a.submeshes[e]+r);r+=l}const u=new br({positions:o,normals:s,uvs:d,submeshes:[l,c,p]});return u}static createToursMesh(e,t,a=20,n=20){var r=Math.PI,o=Math.sin,s=Math.cos;const d=[],l=[],c=[],p=[];for(let u=0;u<=a;++u){const i=u*(1/a);for(let m=0;m<=n;++m){const g=m*(1/n),f=s(2*r*i),_=s(2*r*g),h=o(2*r*i),y=o(2*r*g);if(d.push(new $(_*(t+e*f),h*e,y*(t+e*f))),l.push(new $(_*f,h,y*f)),c.push(new oe(i,1-g)),u<a&&m<n){const e=u*(n+1)+m,t=(u+1)*(n+1)+m,a=u*(n+1)+(m+1),r=(u+1)*(n+1)+(m+1);p.push(e,t,a),p.push(t,r,a)}}}const u=new br({positions:d,normals:l,uvs:c,submeshes:p});return u}}class Hi{constructor(e,t){this._name=e,this._context=t}equals(e){return this._name===e.name}get name(){return this._name}get context(){return this._context}onEnter(){}onExit(){}onUpdate(){}onEvent(){}toString(){return`[${this._name}]`}}class ji{constructor(){this._registeredStates=new Map}setState(){}removeState(){}onUpdate(){}onEvent(){}registerState(e){this._registeredStates.has(e.name)&&console.log(`State [${e.name}] already registered! Overriding`),this._registeredStates.set(e.name,e)}}class Wi extends ji{constructor(){super(...arguments),this._currentStates=new Set}onUpdate(e){for(const t of this._currentStates){const a=this._registeredStates.get(t);a&&a.onUpdate(e)}}onEvent(e){for(const t of this._currentStates){const a=this._registeredStates.get(t);a&&a.onEvent(e)}}setState(e){if(!this._registeredStates.has(e))return void console.log(`Unrecognized state [${e}]`);const t=this._registeredStates.get(e);this._currentStates.has(e)||(t&&t.onEnter(),this._currentStates.add(e))}removeState(e){if(this._registeredStates.has(e)||console.log(`Unrecognized state [${e}]`),this._currentStates.has(e)){const t=this._registeredStates.get(e);t&&t.onExit(),this._currentStates.delete(e)}}}class Yi extends ji{constructor(){super(...arguments),this._currentState=null,this._transitions=new Map}addTransition(e,t){if(this._registeredStates.has(e)&&this._registeredStates.has(t)){this._transitions.has(e)||this._transitions.set(e,new Set);const a=this._transitions.get(e);a&&a.add(t)}}isValidTransition(e,t){const a=this._transitions.get(e);return!!a&&a.has(t)}setState(e){if(this._registeredStates.has(e)){if(this._currentState&&this.isValidTransition(this._currentState.name,e)){const e=this._currentState;e.onExit()}const t=this._registeredStates.get(e);t&&t.onEnter(),this._currentState=t}}removeState(e){this._currentState&&this._currentState.name===e&&(this._currentState.onExit(),this._currentState=null)}onUpdate(e){this._currentState&&this._currentState.onUpdate(e)}onEvent(e){this._currentState&&this._currentState.onEvent(e)}}exports.AABB=xr,exports.AbstractMesh=Rr,exports.AlignmentComponent=Ut,exports.Analytics=bi,exports.AnimationComponent=qt,exports.AudioComponent=Qt,exports.AudioFactory=Fi,exports.AvatarDrive=hr,exports.BlendFactor=k,exports.BlendOp=N,exports.Body2D=pr,exports.Body3D=gr,exports.ButtonComponent=ft,exports.CameraComponent=U,exports.CanvasComponent=$e,exports.CanvasScalerComponent=kt,exports.Collider3DComponent=re,exports.Color=v,exports.CompareOp=O,exports.ConvFilter=Mn,exports.CullFace=z,exports.DoubleTapGestureRecognizer=Kr,exports.Engine=Li,exports.Entity=ca,exports.EntityLayerMax=64,exports.EntityTagMax=w,exports.EventHandler=e,exports.FeatureMinSDKVersion=h,exports.FilterGraph=or,exports.FilterGraphRegistry=sr,exports.FilterMode=Fe,exports.FilterNode=_n,exports.FiniteStateMachine=Yi,exports.FrontFace=B,exports.GenericJoint3DComponent=Wt,exports.GeometryUtil=Ui,exports.Gyroscope=Oi,exports.Hand=dr,exports.Head=ka,exports.ImageComponent=Ze,exports.ImagePixelFormat=S,exports.LabelComponent=Bt,exports.LayoutComponent=wt,exports.LightComponent=pe,exports.LineMesh=Di,exports.LongPressGestureRecognizer=Xr,exports.MSAAMode=M,exports.Mat3=he,exports.Mat4=xe,exports.Material=Be,exports.Mesh=br,exports.ModelComponent=ke,exports.MultiToggleStateMachine=Wi,exports.OperatorFilter=Cn,exports.PanGestureRecognizer=Gr,exports.ParticleSystemComponent=we,exports.PinchGestureRecognizer=Wr,exports.PingpongFilter=Sn,exports.PolygonMode=L,exports.Prefab=Ei,exports.Primitive=P,exports.Quat=ve,exports.Rect=C,exports.RenderTexture=Gi,exports.RenderTextureAttachment=F,exports.RendererType=E,exports.RigidBody3DComponent=We,exports.RotationGestureRecognizer=Hr,exports.Scene=ua,exports.SceneObject=ca,exports.ScreenHitInfo=Jr,exports.ScreenRaycasterComponent=da,exports.ScreenTransformComponent=ea,exports.ScriptComponent=ia,exports.Segmentation=Va,exports.SeqAnimationComponent=it,exports.ShaderType=b,exports.SliderComponent=Rt,exports.SliderThumbComponent=bt,exports.SpriteComponent=at,exports.State=Hi,exports.SubMesh=Mr,exports.TapGestureRecognizer=wr,exports.Texture=Pe,exports.TextureFilterMipMapMode=I,exports.TextureFilterMode=A,exports.TextureWrapMode=R,exports.TouchDevice=_a,exports.TouchGesture=Qr,exports.TouchRespond=ei,exports.Trigger3DComponent=st,exports.UIColliderComponent=St,exports.UIEventSystemComponent=yt,exports.Vec2=oe,exports.Vec3=$,exports.Vec4=me,exports.WrapMode=Me,exports.XShader=Ee;